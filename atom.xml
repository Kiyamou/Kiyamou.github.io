<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>308实验室</title>
  
  
  <link href="http://yoursite.com/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2023-05-13T07:47:57.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Kiyamou</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>2023 立夏拾遗：流着泪 依然觉得很有幸呢</title>
    <link href="http://yoursite.com/2023/05/13/2023-Summerback/"/>
    <id>http://yoursite.com/2023/05/13/2023-Summerback/</id>
    <published>2023-05-13T07:47:57.000Z</published>
    <updated>2023-05-13T07:47:57.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>那冰川 与海岛 后来独自看过</p><p>流着泪 依然觉 得很有幸呢</p><p>——《和宇宙的温柔关联》</p></blockquote><p>电脑里存着之前没有写完的 Blog，时间过去的有点久了，强行续写也显得生涩，简单整理一下。</p><span id="more"></span><br /><blockquote><p>雨伞弄丢 在下雨天</p><p>还没回应 手机也没电</p><p>久别重逢 却赶时间</p><p>事与愿违天天不断上演</p><p>——《Too bad》</p></blockquote><p>我想到了一个盲点，或许能回答我的疑惑…</p><p>一点一点剥开洋葱，才能更好地认识世界、理解自己。</p><h3 id="蝉鸣声"><a href="#蝉鸣声" class="headerlink" title="蝉鸣声"></a>蝉鸣声</h3><p>进入夏天之后听的歌，大抵还是靠 B 站推荐和自行搜索，有不止一首印象很深的歌，但这里不打算全写。因为我突然意识到过去一些难忘的经历，事出有因。我是因为做了这些才有经历可以回忆，我是因为以一种合适的视角去切入和看待才有了回忆的美好。</p><h3 id="清醒梦"><a href="#清醒梦" class="headerlink" title="清醒梦"></a>清醒梦</h3><p>跑步的时候不听歌，因为会没法专心地呼吸，会打乱节奏。这是我开始听歌后一直的遵循。</p><p>一些记忆还未模糊，又是那样美好。</p><p>清醒梦。</p><h3 id="混沌场"><a href="#混沌场" class="headerlink" title="混沌场"></a>混沌场</h3><p>从某个角度讲，大学才是青涩的，先是不知道要干什么，再是找到一个方向却难于起步，最后变成感叹时间的浪费和思维的狭窄——“当初我为什么就不能这样想一想呢”。中学可不是这样，中学时大抵只有一个目标，就是中考高考，是成熟有明确目标的。论中学时的这种成熟程度，可能要胜过很多成年人。</p><p>所以在大学的时光里，有时候就处在薛定谔的状态，我不知道当前的努力是处在什么层次，我究竟是在沙漠里捡沙子，还是在鱼塘里清理杂土：我找不到一个更宏观地角度去评价自己，只有经历和结尾才值得猫是否活着。有时候回头看，我在一些时候的努力，就像是 Gal 初期里选对一个看似无关却关键的选项，后期再怎么折腾都不慌；而另一些时候的做法，就像是 Gal 里大脑宕机情商欠费反射弧可绕地球两圈人人为他着急跳脚甚至欲诛之而后快的男主，明明幸福就在身边，明明学习和成长的机会就在手边，却要放弃甚至无视这种可能。</p><p>所谓混沌。</p><h3 id="另位面"><a href="#另位面" class="headerlink" title="另位面"></a>另位面</h3><blockquote><p>所以就活在当下，享受每一个日常。</p><p>都接受它，你会变成一个，很完整的自己。</p></blockquote><p>我想变成一个完整的自己，所以在最近的工作生活中尽量去用心完成，不得过且过。我想表达出我的思考，同时贴合实际情况。我会把我的思考、智慧和精力用在应该用的地方和值得用的地方，让我的灵魂和现实合二为一，做完整的我。</p><blockquote><p>开心快乐地照顾好自己，其实就好像照顾好了整个世界一样</p></blockquote><blockquote><p>你怎么对待自己，就如同你怎么对待世界</p></blockquote><p>用心地去生活，一些仪式是必要的，一些细节是可以温暖人心改善生活和工作的，不是无聊地雕刻细节或无事找事的繁文缛节。</p><p>七月的夜晚，出人意料的不是那么热，还有徐徐微风。在夜晚的马路上，无论是散步还是骑车，都感觉干燥舒适。也许这就是没有其他事情缠身的生活。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;那冰川 与海岛 后来独自看过&lt;/p&gt;
&lt;p&gt;流着泪 依然觉 得很有幸呢&lt;/p&gt;
&lt;p&gt;——《和宇宙的温柔关联》&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;电脑里存着之前没有写完的 Blog，时间过去的有点久了，强行续写也显得生涩，简单整理一下。&lt;/p&gt;</summary>
    
    
    
    <category term="日记" scheme="http://yoursite.com/categories/%E6%97%A5%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>2022 端午：路灯熄灭，月色蔓延</title>
    <link href="http://yoursite.com/2022/06/03/2022-ReedFragrance/"/>
    <id>http://yoursite.com/2022/06/03/2022-ReedFragrance/</id>
    <published>2022-06-03T08:52:39.000Z</published>
    <updated>2022-06-03T08:52:39.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>这里没有新年只有场庆典</p><p>看路灯熄灭月色蔓延</p><p>无需深情与古怪的嘱托</p><p>别担心我 等告别的雨滴 下落</p><p>——《今夜的江滩公园没有烟花跨年》</p></blockquote><span id="more"></span><p>下班回家，因为划出了成片的封控区，K 着实绕了一段路。又赶着去买酱牛肉的香料，跑了好几家店。</p><p>“幸好在第一家店就买了山楂，后面的店全都没有。” K 暗自欣喜。虽然山楂的外包装已经落了一层灰尘，——但总好过没有。不知为何，K 突然想起了兰州旅行的经历。即使是在遍地面馆的兰州，想吃上一碗牛肉面，也要走上好长一段路。</p><p>回到家已经很晚，吃完饭泡好牛肉，K 打开电脑看白天大盘的走势。由于消息面的刺激，不到一个月，鄂电股份已经从低点一路上涨 50%。</p><p>看盘出神之时，手机嗡嗡地响了。网格员通知大家对面小区马上封控。K 起身走到窗边，成车的彩钢板已经运到，在路灯和月光下紧张施工。“明天上班又要绕路了…” K 多少有些懊恼，但又庆幸不是自己的小区。新一批闪存芯片样品即将交付，K 不想在这个时候缺席。</p><p>回到电脑桌边，险些打翻桌上的咖啡。K 这才想起路上买的咖啡。漫漫长夜，突然出现的饮料零食是最好的慰藉。不担心晚上失眠，K 直接掀开盖子准备喝，突然发现已经微凉的咖啡上顶着漂亮的还未散开的拉花。高度商业化的连锁咖啡店很少在意这种事情。也许是临近下班买咖啡的人不多，年轻的咖啡师终于等来一个顾客，于是心血来潮。</p><p>这是今天最开心的事情了，K 这样想着。</p><p>“端午快乐”</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;这里没有新年只有场庆典&lt;/p&gt;
&lt;p&gt;看路灯熄灭月色蔓延&lt;/p&gt;
&lt;p&gt;无需深情与古怪的嘱托&lt;/p&gt;
&lt;p&gt;别担心我 等告别的雨滴 下落&lt;/p&gt;
&lt;p&gt;——《今夜的江滩公园没有烟花跨年》&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="日记" scheme="http://yoursite.com/categories/%E6%97%A5%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>VapourSynth API4 体验</title>
    <link href="http://yoursite.com/2022/04/05/vs-api4/"/>
    <id>http://yoursite.com/2022/04/05/vs-api4/</id>
    <published>2022-04-05T14:21:59.000Z</published>
    <updated>2022-04-05T14:21:59.000Z</updated>
    
    <content type="html"><![CDATA[<p>2021 年 9 月下旬，VapourSynth 发布 R55 版本，从这一版本开始使用 API4。API4 的启用使大量脚本需要更新，一些滤镜似乎也需要做相应的适配。同时，由于大版本的升级和滤镜开发的迁移，配套的 IDE、对应的 Python 版本都需要关注一下。</p><span id="more"></span><h3 id="脚本-API4-适配"><a href="#脚本-API4-适配" class="headerlink" title="脚本 API4 适配"></a>脚本 API4 适配</h3><p>常见的 API 替换：</p><ul><li><p><code>core = vs.get_core()</code><br>-&gt; <code>from vapoursynth import core</code><br>-&gt; <code>core = vs.core</code></p></li><li><p>色彩空间 YCoCg 和 COMPAT 系列被弃用</p></li><li><p>内置函数的更新<br>比如 <code>AverageFrames()</code> 从 <code>misc</code> 迁移到 <code>std</code></p></li><li><p>命名规则中 <code>_</code> 从后缀变为前缀，避免和 Python 变量名冲突<br>比如<code>lambda_</code>改为<code>_lambda</code></p></li></ul><p>在调试中遇到过如下报错</p><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vbnet"><span class="hljs-symbol">analyse:</span> <span class="hljs-keyword">function</span> does <span class="hljs-built_in">not</span> <span class="hljs-keyword">take</span> argument(s) named _global<br></code></pre></td></tr></table></figure><p>可能是后缀变前缀，但滤镜没有适配导致的。后来直接升级 VapourSynth 和 Python 大版本就没有这个问题了。</p><h3 id="滤镜-API4-适配"><a href="#滤镜-API4-适配" class="headerlink" title="滤镜 API4 适配"></a>滤镜 API4 适配</h3><p>新版 API 对滤镜的影响有限，除了 Histogram 外暂时没有遇到因为 API 更新导致不可用的问题（也可能是我没注意到）。不过 API4 启用后不止一个滤镜发布了更新，稍稍关注一下。比如 fmtconv 久违近两年，连续发布多个更新。</p><p>一些 API 的变化：</p><ul><li><p>变量类型：</p><ul><li><code>VSFrameRef</code> -&gt; <code>VSFrame</code></li><li><code>VSFormat</code> -&gt; <code>VSVideoFormat</code></li></ul></li><li><p>函数（<code>prop</code> -&gt; <code>map</code>）</p><ul><li><code>propGetNode()</code> -&gt; <code>mapGetNode()</code></li><li><code>propSetInt()</code> -&gt; <code>mapSetInt()</code></li></ul></li></ul><p>官方 Doc 似乎还没有完全更新，没事看看 <a href="https://github.com/vapoursynth/vapoursynth/blob/master/src/core/vsapi.cpp">vsapi.cpp</a> 总是好的。</p><h3 id="依赖索引"><a href="#依赖索引" class="headerlink" title="依赖索引"></a>依赖索引</h3><ul><li><p>VapourSynth Organization 增加了数个滤镜，把一些滤镜从 VapourSynth 本体中剥离了出来。</p><p>部分滤镜指路：</p><ul><li>单张图像读写：<a href="https://github.com/vapoursynth/vs-imwri">vapoursynth&#x2F;vs-imwri</a></li><li>降噪与修复 Removegrain：<a href="https://github.com/vapoursynth/vs-removegrain">vapoursynth&#x2F;vs-removegrain</a></li><li>场匹配与删除重复帧（反胶卷过带）：<a href="https://github.com/vapoursynth/vivtc">vapoursynth&#x2F;vivtc</a></li><li>源滤镜 lsmas：<a href="https://github.com/AkarinVS/L-SMASH-Works">AkarinVS&#x2F;L-SMASH-Works</a></li></ul></li><li><p>越来越多的脚本放到了 Python Package Index（PyPI）上，所以动手前先试一下<code>pip install xxx</code>不是个坏主意。</p></li></ul><h3 id="IDE：从-VSEditor-到-VSEditor2"><a href="#IDE：从-VSEditor-到-VSEditor2" class="headerlink" title="IDE：从 VSEditor 到 VSEditor2"></a>IDE：从 VSEditor 到 VSEditor2</h3><p>我的 VSEditor 很久之前失去了语法高亮，时间太久想不起来当时搞了什么操作。删了重下、重装 VapourSynth 都无济于事。D9 论坛上提到删除 xx.config，但我这是 Windows 系统啊…</p><h4 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h4><p>顺势改用 VSEditor2。VSEditor2 目前更新到 R6.5。其中，R6.5 版本需要 <a href="https://github.com/DJATOM/LibP2P-Vapoursynth">LibP2P</a>，<a href="AkarinVS/vapoursynth-plugin">AkarinVS&#x2F;vapoursynth-plugin</a>，<a href="https://github.com/dubhater/vapoursynth-histogram">Histogram</a>。R6.4 及之前的 R6.x 版本不需要后两者。</p><p>但我在使用 R6.5 版本时 VSEditor2 发生崩溃，怀疑与 Histogram 有关。Histogram 在适配 API4 后未发布相应版本，并且似乎没有完全适配，简单改了代码编译后 VSEditor2 仍然崩溃。幸好 VSEditor2 的作者做了相应适配（<a href="https://github.com/gundamftw/vapoursynth-histogram">gundamftw&#x2F;vapoursynth-histogram</a>），R6.5 版本顺利运行。</p><p>应该说 VSEditor2 正处于开发阶段，加上新版 VapourSynth API 的启用可能引发潜在的问题，遇到问题多看看<a href="https://forum.doom9.org/showthread.php?t=181708">作者的帖子</a>是值得的。</p><h4 id="功能与界面"><a href="#功能与界面" class="headerlink" title="功能与界面"></a>功能与界面</h4><p>基本的功能都和 VSEidtor 保持了一致，右侧的工具栏提供了一些方便的小工具，比如单独查看 Y、U、V 各个平面，裁剪助手等，预览界面下方的进度条也让查找视频内容更加便捷。总之增添了不少人性化的细节。</p><p>但不得不吐槽一句，把预览界面和代码界面放到同一个窗口，取消原来单独的预览窗口，真是对小屏幕太不友好了。</p><h3 id="Python-版本升级"><a href="#Python-版本升级" class="headerlink" title="Python 版本升级"></a>Python 版本升级</h3><p>截至目前，最新版的 VapourSynth R58-RC2 仅适配 Python 3.10.x 版本和 Python 3.8.x 版本。</p><p>在调用脚本时遇上一个报错。</p><figure class="highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ceylon"><span class="hljs-string">&#x27;ABCMeta&#x27;</span> <span class="hljs-keyword">object</span> <span class="hljs-keyword">is</span> not subscriptable<br></code></pre></td></tr></table></figure><p>当时环境为 VapourSynth R57 + Python 3.8。这似乎是一个蛋疼的语言问题，直接升级版本到 VapourSynth R58-RC2 + Python 3.10，之后相安无事。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;2021 年 9 月下旬，VapourSynth 发布 R55 版本，从这一版本开始使用 API4。API4 的启用使大量脚本需要更新，一些滤镜似乎也需要做相应的适配。同时，由于大版本的升级和滤镜开发的迁移，配套的 IDE、对应的 Python 版本都需要关注一下。&lt;/p&gt;</summary>
    
    
    
    <category term="工具使用" scheme="http://yoursite.com/categories/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"/>
    
    
    <category term="VapourSynth" scheme="http://yoursite.com/tags/VapourSynth/"/>
    
  </entry>
  
  <entry>
    <title>子模块相关</title>
    <link href="http://yoursite.com/2022/03/18/git-submodule/"/>
    <id>http://yoursite.com/2022/03/18/git-submodule/</id>
    <published>2022-03-18T03:39:57.000Z</published>
    <updated>2022-03-18T03:39:57.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h3><h4 id="为项目添加子模块"><a href="#为项目添加子模块" class="headerlink" title="为项目添加子模块"></a>为项目添加子模块</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git submodule add &quot;repository-address&quot;<br></code></pre></td></tr></table></figure><p>上述命令会在项目根目录下建立一个与子模块同名的文件夹。同时在项目根目录新建<code>.gitmodules</code>文件，内容如下。</p><span id="more"></span><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[submodule &quot;repository-name&quot;]</span><br><span class="hljs-attr">path</span> = repository-name<br><span class="hljs-attr">url</span> = <span class="hljs-string">&quot;repository-address&quot;</span><br></code></pre></td></tr></table></figure><p>若需指定子模块的存储未知，可在上述命令后添加存储路径</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git submodule add &quot;repository-address&quot; deps/repository-name<br></code></pre></td></tr></table></figure><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git submodule init<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git submodule update --init<br></code></pre></td></tr></table></figure><h4 id="子模块的更新"><a href="#子模块的更新" class="headerlink" title="子模块的更新"></a>子模块的更新</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git submodule update --remote<br></code></pre></td></tr></table></figure><p>上述两个命令会更新所有（平级的）子模块，但不会涉及子模块的子模块。</p><p>若想对子模块的子模块进行初始化或者更新，需要进入相应子模块，重复执行上述命令。</p><h3 id="dirty-问题"><a href="#dirty-问题" class="headerlink" title="dirty 问题"></a>dirty 问题</h3><p>在已有的本地项目中更新子模块，更新后会在<code>Subproject commit xxxxxx</code>后出现后缀<code>-dirty</code>，表示这个子模块做了与远程仓库不同的修改。目前没有深究和找到确切的原因。但怀疑是子模块的子模块初始化&#x2F;版本错配导致的。使用<code>git status</code>查看项目整体状态如下。</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs vim">On branch master<br>Your branch <span class="hljs-keyword">is</span> <span class="hljs-keyword">up</span>-<span class="hljs-keyword">to</span>-date with <span class="hljs-string">&#x27;origin/master&#x27;</span>.<br>Changes not staged <span class="hljs-keyword">for</span> commit:<br>  (use <span class="hljs-string">&quot;git add &lt;file&gt;...&quot;</span> <span class="hljs-keyword">to</span> <span class="hljs-keyword">update</span> what will <span class="hljs-keyword">be</span> committed)<br>  (use <span class="hljs-string">&quot;git checkout -- &lt;file&gt;...&quot;</span> <span class="hljs-keyword">to</span> discard <span class="hljs-keyword">changes</span> in working directory)<br><br>        modified:   deps/repository-name (<span class="hljs-keyword">new</span> commits)<br><br><span class="hljs-keyword">no</span> <span class="hljs-keyword">changes</span> added <span class="hljs-keyword">to</span> commit (use <span class="hljs-string">&quot;git add&quot;</span> <span class="hljs-built_in">and</span>/<span class="hljs-built_in">or</span> <span class="hljs-string">&quot;git commit -a&quot;</span>)<br></code></pre></td></tr></table></figure><p>其中，子模块被标记了 modified，而且有新的 commit；同时我并没有对子模块的代码进行修改。所以基本能印证上述猜测。</p><p>在上一节提到，初始化&#x2F;更新子模块的子模块需要手动操作，这样就很有可能导致子模块版本与子模块的子模块版本不一致的问题。进而被标记为 dirty。</p><p>暂时也没有什么好的解决办法，把子模块的子模块删了，或者把整改子模块都删了，重新逐级手动初始化&#x2F;更新。</p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;基本命令&quot;&gt;&lt;a href=&quot;#基本命令&quot; class=&quot;headerlink&quot; title=&quot;基本命令&quot;&gt;&lt;/a&gt;基本命令&lt;/h3&gt;&lt;h4 id=&quot;为项目添加子模块&quot;&gt;&lt;a href=&quot;#为项目添加子模块&quot; class=&quot;headerlink&quot; title=&quot;为项目添加子模块&quot;&gt;&lt;/a&gt;为项目添加子模块&lt;/h4&gt;&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;code class=&quot;hljs shell&quot;&gt;git submodule add &amp;quot;repository-address&amp;quot;&lt;br&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;上述命令会在项目根目录下建立一个与子模块同名的文件夹。同时在项目根目录新建&lt;code&gt;.gitmodules&lt;/code&gt;文件，内容如下。&lt;/p&gt;</summary>
    
    
    
    <category term="工具使用" scheme="http://yoursite.com/categories/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"/>
    
    
    <category term="构建与编译" scheme="http://yoursite.com/tags/%E6%9E%84%E5%BB%BA%E4%B8%8E%E7%BC%96%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title>2021 年中书单/影评：只我是那个荒唐</title>
    <link href="http://yoursite.com/2021/07/11/2021-mid-books/"/>
    <id>http://yoursite.com/2021/07/11/2021-mid-books/</id>
    <published>2021-07-11T01:12:26.000Z</published>
    <updated>2021-07-11T01:12:26.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>风微凉 夜微茫 醉在了梦乡</p><p>那时候 谁都讲</p><p>世界偌大少年荒唐</p><p>而如今 闭眼想 只我是那个荒唐</p><p>——《今日重到苏澜桥》</p></blockquote><p>照例，记录 2020 年下半年和 2021 年上半年看过的书、剧等。</p><span id="more"></span><h3 id="学术类书籍"><a href="#学术类书籍" class="headerlink" title="学术类书籍"></a>学术类书籍</h3><h4 id="《三角级数》"><a href="#《三角级数》" class="headerlink" title="《三角级数》"></a>《三角级数》</h4><p>书名不止这四个字，记不清全名了…学院清理旧书时捡起来翻了翻。书的最后一章讲了一些比较…比较古典的求和计算之类的东西。很想拿走看看，但不知道这些旧书要怎么处理，就作罢了。</p><h3 id="泛学术类书籍"><a href="#泛学术类书籍" class="headerlink" title="泛学术类书籍"></a>泛学术类书籍</h3><h4 id="1-《高山仰止——唐敖庆和他的弟子们》"><a href="#1-《高山仰止——唐敖庆和他的弟子们》" class="headerlink" title="1.《高山仰止——唐敖庆和他的弟子们》"></a>1.《高山仰止——唐敖庆和他的弟子们》</h4><p>Sob 几年前写了一个推荐帖推荐这本书，买来读了之后确实如 Sob 所说，不是那种简单歌功颂德的书，里面的内容很具体很翔实。虽然表达方式有些模板化，但对于细节的描述和专业概念的表达是很不错的，化学专业出身的人读起来也不会觉得违和，能够从相对质朴平实的语言中感受到老一辈科研人员的努力认真。</p><h4 id="2-《线性代数的几何意义》"><a href="#2-《线性代数的几何意义》" class="headerlink" title="2.《线性代数的几何意义》"></a>2.《线性代数的几何意义》</h4><p>这本书还只是大概翻了翻，虽然当年线代老师讲得挺好的，坐标变换与旋转等涉及几何的内容也讲过，但看到这本书还是觉得很有价值。</p><h3 id="技术类书籍"><a href="#技术类书籍" class="headerlink" title="技术类书籍"></a>技术类书籍</h3><p>因为要离开学校了，所以抓紧最后的时间去图书馆转了转。</p><h4 id="1-《短线波段战法》"><a href="#1-《短线波段战法》" class="headerlink" title="1.《短线波段战法》"></a>1.《短线波段战法》</h4><p>主要是学到了一些基本的技术指标的概念，再深入的东西看是看了，但没怎么记住Orz…</p><h4 id="2-《原画梦-30天学会日系插画》"><a href="#2-《原画梦-30天学会日系插画》" class="headerlink" title="2.《原画梦 30天学会日系插画》"></a>2.《原画梦 30天学会日系插画》</h4><p>内容比较全面的一本书，适合新手吧。书本身是值得推荐的，但如果不是在图书馆一堆颇具历史感的书籍中鹤立鸡群，单看这个震惊变体的标题，我大概率是拒绝的。所以，这种夸张且令人不太舒服的标题，真的要屈从吗？</p><p>回到书本身，这本书大概真的是循序渐进，从基本的技法，到完整的人体框架，再细化各个部分。如果不讲人体框架，直接分解讲局部，我..可能是读不下去的。</p><h4 id="3-《路米斯经典美术课：人体素描》"><a href="#3-《路米斯经典美术课：人体素描》" class="headerlink" title="3.《路米斯经典美术课：人体素描》"></a>3.《路米斯经典美术课：人体素描》</h4><p>主要看了（静态）人体结构，还大致翻了一下动态人体。这两部分内容都可以和上面的插画教程对照着看。</p><p>静态人体自然是这本书讲得更全面，骨骼肌肉的种种类型、正视图侧视图等等很细致。动态人体部分各有千秋吧，虽然这本书很专业，但似乎上面的插画教程某些方面的干货更多一些。</p><h4 id="4-画法几何与阴影透视的相关书籍"><a href="#4-画法几何与阴影透视的相关书籍" class="headerlink" title="4. 画法几何与阴影透视的相关书籍"></a>4. 画法几何与阴影透视的相关书籍</h4><p>画法几何就是工程制图的plus版，虽然难度明显增大了，但内容还是相对熟悉的。阴影和透视这部分看了基础的透视概念。</p><h4 id="5-建筑素描的相关书籍"><a href="#5-建筑素描的相关书籍" class="headerlink" title="5. 建筑素描的相关书籍"></a>5. 建筑素描的相关书籍</h4><p>关于国内民居白描和英国建筑素描的两本书看的较多，还有一两本偏教材风格的素描画集也印象比较深。主要想看技术上的东西，特别是透视相关。但民居白描那本书意境上的东西更吸引人，倒不是那么展示教科书式的透视，大概白描和传统中国画还是很有关系的吧，书里还特别强调了故意把线画得歪一些，显得生动之类的。而经典素描的部分，不少作品的技法确实让我觉得震撼，透视和阴影的表现很到位。</p><h4 id="6-建筑设计的相关书籍"><a href="#6-建筑设计的相关书籍" class="headerlink" title="6. 建筑设计的相关书籍"></a>6. 建筑设计的相关书籍</h4><p>印象比较深的是一本医院建筑设计的图书，副标题大概是“带着脚镣跳舞”，也就是医院建筑的设计要在符合医疗需求的基础上进行。书中讲了一些偏医疗的东西，比如医疗技术的进步，由此带来了医院布局的几代发展。另外印象较深的书就是一本课程设计纪录，讲了一门建筑设计课上几个小组实际搭建建筑模型的事情。从配图上看，都是比较..前卫的设计吧。啊，我也不知道用什么词好。总之让我看到了四四方方房子之外的东西，特别是第一个小组的框架结构，很震撼，也比较漂亮。此外还有印象的就是一本讲欧洲历史建筑的书吧，讲了一些比较原始的建筑，其中的几幅插图还是很有意境的。</p><h3 id="音乐"><a href="#音乐" class="headerlink" title="音乐"></a>音乐</h3><h4 id="从-Hebe-到田馥甄"><a href="#从-Hebe-到田馥甄" class="headerlink" title="从 Hebe 到田馥甄"></a>从 Hebe 到田馥甄</h4><p>听了 2014 年一场原版配乐的《Super Star》，能明显看出田馥甄舞台表情和 00 年代时的区别。我一面听着不想长大、Super Star 在回忆，另一面在听着 2016 或 2017 年前后常听的田馥甄的歌，有种恍如隔世的感觉。不论是从 Hebe 到田馥甄的变化，还是听歌的我的变化。</p><p>我也不是明星，没有影像的记录。就算我会写日记，但很多经历和记忆、感受都随风飘散。所以去翻田馥甄的视频，不仅让我认识了曾经的 Hebe，也让我想起了当年的自己。这大概就是透过他人望出了外面的世界。</p><p>我模糊得记得在初中或者高中时期，大概是 2010 - 2013 年那段时间，看到过一篇关于田馥甄的报道，大概是那个时候才知道 Hebe 是田馥甄。我甚至朦胧得记得旧电脑里还存着一张当时报道的照片。但也只是看了报道而已，没有去听歌。</p><p>我有时候会有些许的感叹，为什么没有那个时候去听一听田馥甄的歌。</p><p>我自己心里也清楚，我的感叹，很大程度上是对我自己的旧时光的怀念。虽然我总是告诫自己不要这么留恋旧日时光，但年少的美好认真，是无法被磨灭的啊。</p><p>大概只有认真做自己，才能让未来的我去怀念现在的时光。只有认真做现在的事情，认真完善实行头脑中的想法，才能做到知行合一。所以，要有自己的生活，完全地做自己。</p><p>我自己给“知行合一”重新发明了一个含义，就是心里想的事情和实际做的事情一致，别心不在焉地做事。“风微凉 夜微茫 醉在了梦乡 &#x2F; 那时候 谁都讲 &#x2F; 世界偌大少年荒唐 &#x2F; 而如今 闭眼想 只我是那个荒唐”。某种程度上，“只我是那个荒唐”。或者具体点说，某一个时期无谓怀念心不在焉的我是那个荒唐。只我是那个荒唐，一种比较尖锐的批评就是，我自以为与世独立，却没有做好该做的事，我自认为在掩盖尴尬的事情，却把事情弄得更尴尬。高中有，大学更明显。所以，表里如一地做事，大方地生活，不要最后变得荒唐。</p><p>有点沉重了，“荒唐”这个词在 Hebe 开车时也常常出现，这里能插张图就会开心多了。</p><h3 id="影视"><a href="#影视" class="headerlink" title="影视"></a>影视</h3><h4 id="1-《我的青春恋爱物语果然有问题。完》"><a href="#1-《我的青春恋爱物语果然有问题。完》" class="headerlink" title="1.《我的青春恋爱物语果然有问题。完》"></a>1.《我的青春恋爱物语果然有问题。完》</h4><p>我几乎都要忘了这是 2020 年 7 月的番剧了，从 4 月跳票到 7 月…我现在印象已经模糊了…说实话，这部番大抵就是大老师和雪乃的发糖，大老师你还记得你在第一部开篇的现充爆炸论吗Orz…</p><h4 id="2-《路人女主的养成方法-Fine》"><a href="#2-《路人女主的养成方法-Fine》" class="headerlink" title="2.《路人女主的养成方法 Fine》"></a>2.《路人女主的养成方法 Fine》</h4><p>同上面提到的春物第三季，去年暑期看的，内容的记忆已经模糊了。尽管也是发糖，但还是没忘记创业番的主题，比起春物第三季要点个赞。</p><h4 id="3-《HELLO-WORLD》"><a href="#3-《HELLO-WORLD》" class="headerlink" title="3.《HELLO WORLD》"></a>3.《HELLO WORLD》</h4><p>去影院看了 Hello World，怎么说呢，毕竟从咬文嚼字的角度来说，是电影而不是剧场版；而我对电影中的艺术表现手法向来是不怎么关心的，所以就安静地看完了一个故事，也不知道做什么评价，不置可否。话说我现在像是一个刚学会用成语的小学生，不管合适不合适就想用个成语Orz…</p><h4 id="4-《工作细胞！！》"><a href="#4-《工作细胞！！》" class="headerlink" title="4.《工作细胞！！》"></a>4.《工作细胞！！》</h4><p>印象比较深的是有益菌那两集，有弹幕说是“小蝌蚪找妈妈”。工作细胞第二部只有大概 8 集，这应该是很明智的决定了。作为卖萌向的番剧，太长了可能会腻的，还不如像这样利落地结尾。</p><h4 id="5-《剃须。然后捡到女高中生。》"><a href="#5-《剃须。然后捡到女高中生。》" class="headerlink" title="5.《剃须。然后捡到女高中生。》"></a>5.《剃须。然后捡到女高中生。》</h4><p>追到一半暂时弃了，一开始觉得剧情设计不错，台词也是直来直去的不矫情。但几集过后就开始展现熟悉的剧情和套路。从批评地角度说，给人感觉是套了个新鲜外衣的常规故事。</p><h4 id="6-《名侦探柯南》"><a href="#6-《名侦探柯南》" class="headerlink" title="6.《名侦探柯南》"></a>6.《名侦探柯南》</h4><p>很久没看柯南了，去看了安室和厨师同场的那个篇章。我总觉得柯南是作画质量下降而非单纯的画风变化，特别怀念领妹和深夜动画那个时期的作画。当然日常剧情本身还是很欢乐的。</p><h4 id="7-《逃避虽可耻但有用》SP"><a href="#7-《逃避虽可耻但有用》SP" class="headerlink" title="7.《逃避虽可耻但有用》SP"></a>7.《逃避虽可耻但有用》SP</h4><p>结合了疫情的剧情，总体看上去是很温馨的。只是看到百合姐和风见分手有点惊讶，但确实如剧里所说，心理年龄的差距是绕不开的问题，一个人已经开始盘算退休之后的事情，另一个人却觉得人生才刚开始。</p><h4 id="8-《昨晚过得很愉快吧》"><a href="#8-《昨晚过得很愉快吧》" class="headerlink" title="8.《昨晚过得很愉快吧》"></a>8.《昨晚过得很愉快吧》</h4><p>很早之前就知道这个剧，冲着妹子的颜值去看的。妹子好看就完事了，剧情也是如童话一般。</p><h4 id="9-《真命天女》"><a href="#9-《真命天女》" class="headerlink" title="9.《真命天女》"></a>9.《真命天女》</h4><p>S.H.E 当年主演的偶像剧，当然现在已经不会为偶像剧的剧情着迷了，但令我惊讶的是，其中很多词语用法好熟悉。</p><h3 id="游戏"><a href="#游戏" class="headerlink" title="游戏"></a>游戏</h3><h4 id="1-《他人世界末》"><a href="#1-《他人世界末》" class="headerlink" title="1.《他人世界末》"></a>1.《他人世界末》</h4><p>《他人世界末》是去年看了月夜桥的推荐去玩的，一开始因为画风的问题暂时放弃，后来继续玩才感觉到，几个主要人物的立绘是不是出自不同的画师，画风差距略明显…</p><p>打通了沈岩线和木竹樱线两条线，还把关键剧情录了下来。在我玩过的 Gal 中，《他人世界末》是《高考恋爱 100 天》之外最让我感动和印象深刻的了，特别是沈岩线的 Happy Ending。夸张点说，这条线是对 Gal 剧本的一个创新。不管是单论 Gal，还是扩大到其他文艺作品，通常剧情发展到一个看似圆满的结局就结束了，即使有后日谈也是类似演唱会安可一样给粉丝的额外赠品。但沈岩线的 Happy Ending 花了相当的篇幅描写毕业之后的事情，也就是花了相当的篇幅写一般意义结局之后的事情；而作者想表达的思想，有一部分是在这个篇章中才体现的。这样的设计使剧本显得丰富完整，同时也更能引人思考。</p><p>剧本之外，在游戏的设计上，我还是想说，越玩 Gal 越觉得现实生活步履维艰…这个词或许有点太沉重，但我也想不出更贴切的词语。打出沈岩线的 Happy Ending 需要几个选项全部正确，包括早期一个看似无关紧要的选项。当然，客观地说，和《高考恋爱 100 天》比起来，《他人世界末》已经很讲武德了。在《高考恋爱 100 天》里想打出小涵线，需要在早期特定的某天去找小涵，这个不看攻略怕是不会有太多人能发现，特别是我没怎么玩过《高考恋爱 100 天》这种养成类的游戏，对这种选项更是不敏感。</p><h4 id="2-《爱人-Lover》"><a href="#2-《爱人-Lover》" class="headerlink" title="2.《爱人 Lover》"></a>2.《爱人 Lover》</h4><p>半年来也玩了不止一个游戏，印象好的有，印象不太好也有，但总觉得还在序章里打转，没 get 到作者的想法。想了想，除了《他人世界末》，能提笔写感受大概就是《爱人 Lover》了。也不是说这个游戏有多好，只是第一个篇章打完开头，就能感受到游戏的风格和立意。</p><p>这么多游戏玩下来，难免想吐槽一句，为什么主角都带有自闭画风啊。《爱人 Lover》的主角是女性，但几乎就可以说是经典 Gal 男性主角的翻版，羞于表达、隐藏情感、循规蹈矩。好吧，Gal 的目标群体真就只有宅男宅女了吗…</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;风微凉 夜微茫 醉在了梦乡&lt;/p&gt;
&lt;p&gt;那时候 谁都讲&lt;/p&gt;
&lt;p&gt;世界偌大少年荒唐&lt;/p&gt;
&lt;p&gt;而如今 闭眼想 只我是那个荒唐&lt;/p&gt;
&lt;p&gt;——《今日重到苏澜桥》&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;照例，记录 2020 年下半年和 2021 年上半年看过的书、剧等。&lt;/p&gt;</summary>
    
    
    
    <category term="日记" scheme="http://yoursite.com/categories/%E6%97%A5%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>一篇小木虫里的旧帖</title>
    <link href="http://yoursite.com/2021/04/14/trans-computer/"/>
    <id>http://yoursite.com/2021/04/14/trans-computer/</id>
    <published>2021-04-14T06:27:33.000Z</published>
    <updated>2021-04-14T06:27:33.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>这是 @yuerongzho 2012年12月发在小木虫的帖子，现在小木虫网站上已经看不到了，但我还存着，时隔几年再看依然感动，所以冒昧转到了个人博客上。</p></blockquote><blockquote><p>这篇帖子发布于2012年，距离现在已经9年。这9年间时过境迁，彼时移动互联网还没有爆发，深度学习还在打比赛，而现在转计算机已经成了各路专业大热的趋势。转这篇帖子，我个人的想法并不是进一步渲染转计算机的氛围，而是感受如何找到一个人想要的东西、如何去实现一个人的想法。</p></blockquote><span id="more"></span><p><strong>小硕毕业一年 从材料转做计算机</strong></p><p>硕士毕业就快一年了，昨天写年终总结，看着1、2.的一长串完成项目，就好像马拉松的中途，回头看看已经走下的这一路，原来我已不再紧张。从材料物理与化学到计算机，到现在敲着代码，看着方程式，弄着神经网络，回想起刚出来时的坎坷、迷茫，更多的是紧张和不安，现在却并没如释重负的感觉，一切显得那么平静。有时候同事会问你以前做什么的，我说做材料的，她们总会惊讶，那你怎么搞计算机了。呵呵，工作有时候就像女孩，遇到了才会惊讶。我想会有很多很多的小硕或博士有同样的梦想，将此生献给学术，这个圣神的事业，梦想着能有爱因斯坦般光辉的成就，就像《美丽心灵》中有一天别人将尊敬的钢笔放在你的面前，梦想着能在这一领域举足轻重，能够在学术上游刃有余。直到实验一天重复着一天，日子看不到尽头，然后开始怀疑，开始迷茫，开始一遍一遍的为文章的格式耗尽心力。我想可能大多数硕博士都会遇到。</p><p>工作之后，依然有许多和我做同样课题的人来问我，有硕士，也有博士，有哈工大、西北大、江南大学、兰州大学、山东大学等等，每次我都知无不言，因为我会想着那时候一个人做着课题时候的迷茫和不知所措，一个人的无助和苦闷，所以我总是尽我最大的努力告诉他们，这个理论在哪有，现在国内谁做这一块的比较多，哪些英文著作可以先了解，理论部分看哪一本教材，因为是做材料模拟，所以大部分时间会给他们说软件怎么设置，模型怎么建立。我知道我并不是个什么厉害的人物，只是进课题早点而已，所以希望可以帮帮他们，就像我那时候非常希望有个人可以帮我一样。</p><p>刚进公司，老板给我一篇英文博士论文，让我把这个算法弄出来。初出茅庐，半点不敢懈怠，每天晚上十点而归。由于刚出学校，还不习惯中午不午休，所以下午特别困，困了也不敢睡，有时候只能在厕所小眯一会。终于半个多月后给领导讲解了博士论文的大致理论，一个月后调通了MATLAB代码。虽然累，可是我比较喜欢。不用再去弄那些抄菜一般的材料，我可以一心的弄理论。我可以去用理论解开疑惑，我喜欢这种感觉。</p><p>做课题那会我想好好疏通《固体物理》和《量子力学》，那样就不用做什么都像炒菜，增加一点看怎么样，不行再减少一点看怎么样。可是不行，导师总会催文章，美其名曰只要结果不问过程，我看着周围所有的导师都这样，所以没有半点兴趣读博，我也不相信我会找到一个和我有一致想法的导师。从考研起，我就知道为什么要读这个硕士，所以当不再像我希望那样时，我走了出来，我相信一个人的天空依然可以灿烂。</p><p>后来公司领导让我弄小波去噪，替换现有软件中的ＦＦＴ（快速傅里叶变换）算法（因为ＦＦＴ会有边际效应和滤波后的正弦波效应），我从不知道什么是小波，更别提写小波程序。两个月后完成了MATLAB和Ｃ＋＋的小波去噪程序，随便用小波做了个压缩程序，压缩比可以达到只有原来数据的２５％，甚至更高，这对于单片机向计算机发数据是很有用的。期间学会了Ｃ＋＋的入门，ＶＳ、ＱＴ的基本使用。从最开始的老大说你Ｃ＋＋基础太差了，确实差，因为我没学过，到后来自己完成Ｃ＋＋ＧＵＩ界面调试程序和类的编写，还有理论的理解。总共应该差不多三个月的时间，看过的ｐｄｆ专业书籍能列出来的应该不少于十本。每天差不多晚上十点下班，不过我周末很少加班，我不喜欢工作狂。努力只是一种姿态，不能成为全部。</p><p>空闲的时候会来逛逛小木虫，会看到各种各样的苦闷，有和自己相同的，有些不同的，但我想生活方式多种多样，也不定说哪种一定好，但我始终坚信，应该有一条属于自己最佳的，就像费曼的最小作用原理一样。我很怕自己写的东西最后像那种说教式的，本科的时候我不断的要求自己去看书，各种各样的，没有别的目的，只是想着我可以多看看别人的路，然后去想、去选择一条我最合适，或者说自己最喜欢的路。也出于这种目的，我想给那些和我有相同经历的人看看我这样的一条路，路不一定是最好的，有点启发就好。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;这是 @yuerongzho 2012年12月发在小木虫的帖子，现在小木虫网站上已经看不到了，但我还存着，时隔几年再看依然感动，所以冒昧转到了个人博客上。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;这篇帖子发布于2012年，距离现在已经9年。这9年间时过境迁，彼时移动互联网还没有爆发，深度学习还在打比赛，而现在转计算机已经成了各路专业大热的趋势。转这篇帖子，我个人的想法并不是进一步渲染转计算机的氛围，而是感受如何找到一个人想要的东西、如何去实现一个人的想法。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="梦里的棉花糖" scheme="http://yoursite.com/categories/%E6%A2%A6%E9%87%8C%E7%9A%84%E6%A3%89%E8%8A%B1%E7%B3%96/"/>
    
    
  </entry>
  
  <entry>
    <title>2020 年终总结：只一眼，梵音也渐远</title>
    <link href="http://yoursite.com/2021/01/12/2020-summary/"/>
    <id>http://yoursite.com/2021/01/12/2020-summary/</id>
    <published>2021-01-12T03:37:25.000Z</published>
    <updated>2021-01-12T03:37:25.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>若非那年 总角放纸鸢</p><p>风中断线 恣意翩跹</p><p>空旷禅院 独落你脚边</p><p>只一眼 梵音也渐远</p><p>——《青溪渡雪》</p></blockquote><p>因为疫情，回望2020年，显得尤为短暂。仿佛前两天还是2020年寒假前坐在屏幕前敲代码的时光，现在却是另一番光景。</p><span id="more"></span><h3 id="工作与学习"><a href="#工作与学习" class="headerlink" title="工作与学习"></a>工作与学习</h3><p>10月底的时候，和P见了一面，把我暑假以及9月的经历和P简单说了一下。P说，“你胆子还真大”。也确实是这样，面试的时候没有太多感觉，但结束之后回想，些许有股不知天高地厚的样子。</p><p>由此前推，我在面试时说得最多的，或者说面试官最感兴趣的，还是我4月份之后以及6月回到学校期间做的东西。这也让我感受到一个朴素的道理，前行的路、积累的过程，并不是线性的。如果走到一半或者快到尽头时放弃，得到的往往不是50%或者85%，而很可能只有10%。</p><p>而回望这一年的学习和工作，最深的感受就是，心态和环境真的影响很大。新年刚过，起步阶段，状态很好；刚回家时，换了新环境，效率也很高；然后就开始了情绪波动，状态萎靡，不过幸好坚持做了去雾的项目，萎靡中的坚持同样重要，甚至更可贵，这才是告别”在感叹时光流失中让时光再次流失”的方法；回到学校，又是经历从高效到颓废的变化，后期有相当一段时间都在打游戏。好在最后能找回状态。</p><p>在2020的最后一天，和同组的老师同学畅谈了过去的经历，当我能平淡甚至面带笑容说出过去不愿回想的经历，我应该算是从过去走出了吧。在11月、12月的时候，我对我自己说，让自己得到救赎，大概就是如此。</p><h3 id="之前的路"><a href="#之前的路" class="headerlink" title="之前的路"></a>之前的路</h3><p>疫情期间，闷在家里，每天刷手机刷网络。先是在知乎上看到了一位当年吧友，之后便心血来潮翻过去的帖子，再后便是偶然搜到了龙崎和余哥的主页，得知了他们的近况。原来他们一直都没有离开，只是换了一种方式存在。那时候我受了很大的…心理波动吧，“感觉命运给我开了一个玩笑”。就像我在年末和同组同学说的那样，大家都当真了，只有我在开玩笑。能够为自己做选择，能够去追逐热爱的事情，这是一件多么好的事情啊。就像《四月》里说的那样，“喜欢和不讨厌之间，可是隔了数亿光年都不止的距离”。</p><p>疫情给我上网方式带来的另一个变化，是让我回归了传统的论坛和bbs的交流方式。时不时会在论坛上看到一些感叹个人生活的帖子，无论他们的年龄比我小还是大，大部分时候我都会感觉，我自己已经能够不再为类似的事情感慨了，这大概就是我长大了吧。</p><p>在Github上交流，这对我是一个全新的体验，感觉很愉快。而在现实中，或者是在带有现实的微信中，也尝试了和陌生人去交流，那种破冰的感觉，也很久不曾体验了。</p><h3 id="生活、做饭"><a href="#生活、做饭" class="headerlink" title="生活、做饭"></a>生活、做饭</h3><p>疫情的又一个影响，我开始做饭了。从煮挂面开始，到煮菜煮鸡胸肉，再到炒菜烩菜。看了那么多烹饪视频，终于有了行动，而小时候常常幻想的做饭场景也终于成为了现实。</p><p>开始真正的做饭，应该说正是疫情闷在家里快闷坏了的阶段。做一顿饭，确实是生活中很好的调剂。</p><p>到了5月，疫情渐渐消退，我也终于挪出了家门，经常性地出门走走。虽然通常只是买杯咖啡带回家，但也足够呼吸新鲜空气了。虽然家在县城，但比村里的学校还是方便多了，走不远就是肯德基和麦当劳。话说肯德基的大神卡买咖啡真的很划算，肯德基的咖啡也不比星巴克差，至少我喝不出来。</p><p>回到学校之后，尝试了多种咖啡，从速溶黑咖啡到手冲。第一次泡手冲，推开宿舍门，真是满屋的香气。后来了解了一些咖啡知识，知道了星巴克等咖啡馆，拿铁也是要加奶泡的，而奶泡是用商业级设备打出来的，家里面很难复现。所以我终于明白了，为什么自己兑的咖啡牛奶、肯德基的拿铁，和星巴克的味道总是不一样了。但回到主题，我用手冲泡出来的咖啡，和星巴克的美式，喝不出区别。原来3块钱也能做到30块钱的效果。</p><h3 id="结语以及之后"><a href="#结语以及之后" class="headerlink" title="结语以及之后"></a>结语以及之后</h3><p>有的时候会感觉，想努力却没有平台。所谓“比你优秀的比你还努力”，问题并不一定出在思想和自制力上，而是由于不知道怎么跳出无效的努力，或者找不到有效的平台。相反地，当我找到属于我的铁轨之后，并不是工作结束了，而是我能给我自己提供一个方向。所谓“成长的烦恼”、已经OK了为什么还要继续，可以批判地看待这些话，但不得不说反映了客观的道理。</p><p>大概这就是2020年了。写年终总结的时候，因为有些事情过去的比较久了，记不太清了，年终总结往往会变成季度总结+新一年的flag。但还是要尽量避免。我希望这一年能沉淀下一些东西，而不是把近期还未成熟的感受强化。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;若非那年 总角放纸鸢&lt;/p&gt;
&lt;p&gt;风中断线 恣意翩跹&lt;/p&gt;
&lt;p&gt;空旷禅院 独落你脚边&lt;/p&gt;
&lt;p&gt;只一眼 梵音也渐远&lt;/p&gt;
&lt;p&gt;——《青溪渡雪》&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;因为疫情，回望2020年，显得尤为短暂。仿佛前两天还是2020年寒假前坐在屏幕前敲代码的时光，现在却是另一番光景。&lt;/p&gt;</summary>
    
    
    
    <category term="日记" scheme="http://yoursite.com/categories/%E6%97%A5%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>2020 年中书单/影评：在终止彷徨，在结束动荡</title>
    <link href="http://yoursite.com/2020/07/28/2020-mid-books/"/>
    <id>http://yoursite.com/2020/07/28/2020-mid-books/</id>
    <published>2020-07-27T18:32:18.000Z</published>
    <updated>2020-07-27T18:32:18.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>你在终止彷徨  你在结束动荡</p><p>你成为垂衣驭八荒的王</p><p>你低下头与我相望  将金色徽章戴在我肩膀</p><p>你眼中分明蛰藏  锁死我危险却迷人的欲望</p><p>——《国境四方》</p></blockquote><p>开了一个新系列，记载 2019 年下半年至 2020 年上半年读过的书和看过的视频。</p><span id="more"></span><h3 id="技术类书籍"><a href="#技术类书籍" class="headerlink" title="技术类书籍"></a>技术类书籍</h3><h4 id="1-《深入理解-C-指针》"><a href="#1-《深入理解-C-指针》" class="headerlink" title="1.《深入理解 C 指针》"></a>1.《深入理解 C 指针》</h4><p>推荐指数：★ ★ ★ ★ ★</p><p>这段时间以来看的书，首推这本《深入理解 C 指针》。这是一本超越了字典&#x2F;百科全书式的各类 C&#x2F;C++ 教程的专项书籍，是进阶的开端书籍。看这本书大概是在 2019 年 12 月，当时正在写 JincResize 和 AreaResize，刚接触图像处理中双重 for 循环遍历元素与指针移动的过程，看这本书让我迅速理解了上述内容。</p><h4 id="2-《现代-C-教程：高速上手-C-11-x2F-14-x2F-17-x2F-20》"><a href="#2-《现代-C-教程：高速上手-C-11-x2F-14-x2F-17-x2F-20》" class="headerlink" title="2.《现代 C++ 教程：高速上手 C++11&#x2F;14&#x2F;17&#x2F;20》"></a>2.《现代 C++ 教程：高速上手 C++11&#x2F;14&#x2F;17&#x2F;20》</h4><p>推荐指数：★ ★ ★ ★ ★</p><p>龙崎哥写的开源书籍， Github 仓库在<a href="https://github.com/changkun/modern-cpp-tutorial">这里</a>。</p><p>龙崎哥是真的厉害，我只记得当年在数吧里看到他提了一下，说在学 C++。没想到写出了这么棒的书。</p><p>我主要是 2020 年 2 月 ~ 3 月在看这本书，没有太注意 C++ 20 的内容（毕竟在不断更新中）。如龙崎哥所言，这本书由于各章节独立，适合零碎的阅读、查阅。我主要看了智能指针部分，其次是一些相对零碎的新特性，而多线程部分虽然看了…但没看太懂。</p><p>会感慨固然人生路远，但能遇见的人就这么多，当年仰慕的人并没有消失，只是换了一种方式存在。题记中引用了一首歌，《国境四方》，我想表达的便是这个含义。</p><h4 id="3-《OpenCV-3-编程入门》"><a href="#3-《OpenCV-3-编程入门》" class="headerlink" title="3.《OpenCV 3 编程入门》"></a>3.《OpenCV 3 编程入门》</h4><p>推荐指数：★ ★ ★ ★ ★（新手视角）| ★ ★ ★ ★ ☆（一般视角）</p><p>适合新手阅读的一本书，书的内容包括如下几个部分：1.编程扫盲部分，讲了变量命名规则与习惯、C&#x2F;C++ 的一些常识；2. OpenCV 3 入门部分，讲了 OpenCV 3 的一些设计思路和数据结构；3.逐条讲解主要函数，同时讲了一些图像处理的基础理论。在 2019 年 11月 ~ 2020 年 2 月看了这本书，不得不说让懵懂的我学了很多，但站在一般向的视角上，内容略显简单（当然，对于封装这么成熟的 OpenCV，把书写复杂可能既不容易也没必要）。</p><h4 id="4-《21-天学通-C-》"><a href="#4-《21-天学通-C-》" class="headerlink" title="4.《21 天学通 C++》"></a>4.《21 天学通 C++》</h4><p>推荐指数：★ ★ ★ ★ ☆</p><p>没什么好说的，这是我用来当手册&#x2F;字典的书籍，大概可以分为三部分：C&#x2F;C++ 通用语法、C++ 特性语法、STL 库。这本书我好像没有在博文中看到过有人推荐，接触这本书因为《21 天实战 Caffe》，后者的作者说他就是在《21 天学通 C++》启发下写了《21 天实战 Caffe》。</p><p>但有一说一，《21 天实战 Caffe》真的是分了 21 个章节，而《21 天学通 C++》…除了书名之外，好像没看到和 21 相关的东西 Orz…</p><h4 id="5-《C-x2F-C-常用算法手册》"><a href="#5-《C-x2F-C-常用算法手册》" class="headerlink" title="5.《C&#x2F;C++ 常用算法手册》"></a>5.《C&#x2F;C++ 常用算法手册》</h4><p>推荐指数：★ ★ ★ ☆</p><p>很基础的书籍，讲了常见的数据结构和基础的算法，适合新手，也是我在浮躁状态下难得读得进去的书。但平心而论，书的内容本身并谈不上有多好，代码风格陈旧且不说，前后代码重复让人感觉有点冗杂。</p><h3 id="文学类书籍"><a href="#文学类书籍" class="headerlink" title="文学类书籍"></a>文学类书籍</h3><h4 id="1-《文在寅自传：命运》"><a href="#1-《文在寅自传：命运》" class="headerlink" title="1.《文在寅自传：命运》"></a>1.《文在寅自传：命运》</h4><p>本来不想提到这本书的，因为避免谈政治。只是书的一句话印象太深刻了，“愿为江水，与君同行”。</p><h4 id="2-《透过机器人与你相恋》"><a href="#2-《透过机器人与你相恋》" class="headerlink" title="2.《透过机器人与你相恋》"></a>2.《透过机器人与你相恋》</h4><p>轻小说。接触这本书是因为插画师 loundraw。早前在 P 站看到 loundraw 的一幅画，还用来当了一段时间的台式机壁纸。没想到这幅画同样是《透过机器人与你相恋》的封面图，于是就把小说买来看了。目前只看了开头，还没有看到故事的核心。</p><h3 id="网课"><a href="#网课" class="headerlink" title="网课"></a>网课</h3><p>点开看过的网课有以下几个。</p><p><strong>1.某培训班的通用 C++ 网课</strong></p><p><strong>2.国防科大《编译原理》</strong></p><p><strong>3.郝斌《数据结构》</strong></p><p><strong>4.北理工 2020 冬季 ACM 培训</strong></p><p><strong>5.某编程算法教程</strong></p><p>这几个网课收获都不小。应该说第一个 C++ 网课没什么特色，但对于新手还是友好的。第二个编译原理网课虽然只是浅看，但很受启发，确实有种“学了编译原理你就明白了的感觉”。重点看的是第三、四个，数据结构的入门和 STL 库的讲解（众所周知，ACM 用的 C++ &#x3D; C + STL）。最后一个是付费购买的，面向面试的教程，物有所值。</p><h3 id="影视"><a href="#影视" class="headerlink" title="影视"></a>影视</h3><h4 id="1-《樱花庄的宠物女孩》"><a href="#1-《樱花庄的宠物女孩》" class="headerlink" title="1.《樱花庄的宠物女孩》"></a>1.《樱花庄的宠物女孩》</h4><p>2019 年下半年开了三部番，《冰菓》、《境界的彼方》、《樱花庄》，前两者没有弃但到现在都没看完，《樱花庄的宠物女孩》是日常向，所以看得进度快。这三部番陪着我走过了 2019 年 9 月到 12 月，从轻松到迷茫再到找到方向。</p><p>《樱花庄》里的生活确实让人羡慕，但或许因为我不是天才吧，若客观地分析人物塑造，还是有些贴标签的感觉。剧中的人物塑造方式，对于龙哥这样的配角而言，没什么问题，感觉不到贴标签，简略描写增加的神秘感反而更适合龙哥。三鹰学长学姐倒也没什么问题，一开始贴上两个人都能力超群的标签，但进一步的剧情展开则说明，看似无所不能的学长，专业技能反倒逊色于嘻嘻哈哈的学姐，这提供了戏剧冲突，也让人物形象丰满了一些，对于配角也可以了。但说到主角真白，仍把塑造配角的方式拿来用，就感觉有些僵硬。</p><p>不过嘛，《樱花庄》毕竟是在日常基础上深入的，看的时候让人开心和感动就足够了。</p><h4 id="2-《狼与香辛料》第一季"><a href="#2-《狼与香辛料》第一季" class="headerlink" title="2.《狼与香辛料》第一季"></a>2.《狼与香辛料》第一季</h4><p>同样是在 2019 年下半年看的，没和上面三部番写到一起，是觉得风格不太一样。这部番被调侃为“夫妻行骗记”，但我更喜欢另一个评价，这部番是把女性作为独立个体的番剧。且不和一众后宫番比较，就是和非后宫普通番剧乃至没什么男性的百合番相比，能把女性独立人格塑造出来，除了《狼与香辛料》，我看过的番中只有柯南剧场版《战栗的乐谱》。</p><h4 id="3-《非自然死亡》"><a href="#3-《非自然死亡》" class="headerlink" title="3.《非自然死亡》"></a>3.《非自然死亡》</h4><p>好剧，不需要多说。特别是在新冠疫情的背景下，第一集甚至有了代入感。每一集的片尾曲《Lemon》都是神插入。看《境界的彼方》时，弹幕经常说 OP 神插入，但我倒没有明显感觉。片中时不时出现的名台词，可以当壁纸的石原里美的名场景，更让人印象深刻。而六郎对人生的思考，也让当时迷茫的我有了共鸣。</p><p>在主要剧情之外，看这部剧时不时会跳戏，且不说作为所长的<del>五郎</del>（欸，所长名字是啥来着？），光是里面的名字就让人跳戏，美琴、想见美琴的白井同学、神经大条的毛利警官。</p><p>喜欢 B 站的一条评论，看这部剧还能因为 cp 掐起来，应该把脑子泡在福尔马林里。</p><h4 id="4-《理科生坠入情网，故尝试证明。》"><a href="#4-《理科生坠入情网，故尝试证明。》" class="headerlink" title="4.《理科生坠入情网，故尝试证明。》"></a>4.《理科生坠入情网，故尝试证明。》</h4><p>应该是这一年追的唯一一部新番，也不能叫追，因为不知道是网飞还是亚马逊加持，一次性更完 12 集。虽然还是让人感觉有些夸张，就是这类番剧中常见的过分夸张数理知识的感觉。但一些细节还是有意思的，真的很佩服在 Ubuntu 下玩 galgame 的师弟，不知是创作者是真在 Linux 下玩过 galgame，还是只是单纯营造人设。</p><h4 id="5-《无法成为野兽的我们》"><a href="#5-《无法成为野兽的我们》" class="headerlink" title="5.《无法成为野兽的我们》"></a>5.《无法成为野兽的我们》</h4><p>冲着新垣结衣去看的，但可能是我还没有步入职场吧，感触一般。</p><h4 id="6-《轻音少女》第一季"><a href="#6-《轻音少女》第一季" class="headerlink" title="6.《轻音少女》第一季"></a>6.《轻音少女》第一季</h4><p>治愈的日常番。</p><h4 id="7-《Fate-x2F-stay-night-Heaven’s-Feel-II-lost-butterfly》"><a href="#7-《Fate-x2F-stay-night-Heaven’s-Feel-II-lost-butterfly》" class="headerlink" title="7.《Fate&#x2F;stay night [Heaven’s Feel] II.lost butterfly》"></a>7.《Fate&#x2F;stay night [Heaven’s Feel] II.lost butterfly》</h4><p>在 2019 年 7 月还是 8 月，和 G 和 H 去电影院看的。因为在七八月份，就写了进来，其实从心境上看，应该归到上半年。电影院里的感受自然和十几寸二十几寸的屏幕不一样，特别是对于 Fate 这种大制作的番剧。樱真的惹人喜欢。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;你在终止彷徨  你在结束动荡&lt;/p&gt;
&lt;p&gt;你成为垂衣驭八荒的王&lt;/p&gt;
&lt;p&gt;你低下头与我相望  将金色徽章戴在我肩膀&lt;/p&gt;
&lt;p&gt;你眼中分明蛰藏  锁死我危险却迷人的欲望&lt;/p&gt;
&lt;p&gt;——《国境四方》&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;开了一个新系列，记载 2019 年下半年至 2020 年上半年读过的书和看过的视频。&lt;/p&gt;</summary>
    
    
    
    <category term="日记" scheme="http://yoursite.com/categories/%E6%97%A5%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>DehazingCE：基于对比度增强的去雾算法及 VapourSynth 迁移</title>
    <link href="http://yoursite.com/2020/06/26/dehazingce-port/"/>
    <id>http://yoursite.com/2020/06/26/dehazingce-port/</id>
    <published>2020-06-25T16:42:53.000Z</published>
    <updated>2020-06-25T16:42:53.000Z</updated>
    
    <content type="html"><![CDATA[<p>这一去雾算法在2013年提出，论文见 <a href="http://mcl.korea.ac.kr/projects/dehazing/#userconsent#">Optimized contrast enhancement for real-time image and video dehazing</a>，我们称其为 DehazingCE （CE &#x3D; contrast enhancement）。</p><h3 id="算法概述"><a href="#算法概述" class="headerlink" title="算法概述"></a>算法概述</h3><p>DehazingCE 基于大气散射模型，分别估计大气光强度和透射率，得到去雾结果。</p><span id="more"></span><p>大气光估计通过图像分块、寻找像素差异最小的子块，以该子块最亮的点作为大气光的估计值。但这里存在一个问题，不知道是我理解有问题，还是我代码迁移有问题，或者算法本身就有问题。如果图像整体偏暗，那寻找到的子块就会很暗，最后以一个像素值很小的点作为大气光估计值，用这个值继续计算，最终结果就是全黑。我对迁移到 VapourSynth 的代码进行测试，确实发现了这一问题。</p><p>透射率估计分为粗算和细化两步。粗算是基于大气散射模型进行次数不多的迭代，并自定义像素损失值（大气散射模型的直接计算结果可能会超过 [0, peak]，导致像素越界）以决定是否继续迭代。细化通过导向滤波实现。</p><p>后处理包括 Gamma 亮度调整和类似均值滤波的均值化计算。前者是避免去雾后图像过暗，后者是避免透射率过低时导致的块效应。在我迁移的代码中，Gamma 亮度调整表现不错，但均值化计算可能是我的代码还有问题，测试结果是不如不做，做了反而凭空多了瑕疵。</p><h3 id="代码迁移"><a href="#代码迁移" class="headerlink" title="代码迁移"></a>代码迁移</h3><p>代码迁移着实花了很久，满打满算从 4 月份开始读原始代码，到 6 月份完成初版的迁移，几乎花了两个月…原始代码风格很古典，着实有点费力。</p><h4 id="从-OpenCV-2-到-OpenCV-3"><a href="#从-OpenCV-2-到-OpenCV-3" class="headerlink" title="从 OpenCV 2 到 OpenCV 3"></a>从 OpenCV 2 到 OpenCV 3</h4><p>在最开始，我觉得一下子迁移到 VapourSynth 有点费力，便想尝试着把原始代码先跑起来。原始代码基于 OpenCV 2，存储图像还是用的 IplImage 指针而非 Mat 类。这一部分工作在<a href="https://kiyamou.github.io/2020/04/28/dehazing/">前面的博文</a>有提到。但折腾好久，也没把原始代码跑起来，最后放弃了，直接迁移。</p><h4 id="YUV-还是-RGB"><a href="#YUV-还是-RGB" class="headerlink" title="YUV 还是 RGB"></a>YUV 还是 RGB</h4><p>在着手迁移之初，是先支持 YUV 还是先支持 RGB 纠结了好久。其中一部分原因是我还没完全搞懂原始代码的处理流程，从大气光估计部分看，原始代码用的是 RGB 格式，从透射率估计看，原始代码既有只算灰度的（这像是面向 YUV），又有 RGB 三个通道都计算的。最后决定先支持 RGB（因为我先读明白了原始代码的大气光估计部分，沿用了这一部分的 RGB 格式）。</p><h4 id="数据结构的转换与基础操作的迁移"><a href="#数据结构的转换与基础操作的迁移" class="headerlink" title="数据结构的转换与基础操作的迁移"></a>数据结构的转换与基础操作的迁移</h4><p>确定 RGB 后便开始转换图像数据结构，为减少工作量，尽量不去动原始代码的函数输入输出模式，把 VapourSynth 接口传递过来的图像指针转化为普通指针，送给核心计算函数。在这个过程中，我越来越感觉到 VapourSynth 接口的概念，或者什么叫接口。我渐渐懂得把核心处理剥离开，不再依赖 VapourSynth API 提供的数据类型，而是使用普通指针和数组完成核心计算，在把结果送给 VapourSynth API。</p><p>在计算过程中需要进行图像分块、计算图像像素值均值和标准差。在原始代码中，这些操作都是使用的 OpenCV 函数。对于这些并不复杂的操作，我自然不能接受调用第三方库来实现。图像分块最开始是用两层 for 循环赋值，后来才想到用<code>memcpy()</code>函数直接拷贝。计算均值和标准差直接 copy 了一份代码。</p><p>完成上述操作后，迁移过程就没什么困难的了，写个集成函数去调用各步计算即可。</p><h4 id="VapourSynth-API-的一些事情"><a href="#VapourSynth-API-的一些事情" class="headerlink" title="VapourSynth API 的一些事情"></a>VapourSynth API 的一些事情</h4><p>虽说已经没有大的困难，但具体细节上还是要花时间的。我之前没有写过 ref 参考片段，之前也不知道 VapourSynth 接口没有提供 bool 类型。好在有前辈们写成的其他滤镜，有很多可以参考（copy）的代码。</p><h3 id="Debug"><a href="#Debug" class="headerlink" title="Debug"></a>Debug</h3><h4 id="指针读取冲突"><a href="#指针读取冲突" class="headerlink" title="指针读取冲突"></a>指针读取冲突</h4><p> 读取位置 … 时发生访问冲突。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">srcInterleaved[pos] = srcpB[x];<br>srcInterleaved[pos + <span class="hljs-number">1</span>] = srcpG[x];<br></code></pre></td></tr></table></figure><p>这里就出问题是我没有想到的，因为这部分代码之前在AreaResize中已经用过了，没有问题。</p><p>回到报错本身，“发生访问冲突”表明指针访问内存时出问题了，指针指向了不属于自己的内存地址，是一个基础的问题。</p><p>发现在vs接口部分忘记释放ref，释放之后同样报访问冲突，但这次的报错位置是大气光估计函数的图像分块位置，这才是意料之中（这部分代码最开始写的时候就迷迷糊糊的）。</p><p>但另一个引发该错误的原因就很蠢了，假如读入的不是 RGB 格式，而是 YUV 格式，也会引发该错误。这是自然的，YUV 的第二、三个通道的宽高分别是第一个通道的一半，自然会越界。</p><h3 id="构建与C-语法"><a href="#构建与C-语法" class="headerlink" title="构建与C++语法"></a>构建与C++语法</h3><p>从这次开始我使用了 cmake 进行构建，一开始都是一些技术问题，直到部署 CI 的时候，才通过 cmake 意识到一些 C++ 语法的问题，一些我在很早的时候就看到过但没有读懂的问题。</p><h4 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h4><p>智能指针是 C++11 引入的，但<code>std::make_unique</code>被忘记写入标准了，直到 C++14 才被引入…</p><h4 id="noexcept"><a href="#noexcept" class="headerlink" title="noexcept"></a>noexcept</h4><p><code>noexcept</code>在 C++11 引入。</p><p>不搞清这些标准问题，在 travis-ci 的编译器上会报错…</p><h3 id="高位深支持"><a href="#高位深支持" class="headerlink" title="高位深支持"></a>高位深支持</h3><p>高位深支持需要解决两个方面的问题，一是算法本身计算过程的修改，这一部分我改到现在还是有问题…图像暗场处理后会直接变黑…另一是C++语法的问题，带有模板的成员函数怎么写。</p><h4 id="语法层面的问题"><a href="#语法层面的问题" class="headerlink" title="语法层面的问题"></a>语法层面的问题</h4><p>我之前用模板，借用做饭的话说就是现用现做，而成员函数的声明和定义分开写在两个文件中，这时候再用模板就会出现链接器错误。但把声明和定义写在一起我不太愿意这么搞，于是折中的办法是在 main.cpp 同时 include 含有声明的 .h 和定义的 .cpp 文件。</p><h4 id="算法层面的问题"><a href="#算法层面的问题" class="headerlink" title="算法层面的问题"></a>算法层面的问题</h4><p>按照惯例，至少对于从 8bit 到 16bit 的扩充，把类似含有 255 的地方改成 peak 就可以了，但这次遇到了不少问题。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;这一去雾算法在2013年提出，论文见 &lt;a href=&quot;http://mcl.korea.ac.kr/projects/dehazing/#userconsent#&quot;&gt;Optimized contrast enhancement for real-time image and video dehazing&lt;/a&gt;，我们称其为 DehazingCE （CE &amp;#x3D; contrast enhancement）。&lt;/p&gt;
&lt;h3 id=&quot;算法概述&quot;&gt;&lt;a href=&quot;#算法概述&quot; class=&quot;headerlink&quot; title=&quot;算法概述&quot;&gt;&lt;/a&gt;算法概述&lt;/h3&gt;&lt;p&gt;DehazingCE 基于大气散射模型，分别估计大气光强度和透射率，得到去雾结果。&lt;/p&gt;</summary>
    
    
    
    <category term="图像处理" scheme="http://yoursite.com/categories/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    
    
    <category term="构建与编译" scheme="http://yoursite.com/tags/%E6%9E%84%E5%BB%BA%E4%B8%8E%E7%BC%96%E8%AF%91/"/>
    
    <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
    <category term="VapourSynth" scheme="http://yoursite.com/tags/VapourSynth/"/>
    
  </entry>
  
  <entry>
    <title>《饥荒》食谱个人点评</title>
    <link href="http://yoursite.com/2020/05/30/Dont-starve/"/>
    <id>http://yoursite.com/2020/05/30/Dont-starve/</id>
    <published>2020-05-29T17:56:26.000Z</published>
    <updated>2020-05-29T17:56:26.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>这几天一直在玩《饥荒》，起因是想起大一和几个室友联机打游戏的场景；而且虽然我已经在 Steam 补票，但一直没怎么玩，于是重新开始，沉迷了几天。写一写这几天打游戏的感受，主要是点评食谱以及围绕食谱展开的生存模式。</p><span id="more"></span><p>内容比较基础，适合萌新观看。</p><p>额…再多说两句，我玩的是《饥荒》原始版，而大部分教程以及攻略都是基于《饥荒》巨人国DLC 展开的，在巨人王朝中添加了很多新内容，食谱也随之丰富，所以我的内容会比较少。</p><p><strong>Update</strong>：之后我买了巨人国DLC，又在夏日特卖时买了海滩DLC，所以对食谱做了少量更新，仍然是围绕基础版&#x2F;巨人国展开，海滩的内容只加入了甘薯和咖啡豆（前者在兼容海滩的巨人国中也能种植获得，后者可以通过海滩穿越带到巨人国中）。</p><h3 id="我的食物风格"><a href="#我的食物风格" class="headerlink" title="我的食物风格"></a>我的食物风格</h3><p>我玩《饥荒》的风格可以概括为农场怪兽流，就是农场派+以怪兽肉为主要肉类，除了养一只鸟、一个蜂巢外，没有采取养猪、养兔子、捉火鸡等牧场派喜欢的模式。建猪舍只是因为之前没玩过，在开局早期倒是经常捉兔子，但之后就很少干了，而火鸡更是随缘。</p><h3 id="食物属性"><a href="#食物属性" class="headerlink" title="食物属性"></a>食物属性</h3><p>说食谱之前先整理一下食物属性，《饥荒》里将食物分为肉、蔬菜、水果、蛋、甜品等，并分别定义的了肉度、蔬菜度、果度、蛋度、甜品度（鱼还有鱼度，但基础版&#x2F;巨人国中似乎用不上）。此外树枝、冰块在一定条件下也可以作为食谱填充物。</p><ul><li><strong>肉度</strong><ul><li>1.0 肉度：大肉、怪兽肉</li><li>0.5 肉度：小肉块、鱼、青蛙腿、鸡腿</li></ul></li><li><strong>蔬菜度</strong><ul><li>1.0 蔬菜度：各种蔬菜，包括夏季限定的仙人掌花</li><li>0.5 蔬菜度：红绿蓝三种颜色的蘑菇</li></ul></li><li><strong>果度</strong><ul><li>1.0 果度：各种水果</li><li>0.5 果度：浆果、咖啡豆（兼容海滩后从海滩穿越到巨人国可得）</li></ul></li><li><strong>蛋度</strong><ul><li>2.0 蛋度：高脚鸟蛋</li><li>1.0 蛋度：蛋（鸟蛋和企鹅蛋都是这同一个东西）</li></ul></li><li><strong>甜品度</strong><ul><li>蜂蜜和蜂巢，甜品度一样</li><li>非联机版无蜂王浆，不用考虑甜品度的问题</li></ul></li><li><strong>奶制品</strong><ul><li>羊奶、黄油</li><li>没有需要大于一个奶制品的食谱，所以奶制品不用考虑“度”的问题</li></ul></li><li><strong>鱼度</strong><ul><li>同样不甚了解，基础版与巨人国不用考虑，只有鱼和鳗鱼，鱼度一样</li></ul></li><li><strong>怪兽肉度</strong><ul><li>1.0 怪兽肉度：怪兽肉、榴莲（没有树枝的前提下，两个怪兽肉度会做出怪兽肉千层饼）</li></ul></li></ul><h3 id="我的食谱"><a href="#我的食谱" class="headerlink" title="我的食谱"></a>我的食谱</h3><p>正式开始说食谱，我个人将食谱分成如下几类。</p><p>在说食谱之前再啰嗦几句，由于肉丸是广为人知且较易得的饱食食谱，所以我的食谱主要侧重于回血与恢复精神。</p><p>对于回血，由蜘蛛腺体制作的治疗药膏可以回 20 血，以此为基准，大于 20 血的食谱都可以视为回血食谱。</p><p>对于恢复精神，大部分食物都只能加 5 精神，常见的恢复精神食谱包括蜂蜜类、冰类。</p><h4 id="喜欢且常做的食谱"><a href="#喜欢且常做的食谱" class="headerlink" title="喜欢且常做的食谱"></a>喜欢且常做的食谱</h4><ul><li><p><strong>波兰水饺</strong></p><p>波兰水饺是在我养鸟之后，最喜欢的食谱之一，有时候怪兽肉很多吃不完，做风干怪兽肉有点坑，把怪兽肉喂给鸟、变成蛋，就可以做波兰水饺了。</p><ul><li><strong>食谱属性</strong>：<strong>37.5 饱食、40 血、5 精神</strong>、20 秒烹饪、20 天保存</li><li><strong>通用食谱</strong>：1.0 蛋度 + 0.5 肉度 + 0.5 蔬菜度 + 其他（不能有树枝）</li><li><strong>我的食谱</strong>：一个蛋 + 一个怪兽肉 + 一个蔬菜或一个蘑菇 + 一个浆果或其他水果（注意不能有榴莲）</li><li><strong>额外说明</strong>：如前面所说，《饥荒》的食物属性中还有一个“怪兽肉度”，虽名为“肉度”，但并不限于肉，常见的怪兽肉、榴莲都是一个怪兽肉度。食谱中若包含两个怪兽肉度，则会做出不讨人喜欢的怪兽肉千层饼。所以一个怪兽肉加一个榴莲等效于两个怪兽肉，都会做出怪兽肉千层饼。</li></ul><p><strong>点评</strong>：回血神器、解决吃不完的怪兽肉、允许蘑菇给缺少蔬菜的冬季带来可能、保存时间也不错。</p></li><li><p><strong>火龙果派</strong></p><p>因为有农场，火龙果包括下面的南瓜都是比较容易获得的，所以很推荐又回血又饱腹制作简单粗暴的</p><ul><li><strong>食谱属性</strong>：<strong>75 饱食、40 血、5 精神</strong>、40 秒烹饪、15 天保存</li><li><strong>通用食谱</strong>：一个火龙果 + 其他（不能有肉）</li><li><strong>我的食谱</strong>：一个火龙果 + 三个树枝</li></ul><p><strong>点评</strong>：回血神器、饱食值也很高、能用三个树枝直接填满、保质期长，农场派的神器，特别是养鸟之后，可以得到火龙果种子。</p></li><li><p><strong>太妃糖、南瓜饼干</strong></p><p>这两个都是用来恢复精神的，而且主要依赖蜂蜜，所以放在了一起。</p><ul><li><p><strong>太妃糖</strong></p><ul><li><strong>食谱属性</strong>：<strong>25 饱食、-3 血、15 精神</strong>、40 秒烹饪、15 天保存</li><li><strong>通用食谱</strong>：三个蜂蜜或蜂巢 + 其他（不能有肉）</li><li><strong>我的食谱</strong>：三个蜂蜜 +一个树枝</li></ul></li><li><p><strong>南瓜饼干</strong></p><ul><li><strong>食谱属性</strong>：<strong>37.5 饱食、0 血、15 精神</strong>、40 秒烹饪、10 天保存</li><li><strong>通用食谱</strong>：一个南瓜 + 两个蜂蜜或蜂巢 + 其他（可以有肉，什么都可以）</li><li><strong>我的食谱</strong>：一个南瓜 + 两个蜂蜜 + 一个树枝</li></ul></li><li><p><strong>额外说明</strong> </p><ul><li>“三个蜂蜜或蜂巢 + 一个南瓜”做出上述两种食品的概率各为50%（当然也没理由这么做）</li><li>这两种食品优先度相当高，在其他大部分食谱中，都不能以曼德拉草为填充物（当然同样没理由把珍贵的曼德拉草来烹饪一般食物，所以上面没有提），但这两种食品都可以以曼德拉草为填充物，做出对应食品或曼德拉草汤的概率各为50%</li></ul></li></ul><p><strong>点评</strong>：回 san 食谱，虽然看上去需要很多蜂蜜，但其实养一个蜂巢就够了。由于生吃南瓜就可以得到 37.5 饱食和 3 点血，烤南瓜则提高到 8 点血，所以在蜂蜜充足的情况下，完全建议做太妃糖而不是南瓜饼，太妃糖扣的血量靠吃南瓜就可以弥补，还能增加更多的饱食度。</p><p>假如有三个蜂蜜 + 一个南瓜，两种组合方式及效果如下。</p><table><thead><tr><th align="center">食谱</th><th align="center">太妃糖 + 烤南瓜</th><th align="center">南瓜饼 + 蜂蜜</th></tr></thead><tbody><tr><td align="center">饱食</td><td align="center">25 + 37.5 &#x3D; 62.5</td><td align="center">37.5 + 9.375 &#x3D; 46.875</td></tr><tr><td align="center">血量</td><td align="center">-3 + 8 &#x3D; 5</td><td align="center">0 + 3 &#x3D; 3</td></tr><tr><td align="center">san 值</td><td align="center">15</td><td align="center">15</td></tr></tbody></table><p>“太妃糖 + 烤南瓜”的饱食度赶上一个肉丸了有木有？！</p></li><li><p><strong>西瓜冰</strong></p><ul><li><strong>食谱属性</strong>：<strong>12.5 饱食、3 血、20 精神</strong>、10 秒烹饪、3 天保存</li><li><strong>通用食谱</strong>：一个生西瓜 + 一个冰 + 一个树枝 + 填充物（不能是肉、蛋、蔬菜）</li><li><strong>我的食谱</strong>：一个生西瓜 + 一个冰 + 两个树枝</li></ul><p><strong>点评</strong>：<strong>西瓜为巨人国DLC增加</strong>，回 san 食谱，比太妃糖&#x2F;南瓜饼回 san 更高，但西瓜毕竟是种出来的，而且保存期不是很长，不像太妃糖那样存着蜂蜜想做随时都有（其实单从回 san 角度，烤绿蘑菇是最简单粗暴的了，但毕竟还要趁着黄昏去桦树林或沼泽摘蘑菇，不像太妃糖那样宅在家里饭来张口。嗯…在游戏里我也喜欢宅 Orz…）。</p></li><li><p><strong>培根煎蛋</strong></p><ul><li><strong>食谱属性</strong>：<strong>75 饱食、20 血、5 精神</strong>、40 秒烹饪、20 天保存</li><li><strong>通用食谱</strong>：2.0 蛋度 + 至少 1.5 肉度</li><li><strong>我的食谱</strong>：两个蛋 + 一个怪兽肉 + 一个小肉</li></ul><p><strong>点评</strong>：保质期长的饱食回血食谱，可以视为增强版的肉丸。</p></li><li><p><strong>肉丸</strong></p><ul><li><strong>食谱属性</strong>：<strong>62.5 饱食、3 血、5 精神</strong>、15 秒烹饪、10 天保存</li><li><strong>通用食谱</strong>：肉度大于等于 0.5 小于等于 3.0 + 其他（不能是树枝、蜂蜜）</li><li><strong>我的食谱</strong>：一个怪兽肉&#x2F;小肉 + 三个蔬菜&#x2F;水果（避免怪兽肉 + 榴莲、鱼 + 玉米的组合）</li></ul><p><strong>点评</strong>：没什么好说的，增加饱食的易得利器，0.5 个肉度，也就是一个小肉即可，肉度大于 3.0 会做成肉汤。特别是条件不太好时，只为增加饱食又不太追求保质期，基本上没必要追求其他食谱。</p></li></ul><h4 id="比较喜欢的食谱"><a href="#比较喜欢的食谱" class="headerlink" title="比较喜欢的食谱"></a>比较喜欢的食谱</h4><ul><li><p><strong>青蛙腿三明治</strong></p><ul><li><strong>食谱属性</strong>：<strong>37.5 饱食、20 血、5 精神</strong>、10 秒烹饪、10 天保存</li><li><strong>通用食谱</strong>：一个青蛙腿 + 0.5 蔬菜度 + 其他</li><li><strong>我的食谱</strong>：一个青蛙腿  + 一个胡萝卜或一个蘑菇 + 两个树枝</li></ul><p><strong>点评</strong>：只需要 0.5 个蔬菜度、可以放两个树枝，如果有青蛙腿，则是一道很易得的回血食谱了。</p></li><li><p><strong>蜜汁火腿</strong></p><ul><li><strong>食谱属性</strong>：<strong>75 饱食、30 血、5 精神</strong>、40 秒烹饪、15 天保存</li><li><strong>通用食谱</strong>：2.0 肉度 + 一个蜂蜜（不能是蜂巢） + 其他（不能有树枝、蛋）</li><li><strong>我的食谱</strong>：一个大肉 + 一个怪兽肉 + 一个蜂蜜 + 一个蔬菜&#x2F;水果（不能有榴莲）</li></ul><p><strong>点评</strong>：似乎很多人推荐蜜汁火腿，但由于需要两个肉度，至少也要一个大肉加一个怪兽肉，或者两个小肉加一个怪兽肉。<br>对农场派的我而言，大肉是难得的食材，有大肉我更倾向于直接做晾干成风干肉；而拿出两个小肉来做也是有点奢侈。蜜汁火腿的优势可能在于饱食+回血，但对于农场派有更好且更廉价的选择，就是火龙果派。</p></li></ul><h4 id="推荐的单品"><a href="#推荐的单品" class="headerlink" title="推荐的单品"></a>推荐的单品</h4><p><strong>肉干类</strong></p><ul><li><p>风干肉</p><ul><li><strong>食谱属性</strong>：<strong>25 饱食、20 血、15 精神</strong>、20 天保存</li></ul></li><li><p>小风干肉</p><ul><li><strong>食谱属性</strong>：<strong>12.5 饱食、8 血、10 精神</strong>、20 天保存</li></ul></li></ul><p><strong>回血果蔬</strong></p><ul><li><p>烤茄子</p><ul><li><strong>食谱属性</strong>：<strong>25 饱食、20 血、0 精神</strong>、6 天保存（生茄子 10 天保存）</li></ul><p><strong>点评</strong>：烤石榴（正式翻译是石榴切片）同样能回 20 血，但饱食度只有 12.5，而且只有 3 天保存（生石榴 6 天保存），相比之下就要比烤茄子逊色了。</p></li><li><p>蓝蘑菇</p><ul><li><strong>食谱属性</strong>：<strong>12.5 饱食、20 血、-15 精神</strong>、10 天保存</li></ul></li></ul><p><strong>回 san 蔬菜</strong></p><ul><li><p>烤绿蘑菇</p><ul><li><strong>食谱属性</strong>：<strong>0 饱食、-1 血、15 精神</strong>、10 天保存（绿蘑菇 10 天保存）</li></ul></li><li><p>烤仙人掌肉</p><ul><li><strong>食谱属性</strong>：<strong>12.5 饱食、1 血、15 精神</strong>、10 天保存（仙人掌肉 10 天保存）</li></ul><p><strong>点评</strong>：采摘仙人掌肉会损失 6 点血，夏天的时候会额外获得仙人掌花，仙人掌花回 8 点血，所以夏天采集仙人掌不会减血反而加血。</p></li><li><p>烤蓝蘑菇</p><ul><li><strong>食谱属性</strong>：<strong>0 饱食、-3 血、10 精神</strong>、10 天保存</li></ul></li></ul><p><strong>饱食蔬菜</strong></p><ul><li><p>烤南瓜</p><ul><li><strong>食谱属性</strong>：<strong>37.5 饱食、8 血、0 精神</strong>、6 天保存（生南瓜 10 天保存）</li></ul><p><strong>点评</strong>：饱食度比单块的肉还高，前面对南瓜饼与太妃糖的点评已经分析了烤南瓜作为单品食用的优势。</p></li></ul><h4 id="喜欢但不常做的食谱"><a href="#喜欢但不常做的食谱" class="headerlink" title="喜欢但不常做的食谱"></a>喜欢但不常做的食谱</h4><ul><li><p><strong>鱼排</strong></p><ul><li><strong>食谱属性</strong>：<strong>37.5 饱食、40 血、5 精神</strong>、40 秒烹饪、10 天保存</li><li><strong>通用食谱</strong>：一个鱼或鳗鱼 + 一个树枝 + 其他</li><li><strong>我的食谱</strong>：一个鱼  + 一个树枝 + 两个蔬菜&#x2F;水果（玉米除外）</li><li><strong>额外说明</strong><ol><li>由于放了树枝，所以填充物可以时两个怪兽肉</li><li>“一个鱼 + 一个玉米”可能会做成炸鱼玉米饼（鱼塔可），37.5 饱食、20 血、5 精神、10 秒烹饪、6 天保存，虽然能放两个树枝，但明显浪费了食材</li></ol></li></ul><p><strong>点评</strong>：同样是回血神器，但我几乎不怎么钓鱼，只是偶尔靠被鱼人得到鱼，所以不怎么做。</p></li><li><p><strong>花瓣沙拉</strong></p><ul><li><strong>食谱属性</strong>：<strong>12.5 饱食、40 血、5 精神</strong>、10 秒烹饪、6 天保存</li><li><strong>通用食谱</strong>：一个仙人掌花 + 额外 1.5 蔬菜度 + 其他（不能有肉、蛋、水果、树枝、甜品，基本只能用冰）</li><li><strong>我的食谱</strong>：一个仙人掌花  + 三个蔬菜&#x2F;蘑菇</li></ul><p><strong>点评</strong>：<strong>仙人掌为巨人国DLC增加</strong>，回血神器再 +1，但仙人掌花只有夏天跑到沙漠才能采，而且仙人掌花只有 3 天保存期，所以不经常做。只在初夏制作花衬衫的时候，顺便多采几个仙人掌来做。</p></li></ul><h4 id="不太喜欢的食谱"><a href="#不太喜欢的食谱" class="headerlink" title="不太喜欢的食谱"></a>不太喜欢的食谱</h4><ul><li><p><strong>蜜汁肉块</strong></p><ul><li><strong>食谱属性</strong>：<strong>37.5 饱食、20 血、5 精神</strong>、40 秒烹饪、15 天保存</li><li><strong>通用食谱</strong>：0.5 肉度 + 一个蜂蜜（不能是蜂巢） + 其他（不能有树枝、蛋）</li><li><strong>我的食谱</strong>：一个小肉  + 一个蜂蜜 + 两个蔬菜&#x2F;水果</li></ul><p><strong>点评</strong>：蜜汁肉块的属性和青蛙腿三明治相当（除了保存时间多 5 天，烹饪时间多 30 秒）。</p></li></ul><h4 id="稀有食谱"><a href="#稀有食谱" class="headerlink" title="稀有食谱"></a>稀有食谱</h4><ul><li><p><strong>冰激凌</strong></p><ul><li><strong>食谱属性</strong>：<strong>25 饱食、0 血、50 精神</strong>、10 秒烹饪、3 天保存</li><li><strong>通用食谱</strong>：一个羊奶 + 一个蜂蜜&#x2F;蜂巢 + 一个冰 + 其他（不能有肉、蛋、蔬菜、树枝）</li><li><strong>我的食谱</strong>：一个羊奶  + 一个蜂蜜 + 一个冰 + 一个浆果或冰</li></ul><p><strong>点评</strong>：<strong>羊奶为巨人国DLC增加</strong>，回 san 神器，回 san 最高的食谱。羊奶由被雷击的山羊掉落（100% 掉落）。让山羊被雷击有几种方式：自然状态下雨时被雷击、老奶奶读书、晨星锤攻击。通用而稳定的方法就是第三种，用晨星锤攻击。<br>晨星锤的制作需要羊角，羊角可由山羊或被雷击的山羊掉落，概率均为 25%。打山羊的时候通常是先用其他武器将山羊打到 100 血以下，再用晨星锤对山羊充电，最后杀死。</p></li></ul><h4 id="海滩穿越食谱"><a href="#海滩穿越食谱" class="headerlink" title="海滩穿越食谱"></a>海滩穿越食谱</h4><ul><li><p><strong>咖啡</strong></p><ul><li><strong>食谱属性</strong>：<strong>9.375 饱食、3 血、-5 精神</strong>、10 秒烹饪、10 天保存</li><li><strong>额外 Buff</strong>：增加 5 点移动速度，持续 4 分钟（半个游戏天）。普通角色移动速度为 6，相当于增加了 83% 的移动速度。</li><li><strong>通用食谱</strong>：三个烘焙咖啡豆 + 填充物（填充物只能为烘培咖啡豆、蜂蜜、羊奶）</li><li><strong>我的食谱</strong>：三个烘焙咖啡豆 + 一个蜂蜜</li></ul><p><strong>点评</strong>：颇费周折从海滩穿越过来，为的就是咖啡。跑在地图上飞快，配合手杖甚至夏天都可以到处乱跑。</p></li></ul><h3 id="我的食品生产模式"><a href="#我的食品生产模式" class="headerlink" title="我的食品生产模式"></a>我的食品生产模式</h3><p>在开头提到，我是农场怪兽流，所以农场 + 鸟是我的基本生产模式，此外还养了一个蜂巢，用于获取蜂蜜。前期靠鸟把怪兽肉变成蛋，后期食材较丰富后，开始喂给鸟火龙果、南瓜等重点果蔬，获得专门的火龙果种子和南瓜种子。</p><p>关于怪兽肉的获取，我把家建在了离池塘稍近的地方，靠青蛙与猎狗两方争斗获取怪兽肉，此外就是去刷蜘蛛（蜘蛛网也是捕鸟养鸟的前提，所以蜘蛛是农场派和怪兽肉的结合点）。没有把家建在猪舍旁，因为猪喜欢吃种子，对农场派而言有点烦。没有把家建在牛群旁，因为就算是农场派，需要肥料时再去找也就够了，不需要特别多。</p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h3&gt;&lt;p&gt;这几天一直在玩《饥荒》，起因是想起大一和几个室友联机打游戏的场景；而且虽然我已经在 Steam 补票，但一直没怎么玩，于是重新开始，沉迷了几天。写一写这几天打游戏的感受，主要是点评食谱以及围绕食谱展开的生存模式。&lt;/p&gt;</summary>
    
    
    
    <category term="二次元与游戏" scheme="http://yoursite.com/categories/%E4%BA%8C%E6%AC%A1%E5%85%83%E4%B8%8E%E6%B8%B8%E6%88%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>nnedi3 相关代码学习</title>
    <link href="http://yoursite.com/2020/04/30/nnedi3/"/>
    <id>http://yoursite.com/2020/04/30/nnedi3/</id>
    <published>2020-04-30T13:17:39.000Z</published>
    <updated>2020-04-30T13:17:39.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>其实不知道有没有必要像这样，为并不是很复杂的源码煞有介事地写一份包含个人感想的阅读笔记。但不得不说，<a href="https://forum.doom9.org/showthread.php?t=147695">nnedi3</a> 相关的内容，从我最开始接触图像处理，就一直萦绕在心头。一直觉得 nnedi3 很神奇，抗锯齿用它，重采样放大也用它，因为用了神经网络更显得高大上。另一方面，随着 Deep Learning 浪潮涌起，有些人开始质疑对 Deep Learning 的跟风。于是有种错觉，用传统神经网络的 nnedi3，既套上了光环，又躲过了质疑。</p><p>起初接触 nnedi3 是通过 <a href="https://www.nmm-hd.org/newbbs/viewtopic.php?f=7&t=1117">nnedi3_resize16</a> 这个流传甚广的缩放脚本。之后在我学会 deband 与边缘检测后，很长时间没有继续学新东西，几乎过了一年，我才接触到 nnedi3 的抗锯齿用途。又跨过大半年，在我熟悉 Github 之后，到第二年的秋天，我又看到了优化版的 <a href="https://github.com/sekrit-twc/znedi3">znedi3</a> 和 <a href="(https://github.com/HomeOfVapourSynthEvolution/VapourSynth-NNEDI3CL)">nnedi3cl</a>。某种角度上，nnedi3 贯穿了我到目前为止的图像处理学习过程。</p><span id="more"></span><p>我已经忘记之前是在哪里看到，说 nnedi3 没有开源。我也模糊得记得，找过 eedi 系列滤镜，没找到代码（事实上也是开源的）。于是交错的印象下，在我开始写 C++ 之前，没有再深入了解 nnedi3。即使是之后开始写 VapourSynth Plugin，也是模仿着 Deblock 和 nnedi2 的框架（话说这对初学者而言，和 nnedi3 比也没什么区别喂喂，只是我当时选择性地无视了）。</p><p>BTW，学习代码不是自己写代码，有时候需要不求甚解，明白意思即可，不然也只是浪费时间。</p><h3 id="代码概览"><a href="#代码概览" class="headerlink" title="代码概览"></a>代码概览</h3><h4 id="代码框架"><a href="#代码框架" class="headerlink" title="代码框架"></a>代码框架</h4><p><a href="https://github.com/HomeOfVapourSynthEvolution/VapourSynth-NNEDI3CL">VapourSynth-NNEDI3CL</a> 是 VapourSynth 框架下进行了 OpenCL 优化的 nnedi3 实现，除了 OpenCL 配置文件外，只有一份 nnedi3cl.cpp，代码结构也不复杂，VapourSynth Plugin 框架的四个函数 + 一个 process() 性质的函数。</p><p>重新审视一下 VapourSynth Plugin 框架的四个函数，初始化函数 Init() 和 释放内存函数 Free() 不必多说，从计算内容的角度看，GetFrame() 函数是与图像内容相关的计算，会用到像素点的数据，而 Create() 函数（除获取参数外）则是无关像素点数值的计算，至多会用到视频格式的信息。从两个函数的名字上看也能看出这一点。</p><p>NNEDI3CL 因为涉及 OpenCL，且参数较多，Create() 函数中报错信息占了较长的篇幅。nnedi3 最原始的用途是隔行插值反交错，所以在 GetFrame() 函数中，比只处理逐行的滤镜，多了 field &#x2F; 场信息的判断。</p><p>大致浏览完这些信息，核心处理从<code>nnedi3_weights.bin</code>文件入手。</p><h4 id="主要数据"><a href="#主要数据" class="headerlink" title="主要数据"></a>主要数据</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++">compute::command_queue queue;<br>compute::kernel kernel;<br>compute::image2d src, dst, tmp;<br>compute::buffer weights0, weights1Buffer;<br>cl_mem weights1;<br></code></pre></td></tr></table></figure><p>其中<code>queue</code>、<code>kernel</code>用于 OpenCL 框架，三个<code>image2D</code>类型的变量<code>src</code>、<code>dst</code>、<code>tmp</code>用于储存图像，余下三个变量则是与神经网络权值相关。</p><p>在 Create() 函数内，<code>weights0</code>、<code>weights1</code>都是<code>float</code>指针。</p><p><code>cl_mem</code>类型用于在设备上分配内存，<code>cl_mem</code>类型是”Memory Object“的句柄，提供了一种内存抽象。</p><h3 id="神经网络"><a href="#神经网络" class="headerlink" title="神经网络"></a>神经网络</h3><h4 id="IO-部分"><a href="#IO-部分" class="headerlink" title="IO 部分"></a>IO 部分</h4><p>由于使用传统神经网络，需要读入权值文件<code>nnedi3_weights.bin</code>。IO 部分基于头文件<code>&lt;cstdio&gt;</code>。</p><p>除了常见的<code>std::fopen</code>、<code>std::fclose</code>外，还用到了下面这些函数。</p><p><code>std::fread</code>-<code>std::size_t fread(void* buffer, std::size_t size, std::size_t count, std::FILE* stream)</code>：从输入流读取至多 <code>count</code> 个对象到数组 <code>buffer</code> 中，返回成功读取的对象数。</p><p><code>std::rewind</code>-<code>void rewind(std::FILE* stream)</code>：移动文件位置指示器到给定文件流的起始。</p><p><code>std::ftell</code>-<code>long ftell(std::FILE* stream)</code>：返回文件流文件位置指示器的当前值。</p><p>读入的<strong>权值数据保存在<code>bdata</code>中</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">constexpr</span> <span class="hljs-type">long</span> correctSize = <span class="hljs-number">13574928</span>; <span class="hljs-comment">// Version 0.9.4 of the Avisynth plugin</span><br><br><span class="hljs-type">float</span> * bdata = <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">float</span> *&gt;(<span class="hljs-built_in">malloc</span>(correctSize));<br><span class="hljs-type">const</span> <span class="hljs-type">size_t</span> bytesRead = std::<span class="hljs-built_in">fread</span>(bdata, <span class="hljs-number">1</span>, correctSize, weightsFile);<br></code></pre></td></tr></table></figure><h4 id="权值计算的后续"><a href="#权值计算的后续" class="headerlink" title="权值计算的后续"></a>权值计算的后续</h4><p>Create() 部分的权值有点复杂，先看看 Create() 权值计算结果是怎么用到 GetFrame() 上的吧。</p><p>如后文的”OpenCL 变量“部分所说，三个权值变量被 GetFrame() 调用的只有两个，<code>weights0</code>和<code>weights1</code>，被调用的位置和次数一样，只是<code>weights1</code>在 Free() 函数中多了一步释放。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">clReleaseMemObject</span>(d-&gt;weights1);<br></code></pre></td></tr></table></figure><p>两个变量在三个分支的<code>if-else</code>中同时出现了四次，伪代码如下。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta"># bool d-&gt;dw, d-&gt;dh;</span><br><br><span class="hljs-keyword">if</span> (d-&gt;dw &amp;&amp; d-&gt;dh)<br>&#123;<br>    kernel.<span class="hljs-built_in">set_args</span>(src, tmp, d-&gt;weights0, d-&gt;weights1, size_h_w, field, <span class="hljs-number">-1</span>);<br>    kernel.<span class="hljs-built_in">set_args</span>(tmp, dst, d-&gt;weights0, d-&gt;weights1, size_w_h, field,  <span class="hljs-number">0</span>);<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (d-&gt;dw)<br>&#123;<br>    kernel.<span class="hljs-built_in">set_args</span>(src, dst, d-&gt;weights0, d-&gt;weights1, size_h_w, field, <span class="hljs-number">-1</span>);<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>    kernel.<span class="hljs-built_in">set_args</span>(src, dst, d-&gt;weights0, d-&gt;weights1, size_w_h, field,  <span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>很明显，是从 x，y 两个方向分别处理。在这四次调用中，<code>weights0</code>和<code>weights1</code>发挥的作用是等价。</p><p>进而来整体看下 GetFrame() 函数及 process() 函数（在 NNEDI3CL 里写作 <code>filter()</code>），常规而且仅有骨架，上面的伪代码便是核心而唯一的操作，除此之前唯一陌生的地方就是增加了 field 信息的判断。</p><p>于是，可以转向 .cl 文件看核心计算了。</p><h3 id="OpenCL-核心计算"><a href="#OpenCL-核心计算" class="headerlink" title="OpenCL 核心计算"></a>OpenCL 核心计算</h3><p>这部分是 .cl 文件中的代码学习笔记。</p><p>命名空间（好像说法不太对..）<code>kernel</code>下的函数有两个重载，分别对应<code>float</code>类型和 uint 类型，看看其中一个。（删去了<code>&quot;\n&quot;</code>）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++">__kernel __attribute__((<span class="hljs-built_in">reqd_work_group_size</span>(<span class="hljs-number">4</span>, <span class="hljs-number">16</span>, <span class="hljs-number">1</span>)))<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">filter_uint</span><span class="hljs-params">(__read_only <span class="hljs-type">image2d_t</span> src, __write_only <span class="hljs-type">image2d_t</span> dst,</span></span><br><span class="hljs-params"><span class="hljs-function">                 __constant <span class="hljs-type">float</span> * weights0, __read_only <span class="hljs-type">image1d_buffer_t</span> weights1,</span></span><br><span class="hljs-params"><span class="hljs-function">                 <span class="hljs-type">const</span> <span class="hljs-type">int</span> srcWidth, <span class="hljs-type">const</span> <span class="hljs-type">int</span> srcHeight, <span class="hljs-type">const</span> <span class="hljs-type">int</span> dstWidth,</span></span><br><span class="hljs-params"><span class="hljs-function">                 <span class="hljs-type">const</span> <span class="hljs-type">int</span> dstHeight, <span class="hljs-type">const</span> <span class="hljs-type">int</span> field_n, <span class="hljs-type">const</span> <span class="hljs-type">int</span> off, <span class="hljs-type">const</span> <span class="hljs-type">int</span> swap)</span></span><br></code></pre></td></tr></table></figure><p>和前面<code>filter()</code>函数中的核心处理相对应。</p><p>追踪一下<code>weights0</code>的传递过程。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">float8 output = <span class="hljs-built_in">PRESCREEN</span>((<span class="hljs-type">const</span> __local <span class="hljs-built_in">float</span> (*)[INPUT_WIDTH])&amp;input[YDIAD2M1 - <span class="hljs-number">1</span> + localY][XDIAD2M1 - PSCRN_OFFSET + <span class="hljs-number">8</span> * localX],<br>                          &amp;flag, weights0);<br></code></pre></td></tr></table></figure><p>（这个<code>PRESCREEN()</code>是啥…）</p><h3 id="OpenCL-接口部分"><a href="#OpenCL-接口部分" class="headerlink" title="OpenCL 接口部分"></a>OpenCL 接口部分</h3><p>这部分是 Create() 函数中出现的 OpenCL 相关内容。</p><h4 id="相关函数"><a href="#相关函数" class="headerlink" title="相关函数"></a>相关函数</h4><h5 id="clCreateImage"><a href="#clCreateImage" class="headerlink" title="clCreateImage"></a><code>clCreateImage</code></h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">cl_mem <span class="hljs-title">clCreateImage</span><span class="hljs-params">(cl_context              context,</span></span><br><span class="hljs-params"><span class="hljs-function">                     cl_mem_flags            flags,</span></span><br><span class="hljs-params"><span class="hljs-function">                     <span class="hljs-type">const</span> cl_image_format  *image_format,</span></span><br><span class="hljs-params"><span class="hljs-function">                     <span class="hljs-type">const</span> cl_image_desc    *image_desc,</span></span><br><span class="hljs-params"><span class="hljs-function">                     <span class="hljs-type">void</span>                   *host_ptr,</span></span><br><span class="hljs-params"><span class="hljs-function">                     cl_int                 *errcode_ret)</span></span><br></code></pre></td></tr></table></figure><p>Creates a 1D image, 1D image buffer, 1D image array, 2D image, 2D image array or 3D image object.</p><p>创建一维图像、一维图像 buffer、一维图像数组、二维图像、二维图像数组或者三维图像对象。</p><h4 id="OpenCL-变量"><a href="#OpenCL-变量" class="headerlink" title="OpenCL 变量"></a>OpenCL 变量</h4><h5 id="d-gt-weights1"><a href="#d-gt-weights1" class="headerlink" title="d-&gt;weights1"></a><code>d-&gt;weights1</code></h5><p>结构体内的<code>weights1</code>定义如下。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">cl_mem mem = <span class="hljs-built_in">clCreateImage</span>(context, <span class="hljs-number">0</span>, &amp;format, &amp;desc, <span class="hljs-literal">nullptr</span>, &amp;error);<br>d-&gt;weights1 = mem;<br></code></pre></td></tr></table></figure><p>其中，<code>mem</code>的主要数据来自<code>desc</code>。</p><p><code>desc</code>的数据，除了一些格式上的常数，一是来自<code>dims1 </code>，一是来自权值<code>weights1Buffer</code>，也就是三个结构体内的数据之一。</p><p><code>dims1</code>的定义如下，都是常数计算，没有额外的东西。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> <span class="hljs-type">int</span> dims1 = nnsTable[nns] * <span class="hljs-number">2</span> * (xdiaTable[nsize] * ydiaTable[nsize] + <span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure><p>所以综上所述，<code>weights1</code>与<code>weights1Buffer</code>有种套娃之感，核心数据是一样的。（看一下名字啊，<code>weights1Buffer</code>&#x3D;<code>weights1</code>+<code>buffer</code>）</p><h5 id="d-gt-weights0与d-gt-weights1Buffer"><a href="#d-gt-weights0与d-gt-weights1Buffer" class="headerlink" title="d-&gt;weights0与d-&gt;weights1Buffer"></a><code>d-&gt;weights0</code>与<code>d-&gt;weights1Buffer</code></h5><p>结构体内的<code>weights0</code>与<code>weights1Buffer</code>定义如下。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++">d-&gt;weights0 = compute::buffer&#123; context, std::<span class="hljs-built_in">max</span>(dims0, dims0new) * <span class="hljs-built_in">sizeof</span>(cl_float),<br>    CL_MEM_READ_ONLY | CL_MEM_COPY_HOST_PTR | CL_MEM_HOST_NO_ACCESS, weights0 &#125;;<br><br>d-&gt;weights1Buffer = compute::buffer&#123; context, dims1 * <span class="hljs-number">2</span> * <span class="hljs-built_in">sizeof</span>(cl_float),<br>    CL_MEM_READ_ONLY | CL_MEM_COPY_HOST_PTR | CL_MEM_HOST_NO_ACCESS, weights1 &#125;;<br></code></pre></td></tr></table></figure><p>事实上，<code>weights1Buffer</code>的调用范围仅限于 Create()，并没有在 GetFrame() 中调用。</p><h5 id="Create-内的同名变量"><a href="#Create-内的同名变量" class="headerlink" title="Create() 内的同名变量"></a>Create() 内的同名变量</h5><p>在 Create() 函数内，有两个临时变量性质的同名变量，定义如下。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">float</span>* weights0 = <span class="hljs-keyword">new</span> <span class="hljs-type">float</span>[std::<span class="hljs-built_in">max</span>(dims0, dims0new)];<br><span class="hljs-type">float</span>* weights1 = <span class="hljs-keyword">new</span> <span class="hljs-type">float</span>[dims1 * <span class="hljs-number">2</span>];<br></code></pre></td></tr></table></figure><p>它们在定义了<code>d-&gt;weights0</code>与<code>d-&gt;weights1Buffer</code>后被释放。</p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h3&gt;&lt;p&gt;其实不知道有没有必要像这样，为并不是很复杂的源码煞有介事地写一份包含个人感想的阅读笔记。但不得不说，&lt;a href=&quot;https://forum.doom9.org/showthread.php?t=147695&quot;&gt;nnedi3&lt;/a&gt; 相关的内容，从我最开始接触图像处理，就一直萦绕在心头。一直觉得 nnedi3 很神奇，抗锯齿用它，重采样放大也用它，因为用了神经网络更显得高大上。另一方面，随着 Deep Learning 浪潮涌起，有些人开始质疑对 Deep Learning 的跟风。于是有种错觉，用传统神经网络的 nnedi3，既套上了光环，又躲过了质疑。&lt;/p&gt;
&lt;p&gt;起初接触 nnedi3 是通过 &lt;a href=&quot;https://www.nmm-hd.org/newbbs/viewtopic.php?f=7&amp;t=1117&quot;&gt;nnedi3_resize16&lt;/a&gt; 这个流传甚广的缩放脚本。之后在我学会 deband 与边缘检测后，很长时间没有继续学新东西，几乎过了一年，我才接触到 nnedi3 的抗锯齿用途。又跨过大半年，在我熟悉 Github 之后，到第二年的秋天，我又看到了优化版的 &lt;a href=&quot;https://github.com/sekrit-twc/znedi3&quot;&gt;znedi3&lt;/a&gt; 和 &lt;a href=&quot;(https://github.com/HomeOfVapourSynthEvolution/VapourSynth-NNEDI3CL)&quot;&gt;nnedi3cl&lt;/a&gt;。某种角度上，nnedi3 贯穿了我到目前为止的图像处理学习过程。&lt;/p&gt;</summary>
    
    
    
    <category term="图像处理" scheme="http://yoursite.com/categories/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    
    
    <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
    <category term="VapourSynth" scheme="http://yoursite.com/tags/VapourSynth/"/>
    
  </entry>
  
  <entry>
    <title>一些较新的去雾（dehazing）算法</title>
    <link href="http://yoursite.com/2020/04/28/dehazing/"/>
    <id>http://yoursite.com/2020/04/28/dehazing/</id>
    <published>2020-04-28T13:12:23.000Z</published>
    <updated>2020-04-28T13:12:23.000Z</updated>
    
    <content type="html"><![CDATA[<p>提到去雾算法，首先想到的便是 2009 年的暗通道去雾算法，以及后续的导向滤波，搜索博客和 Github 发现了一些较新的去雾算法，也算是尝试跟上学术界的脚步。</p><span id="more"></span><ul><li><p>2013年基于对比度增强的去雾算法<br><a href="http://mcl.korea.ac.kr/projects/dehazing/#userconsent#">http://mcl.korea.ac.kr/projects/dehazing/#userconsent#</a></p></li><li><p>2016年非局部均值去雾算法<br><a href="https://github.com/danaberman/non-local-dehazing">https://github.com/danaberman/non-local-dehazing</a></p></li></ul><h3 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h3><p>基于对比度增强的去雾算法（以下简称 DehazingCE，CE &#x3D;  Contrast enhancement）的作者给出了完整的 C++ 代码，只是是基于 OpenCV 2 的（而且代码风格也有些复古）。对我来说，从头完整地把代码迁移到 VapourSynth 上有点困难，所以先做原始代码从 OpenCV 2 到 OpenCV 3 的迁移。</p><h4 id="数据类型的变化"><a href="#数据类型的变化" class="headerlink" title="数据类型的变化"></a>数据类型的变化</h4><p>从 OpenCV 2 的 IplImage 到 OpenCV 3 的 Mat。</p><h4 id="函数名与类型名的变化"><a href="#函数名与类型名的变化" class="headerlink" title="函数名与类型名的变化"></a>函数名与类型名的变化</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">cvCopyImage → cvCopy<br>cvCvtPixToPlane → cvSplit<br>POINT → cv::Point           <span class="hljs-comment">// 这个像是手滑</span><br></code></pre></td></tr></table></figure><h4 id="数据类型的变化-1"><a href="#数据类型的变化-1" class="headerlink" title="数据类型的变化"></a>数据类型的变化</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">double</span> deMean[<span class="hljs-number">3</span>];<br>→<br>  <span class="hljs-type">double</span> deMean_value[<span class="hljs-number">3</span>];<br>  CvScalar dpMean = <span class="hljs-built_in">cvScalar</span>(deMean_value[<span class="hljs-number">1</span>], deMean_value[<span class="hljs-number">2</span>], deMean_value[<span class="hljs-number">3</span>]);<br></code></pre></td></tr></table></figure><h4 id="添加头文件"><a href="#添加头文件" class="headerlink" title="添加头文件"></a>添加头文件</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;opencv2/videoio.hpp&gt;</span></span><br></code></pre></td></tr></table></figure><h4 id="补齐依赖项"><a href="#补齐依赖项" class="headerlink" title="补齐依赖项"></a>补齐依赖项</h4><p>缺少 OpenCV 2.4.3 的四个 .lib 静态库</p><p>缺少 MSVCP100D.dll、MSVCR100D.dll</p><h4 id="运行时遇到的问题"><a href="#运行时遇到的问题" class="headerlink" title="运行时遇到的问题"></a>运行时遇到的问题</h4><h5 id="问题1"><a href="#问题1" class="headerlink" title="问题1"></a>问题1</h5><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">引发了异常: 读取访问权限冲突。 **iminput** 是 <span class="hljs-literal">null</span>ptr。<br></code></pre></td></tr></table></figure><p>空指针，具体而言是没有定义输入图像…</p><h5 id="问题2"><a href="#问题2" class="headerlink" title="问题2"></a>问题2</h5><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lasso">Run<span class="hljs-params">-Time</span> Check Failure #2 - <span class="hljs-built_in">Stack</span> around the <span class="hljs-built_in">variable</span> <span class="hljs-string">&#x27;deMean_value&#x27;</span> was corrupted.<br></code></pre></td></tr></table></figure><p>指针越界了…</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;提到去雾算法，首先想到的便是 2009 年的暗通道去雾算法，以及后续的导向滤波，搜索博客和 Github 发现了一些较新的去雾算法，也算是尝试跟上学术界的脚步。&lt;/p&gt;</summary>
    
    
    
    <category term="图像处理" scheme="http://yoursite.com/categories/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    
    
  </entry>
  
  <entry>
    <title>周记 2020.03.16-03.22</title>
    <link href="http://yoursite.com/2020/04/28/week-202003-3/"/>
    <id>http://yoursite.com/2020/04/28/week-202003-3/</id>
    <published>2020-04-28T08:25:36.000Z</published>
    <updated>2020-04-28T08:25:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>strncpy() -&gt; memcpy() 从内存中复制，gcc对后者兼容性更好？避免warning？</p><p>学习编程的三个方向<br>1.整体结构设计，特别以类和对象为基础的面向对象的构成<br>2.算法优化，同样一个算法，怎么运行更快，这是coder该想的事情，而非算法专家想的事情<br>3.Debug，找bug并更正的能力</p><span id="more"></span><p>再拖着不接触核心算法真不是事，先用vs框架实现算法吧</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">tmp_array.<span class="hljs-built_in">resize</span>(tmp_array.<span class="hljs-built_in">size</span>() + coeff_per_pixel, <span class="hljs-number">0.f</span>); <span class="hljs-comment">// 调整大小，填零</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;strncpy() -&amp;gt; memcpy() 从内存中复制，gcc对后者兼容性更好？避免warning？&lt;/p&gt;
&lt;p&gt;学习编程的三个方向&lt;br&gt;1.整体结构设计，特别以类和对象为基础的面向对象的构成&lt;br&gt;2.算法优化，同样一个算法，怎么运行更快，这是coder该想的事情，而非算法专家想的事情&lt;br&gt;3.Debug，找bug并更正的能力&lt;/p&gt;</summary>
    
    
    
    <category term="笔记" scheme="http://yoursite.com/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>周记 2020.03.09-03.15</title>
    <link href="http://yoursite.com/2020/04/28/week-202003-2/"/>
    <id>http://yoursite.com/2020/04/28/week-202003-2/</id>
    <published>2020-04-28T08:23:47.000Z</published>
    <updated>2020-04-28T08:23:47.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="C-语法"><a href="#C-语法" class="headerlink" title="C++语法"></a>C++语法</h3><h4 id="explicit"><a href="#explicit" class="headerlink" title="explicit"></a><code>explicit</code></h4><p><code>explicit</code>用来修饰构造函数、转换函数（C++11）、推导指引（C++17），C++20可以在其后加表达式（详见：<a href="https://zh.cppreference.com/w/cpp/language/explicit%EF%BC%89%E3%80%82">https://zh.cppreference.com/w/cpp/language/explicit）。</a></p><p><strong>功能</strong></p><ul><li>被修饰的构造函数的类，不能进行隐式类型转换，只能进行显示类型转换</li><li>不能用于复制初始化</li></ul><p><strong>注意</strong></p><ul><li><code>explicit</code>只能用于构造函数的声明</li></ul><span id="more"></span><p><a href="https://www.cnblogs.com/this-543273659/archive/2011/08/02/2124596.html">这篇博文</a>中的例子。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/* without explicit */</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">circle</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">circle</span>(<span class="hljs-type">double</span> r) : <span class="hljs-built_in">R</span>(r) &#123;&#125;<br>    <span class="hljs-built_in">circle</span>(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y = <span class="hljs-number">0</span>) : <span class="hljs-built_in">X</span>(x), <span class="hljs-built_in">Y</span>(y) &#123;&#125;<br>    <span class="hljs-built_in">circle</span>(<span class="hljs-type">const</span> circle&amp; c) : <span class="hljs-built_in">R</span>(c.R), <span class="hljs-built_in">X</span>(c.X), <span class="hljs-built_in">Y</span>(c.Y) &#123;&#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">double</span> R;<br>    <span class="hljs-type">int</span> X, Y;<br>&#125;;<br><br><span class="hljs-type">int</span> _tmain()<br>&#123;<br>    circle A = <span class="hljs-number">1.23</span>;<br>    circle B = <span class="hljs-number">123</span>;<br>    circle C = A;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/* with explicit */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">circle</span><br>&#123;<br>    <span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">circle</span><span class="hljs-params">(<span class="hljs-type">double</span> r)</span> : R(r) &#123;</span>&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">circle</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y = <span class="hljs-number">0</span>)</span> : X(x), Y(y) &#123;</span>&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">circle</span><span class="hljs-params">(<span class="hljs-type">const</span> circle&amp; c)</span> : R(c.R), X(c.X), Y(c.Y) &#123;</span>&#125;<br>    <span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">double</span> R;<br>    <span class="hljs-type">int</span> X, Y;<br>&#125;;<br><br><span class="hljs-type">int</span> _tmain()<br>&#123;<br>    <span class="hljs-function">circle <span class="hljs-title">A</span><span class="hljs-params">(<span class="hljs-number">1.23</span>)</span></span>;<br>    <span class="hljs-function">circle <span class="hljs-title">B</span><span class="hljs-params">(<span class="hljs-number">123</span>)</span></span>;<br>    <span class="hljs-function">circle <span class="hljs-title">C</span><span class="hljs-params">(A)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在结构中也可以这么用。</p><h4 id="非常量引用的初始值必须是左值"><a href="#非常量引用的初始值必须是左值" class="headerlink" title="非常量引用的初始值必须是左值"></a>非常量引用的初始值必须是左值</h4><p>可能是存在不被允许的隐式类型转换。</p><h4 id="assert"><a href="#assert" class="headerlink" title="assert"></a><code>assert</code></h4><p><code>assert</code>是宏，不仅用来报错。</p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;C-语法&quot;&gt;&lt;a href=&quot;#C-语法&quot; class=&quot;headerlink&quot; title=&quot;C++语法&quot;&gt;&lt;/a&gt;C++语法&lt;/h3&gt;&lt;h4 id=&quot;explicit&quot;&gt;&lt;a href=&quot;#explicit&quot; class=&quot;headerlink&quot; title=&quot;explicit&quot;&gt;&lt;/a&gt;&lt;code&gt;explicit&lt;/code&gt;&lt;/h4&gt;&lt;p&gt;&lt;code&gt;explicit&lt;/code&gt;用来修饰构造函数、转换函数（C++11）、推导指引（C++17），C++20可以在其后加表达式（详见：&lt;a href=&quot;https://zh.cppreference.com/w/cpp/language/explicit%EF%BC%89%E3%80%82&quot;&gt;https://zh.cppreference.com/w/cpp/language/explicit）。&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;功能&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;被修饰的构造函数的类，不能进行隐式类型转换，只能进行显示类型转换&lt;/li&gt;
&lt;li&gt;不能用于复制初始化&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;explicit&lt;/code&gt;只能用于构造函数的声明&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="笔记" scheme="http://yoursite.com/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>从 VapourSynth API 到 C++ 基础知识</title>
    <link href="http://yoursite.com/2020/04/28/from-vs-to-cpp/"/>
    <id>http://yoursite.com/2020/04/28/from-vs-to-cpp/</id>
    <published>2020-04-28T08:16:44.000Z</published>
    <updated>2020-04-28T08:16:44.000Z</updated>
    
    <content type="html"><![CDATA[<p><del>副标题：从 C + isotream 到 C++</del></p><p>（这是1月底写一点随笔，然后就被丢到一边不管了）</p><h3 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h3><p>全面讲述智能指针的文章：<a href="https://juejin.im/post/5dcaa857e51d457f7675360b">https://juejin.im/post/5dcaa857e51d457f7675360b</a></p><p>熟悉的<code>unique_ptr</code>，是“拥有独有对象所有权语义的智能指针”。</p><span id="more"></span><h4 id="智能指针的释放"><a href="#智能指针的释放" class="headerlink" title="智能指针的释放"></a>智能指针的释放</h4><p>一个基本概念，要用<code>.</code>而非<code>-&gt;</code>。（<a href="https://blog.csdn.net/delphicui/article/details/4213811%EF%BC%89">https://blog.csdn.net/delphicui/article/details/4213811）</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">smartPointer.<span class="hljs-built_in">release</span>();   <span class="hljs-comment">// 正确</span><br>smartPointer-&gt;<span class="hljs-built_in">release</span>();  <span class="hljs-comment">// 错误</span><br></code></pre></td></tr></table></figure><p>在 VapourSynth Plugin 的编写时，要在<code>Free()</code>函数里写<code>delete d;</code>，但又在<code>Create()</code>函数里写了<code>d.release()</code>。可不可以这么理解，智能指针<code>d</code>在<code>Creat()</code>函数里被声明，所以要在<code>Create()</code>函数内释放一次，但其他地方也用到了<code>d</code>，所以又要写一次<code>delete d</code>？<del>我感觉我在胡说八道</del></p><h4 id="智能指针与数组"><a href="#智能指针与数组" class="headerlink" title="智能指针与数组"></a>智能指针与数组</h4><p>用智能指针创建数组，类似下面这样。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">std::unique_ptr&lt;<span class="hljs-type">float</span>[]&gt; array[<span class="hljs-number">5</span>];<br></code></pre></td></tr></table></figure><p>而且用后并没有释放，这是自然，毕竟智能指针的本意即是如此。</p><p>但我不知道，对于查表用的大数组，有没有必要“升级”成智能指针，对于使用<code>new</code>创建的指针呢？</p><h3 id="com组件"><a href="#com组件" class="headerlink" title="com组件"></a>com组件</h3><p>（被淘汰的技术）</p><p>（我不知道 VapourSynth API 里的 com 是不是这个 com）</p><h3 id="lamda表达式"><a href="#lamda表达式" class="headerlink" title="lamda表达式"></a>lamda表达式</h3><p>（额外延伸的，稍后再看）</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;del&gt;副标题：从 C + isotream 到 C++&lt;/del&gt;&lt;/p&gt;
&lt;p&gt;（这是1月底写一点随笔，然后就被丢到一边不管了）&lt;/p&gt;
&lt;h3 id=&quot;智能指针&quot;&gt;&lt;a href=&quot;#智能指针&quot; class=&quot;headerlink&quot; title=&quot;智能指针&quot;&gt;&lt;/a&gt;智能指针&lt;/h3&gt;&lt;p&gt;全面讲述智能指针的文章：&lt;a href=&quot;https://juejin.im/post/5dcaa857e51d457f7675360b&quot;&gt;https://juejin.im/post/5dcaa857e51d457f7675360b&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;熟悉的&lt;code&gt;unique_ptr&lt;/code&gt;，是“拥有独有对象所有权语义的智能指针”。&lt;/p&gt;</summary>
    
    
    
    <category term="图像处理" scheme="http://yoursite.com/categories/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    
    
    <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
    <category term="VapourSynth" scheme="http://yoursite.com/tags/VapourSynth/"/>
    
  </entry>
  
  <entry>
    <title>色调映射（Tone mapping）</title>
    <link href="http://yoursite.com/2020/04/28/Tonemapping/"/>
    <id>http://yoursite.com/2020/04/28/Tonemapping/</id>
    <published>2020-04-28T08:07:48.000Z</published>
    <updated>2020-04-28T08:07:48.000Z</updated>
    
    <content type="html"><![CDATA[<p>在<a href="https://kiyamou.github.io/2020/02/08/ISP-learn-1/">之前的博文</a>中提到过色调映射，色调映射可以做很多事情，既包括对相机 raw 文件的亮度调整，也可以做 HDR 的转换。</p><span id="more"></span><p>在 VapourSynth 社区中，原生的色调映射滤镜&#x2F;脚本有两个，一个<a href="https://github.com/ifb/vapoursynth-tonemap">滤镜</a>、一个<a href="https://github.com/age1988/vapoursynth-tonemapping">脚本</a>，另外还有基于 placebo 库的<a href="https://github.com/Lypheo/vs-placebo">vs-placebo滤镜</a>，以及一个<a href="https://github.com/xyx98/my-vapoursynth-script/blob/master/xvs.py#L1087">高级函数</a>。</p><p>这些工具中，除了基于 placebo 库的 vs-placebo，因为要用 vulkan 而我的老旧设备不支持外，其余都尝试过了。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在&lt;a href=&quot;https://kiyamou.github.io/2020/02/08/ISP-learn-1/&quot;&gt;之前的博文&lt;/a&gt;中提到过色调映射，色调映射可以做很多事情，既包括对相机 raw 文件的亮度调整，也可以做 HDR 的转换。&lt;/p&gt;</summary>
    
    
    
    <category term="图像处理" scheme="http://yoursite.com/categories/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    
    
  </entry>
  
  <entry>
    <title>Retinex 算法</title>
    <link href="http://yoursite.com/2020/04/28/Retinex/"/>
    <id>http://yoursite.com/2020/04/28/Retinex/</id>
    <published>2020-04-28T08:01:38.000Z</published>
    <updated>2020-04-28T08:01:38.000Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><p>Retinex系列算法如下。</p><h4 id="SSR"><a href="#SSR" class="headerlink" title="SSR"></a>SSR</h4><p>SSR（Single-Scale Retinex）：单尺度 Retinex 算法。</p><h4 id="MSR"><a href="#MSR" class="headerlink" title="MSR"></a>MSR</h4><p>MSR（Multi-Scale Retinex）：多尺度 Retinex 算法，对多个单尺度 Retinex 的结果进行平均。</p><h4 id="MSRCP"><a href="#MSRCP" class="headerlink" title="MSRCP"></a>MSRCP</h4><p>MSRCP：色彩恢复多尺度 Retinex 算法，相当于把亮的地方压缩（变黑），而把黑的地方升高变亮。</p><h4 id="MSRCR"><a href="#MSRCR" class="headerlink" title="MSRCR"></a>MSRCR</h4><p>MSRCR（Multi-Scale Retinex with Color Restoration）：色彩恢复多尺度 Retinex 算法，在 MSRCP 的基础上会改变颜色，让颜色均衡，通常会导致画面变暗，但对于一些图像，可以避免 MSRCP 导致的色差（画面颜色过暖）问题。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;p&gt;Retinex系列算法如下。&lt;/p&gt;
&lt;h4 id=&quot;SSR&quot;&gt;&lt;a href=&quot;#SSR&quot; class=&quot;headerlink&quot; title=&quot;SSR&quot;&gt;&lt;/a&gt;SSR&lt;/h4&gt;&lt;p&gt;SSR（Single-Scale Re</summary>
      
    
    
    
    <category term="图像处理" scheme="http://yoursite.com/categories/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    
    
  </entry>
  
  <entry>
    <title>边缘检测</title>
    <link href="http://yoursite.com/2020/04/27/edgemasks/"/>
    <id>http://yoursite.com/2020/04/27/edgemasks/</id>
    <published>2020-04-26T19:00:48.000Z</published>
    <updated>2020-04-26T19:00:48.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文翻译自 <a href="https://blog.kageru.moe/legacy/edgemasks.html">Edge Masks</a>，原作者：<a href="https://github.com/kageru">kageru</a>。</p><p><em>译者：“mask”的中文译名应该是“蒙版”，不太习惯这个词，于是把标题写成了边缘检测，文内还是直接用英文“mask”。</em></p><span id="more"></span><h3 id="理论、实例和解释"><a href="#理论、实例和解释" class="headerlink" title="理论、实例和解释"></a>理论、实例和解释</h3><p><em>译者：本节篇幅较长，译者添加了小标题。</em></p><p>大多数流行的算法通过卷积来衡量像素邻域变化，以确定亮度变化。卷积计算的时间复杂度为 O(n^2)，其中 n 为卷积核半径，因此卷积核在保存适当精度的前提下越小越好。卷积核半径越低，越容易受到噪声（noise）和瑕疵（artifacts）的影响。</p><p>多数算法采用 3x3 卷积核，在速度和准确性间提供了最佳平衡。例子便是 Prewitt、Sobel、Scharr 和 Kirsch 提出的算子。对于无噪声的干净信号源，也可使用 2x2 卷积（<a href="http://homepages.inf.ed.ac.uk/rbf/HIPR2/roberts.htm">文献</a>），但目前的硬件已经能够实时处理 3x3 卷积。</p><h4 id="Sobel-算子"><a href="#Sobel-算子" class="headerlink" title="Sobel 算子"></a>Sobel 算子</h4><p>以 Sobel 算子为例，x 方向和 y 方向分别进行卷积。</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">---------------   --------------<br>|<span class="hljs-string"> -1 </span>|<span class="hljs-string"> 2 </span>|<span class="hljs-string"> -1 </span>|<span class="hljs-string">   </span>|<span class="hljs-string"> -1 </span>|<span class="hljs-string"> 0 </span>|<span class="hljs-string"> 1 </span>|<br>|<span class="hljs-string">  0 </span>|<span class="hljs-string"> 0 </span>|<span class="hljs-string">  0 </span>|<span class="hljs-string">   </span>|<span class="hljs-string">  2 </span>|<span class="hljs-string"> 0 </span>|<span class="hljs-string"> 2 </span>|<span class="hljs-string"> </span><br><span class="hljs-string"></span>|<span class="hljs-string">  1 </span>|<span class="hljs-string"> 2 </span>|<span class="hljs-string">  1 </span>|<span class="hljs-string">   </span>|<span class="hljs-string"> -1 </span>|<span class="hljs-string"> 0 </span>|<span class="hljs-string"> 1 </span>|<br>---------------   --------------<br></code></pre></td></tr></table></figure><p>用 VapourSynth 简单实现如下。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">Sobel</span>(<span class="hljs-params">src</span>):<br>    sx = src.std.Convolution(matrix=[-<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, -<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>,  <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>], saturate=<span class="hljs-literal">False</span>)<br>    sy = src.std.Convolution(matrix=[-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>,  <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>, -<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>], saturate=<span class="hljs-literal">False</span>)<br>    <span class="hljs-keyword">return</span> core.std.Expr([sx, sy], <span class="hljs-string">&#x27;x y max&#x27;</span>)<br></code></pre></td></tr></table></figure><p>甚至，VapourSynth 内置了<code>core.std.Sobel</code>函数，我们不必自己写代码。</p><p>对于边缘模糊的图像，Sobel 算子的效果并不是很好。提高检测精度的一种方法是使用 8 邻域而非 4 邻域，即在邻域的 8 个方向上，或者说在 3x3 卷积核的对角线上，都将被计算。</p><h4 id="Kirsch-算子"><a href="#Kirsch-算子" class="headerlink" title="Kirsch 算子"></a>Kirsch 算子</h4><p>Russel A. Kirsch 在 1970 年提出了 Kirsch 算子（<a href="https://ddl.kageru.moe/konOJ.pdf">文献</a>）。</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">-----------------<br>|<span class="hljs-string">  5 </span>|<span class="hljs-string">  5  </span>|<span class="hljs-string">  5 </span>|<br>|<span class="hljs-string"> -3 </span>|<span class="hljs-string">  0  </span>|<span class="hljs-string"> -3 </span>|<br>|<span class="hljs-string"> -3 </span>|<span class="hljs-string"> -3  </span>|<span class="hljs-string"> -3 </span>|<br>-----------------<br></code></pre></td></tr></table></figure><p>该卷积核会旋转 45° 以回到其原始位置。</p><p>在 VapourSynth 中并未内置 Kirsch 算子，尝试通过 VapourSynth 内置的卷积方法实现。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">kirsch</span>(<span class="hljs-params">src</span>):<br>    kirsch1 = src.std.Convolution(matrix=[<span class="hljs-number">5</span>,   <span class="hljs-number">5</span>,  <span class="hljs-number">5</span>, -<span class="hljs-number">3</span>,  <span class="hljs-number">0</span>, -<span class="hljs-number">3</span>, -<span class="hljs-number">3</span>, -<span class="hljs-number">3</span>, -<span class="hljs-number">3</span>])<br>    kirsch2 = src.std.Convolution(matrix=[-<span class="hljs-number">3</span>,  <span class="hljs-number">5</span>,  <span class="hljs-number">5</span>,  <span class="hljs-number">5</span>,  <span class="hljs-number">0</span>, -<span class="hljs-number">3</span>, -<span class="hljs-number">3</span>, -<span class="hljs-number">3</span>, -<span class="hljs-number">3</span>])<br>    kirsch3 = src.std.Convolution(matrix=[-<span class="hljs-number">3</span>, -<span class="hljs-number">3</span>,  <span class="hljs-number">5</span>,  <span class="hljs-number">5</span>,  <span class="hljs-number">0</span>,  <span class="hljs-number">5</span>, -<span class="hljs-number">3</span>, -<span class="hljs-number">3</span>, -<span class="hljs-number">3</span>])<br>    kirsch4 = src.std.Convolution(matrix=[-<span class="hljs-number">3</span>, -<span class="hljs-number">3</span>, -<span class="hljs-number">3</span>,  <span class="hljs-number">5</span>,  <span class="hljs-number">0</span>,  <span class="hljs-number">5</span>,  <span class="hljs-number">5</span>, -<span class="hljs-number">3</span>, -<span class="hljs-number">3</span>])<br>    kirsch5 = src.std.Convolution(matrix=[-<span class="hljs-number">3</span>, -<span class="hljs-number">3</span>, -<span class="hljs-number">3</span>, -<span class="hljs-number">3</span>,  <span class="hljs-number">0</span>,  <span class="hljs-number">5</span>,  <span class="hljs-number">5</span>,  <span class="hljs-number">5</span>, -<span class="hljs-number">3</span>])<br>    kirsch6 = src.std.Convolution(matrix=[-<span class="hljs-number">3</span>, -<span class="hljs-number">3</span>, -<span class="hljs-number">3</span>, -<span class="hljs-number">3</span>,  <span class="hljs-number">0</span>, -<span class="hljs-number">3</span>,  <span class="hljs-number">5</span>,  <span class="hljs-number">5</span>,  <span class="hljs-number">5</span>])<br>    kirsch7 = src.std.Convolution(matrix=[ <span class="hljs-number">5</span>, -<span class="hljs-number">3</span>, -<span class="hljs-number">3</span>, -<span class="hljs-number">3</span>,  <span class="hljs-number">0</span>, -<span class="hljs-number">3</span>, -<span class="hljs-number">3</span>,  <span class="hljs-number">5</span>,  <span class="hljs-number">5</span>])<br>    kirsch8 = src.std.Convolution(matrix=[ <span class="hljs-number">5</span>,  <span class="hljs-number">5</span>, -<span class="hljs-number">3</span>, -<span class="hljs-number">3</span>,  <span class="hljs-number">0</span>, -<span class="hljs-number">3</span>, -<span class="hljs-number">3</span>,  <span class="hljs-number">5</span>, -<span class="hljs-number">3</span>])<br>    <span class="hljs-keyword">return</span> core.std.Expr([kirsch1, kirsch2, kirsch3, kirsch4, kirsch5, kirsch6, kirsch7, kirsch8],<br>                         <span class="hljs-string">&#x27;x y max z max a max b max c max d max e max&#x27;</span>)<br></code></pre></td></tr></table></figure><p>显然，简单的复制粘贴并不是一个好主意。当然，代码可以运行。但我不是数学家，而只有数学家才能去编写优雅的代码解决这一问题。换一种思路。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">kirsch</span>(<span class="hljs-params">src: vs.VideoNode</span>) -&gt; vs.VideoNode:<br>    w = [<span class="hljs-number">5</span>]*<span class="hljs-number">3</span> + [-<span class="hljs-number">3</span>]*<span class="hljs-number">5</span><br>    weights = [w[-i:] + w[:-i] <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">4</span>)]<br>    c = [core.std.Convolution(src, (w[:<span class="hljs-number">4</span>] + [<span class="hljs-number">0</span>] + w[<span class="hljs-number">4</span>:]), saturate=<span class="hljs-literal">False</span>) <span class="hljs-keyword">for</span> w <span class="hljs-keyword">in</span> weights]<br>    <span class="hljs-keyword">return</span> core.std.Expr(c, <span class="hljs-string">&#x27;x y max z max a max&#x27;</span>)<br></code></pre></td></tr></table></figure><p>已经好多了，先不去管可读性更强的代码。</p><p>将 Sobel mask 与 Kirsch mask 比较，后者的准确性有了明显提升。</p><p>边缘检测的精度越高，就越容易将噪点识别为边缘，可以通过事先降噪来克服上述问题。</p><p>提升精度对速度的影响可以忽略不计，对于 8bit 1080p 输入源，单纯 Sobel 算子（非 VapourSynth 内置的 Sobel 函数，因为它还包括了高通&#x2F;低通滤波与缩放功能，速度更慢）速度约为 215fps，Kirsch 算子速度为 175fps。诚然，Sobel 算子也检出了许多边缘，但有些边缘不明显，需要使用<code>std.Binarize</code>增强才能达到 Kirsch 算子的效果。</p><h4 id="Canny-算法"><a href="#Canny-算法" class="headerlink" title="Canny 算法"></a>Canny 算法</h4><p>一种更复杂的边缘检测方法是 Canny 算法（译者注：<a href="http://web.archive.org/web/20130218131253/http://bengal.missouri.edu/~kes25c/">tritical</a> 在 AviSynth 框架下实现了 Canny 算法，被称为 TCanny 滤镜），这种算法使用类似的方法检测边缘，并将边缘的宽度缩小至 1 个像素。理想情况下，这些线条代表边缘的中部，且没有边缘被重复标记。此外，算法会进行高斯模糊，以降低噪声干扰（译者注：高斯模糊是前处理，在施加边缘检测算子之前）。一个例子如下。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">core.tcanny.TCanny(op=<span class="hljs-number">1</span>, mode=<span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><p>其中，<code>op=1</code>表示使用一种改进的算子，具有更好的信噪比。</p><p>下面是使用 5x5 卷积核的例子。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">src.std.Convolution(matrix=[<span class="hljs-number">1</span>,  <span class="hljs-number">2</span>,  <span class="hljs-number">4</span>,  <span class="hljs-number">2</span>, <span class="hljs-number">1</span>,<br>                            <span class="hljs-number">2</span>, -<span class="hljs-number">3</span>, -<span class="hljs-number">6</span>, -<span class="hljs-number">3</span>, <span class="hljs-number">2</span>,<br>                            <span class="hljs-number">4</span>, -<span class="hljs-number">6</span>,  <span class="hljs-number">0</span>, -<span class="hljs-number">6</span>, <span class="hljs-number">4</span>,<br>                            <span class="hljs-number">2</span>, -<span class="hljs-number">3</span>, -<span class="hljs-number">6</span>, -<span class="hljs-number">3</span>, <span class="hljs-number">2</span>,<br>                            <span class="hljs-number">1</span>,  <span class="hljs-number">2</span>,  <span class="hljs-number">4</span>,  <span class="hljs-number">2</span>, <span class="hljs-number">1</span>], saturate=<span class="hljs-literal">False</span>)<br></code></pre></td></tr></table></figure><p>这是尝试通过边缘检测创建边缘 mask。进过一些后处理，可以用于去取 halo 或者清理线条（尽管可以使用其他方法配合常规 mask（或许更好），比如<code>std.Maximum</code>或者<code>std.Expr</code>）。</p><h3 id="边缘-mask-的使用"><a href="#边缘-mask-的使用" class="headerlink" title="边缘 mask 的使用"></a>边缘 mask 的使用</h3><p>我们已经了解了基础知识，来看一下实际应用。目前大多数视频仍为 8bit，几乎不可避免地会产生色带（banding）。正如我在之前提到的，恢复（restoration）滤镜会引入新的瑕疵。在去色带时，细节也随之损失。进一步地，加大去色带力度，则会导致图像模糊。边缘 mask 用于修补上述副作用，实际过程为先让去色带滤镜进行去色带操作，然后使用边缘 mask 识别边缘与细节，并通过<code>std.MaskedMerge</code>恢复。</p><p>GradFun3 滤镜会在内部生成 mask，完成上述操作。另一个流行的去色带滤镜 f3kdb 则没有内置 mask 功能。</p><p>举个例子，单纯地进行去色带会破坏纹理（details，在这一语境下译为纹理比细节更合适），特别是暗场纹理。在这种情况下使用 Sobel 算子进行边缘检测，效果不好。</p><p>为了更好地识别暗场区域，使用 Retinex 算法进行局部对比度增强。</p><p>借助 Retinex 算法降低对比度，低对比度下我们能在暗场看到更丰富的内容。也许有人认为这些原本看不到的暗场细节没有意义，但随着 HDR 显示器的推广，普通观众也能看到这些细节。同时暗场细节不会占用过多码率，所以我认为保留它们没有什么坏处。</p><p>利用这些新知识，一些测试和一点点魔法，我们得到的 mask 准确性之高出乎意料。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">retinex_edgemask</span>(<span class="hljs-params">luma, sigma=<span class="hljs-number">1</span></span>):<br>    ret = core.retinex.MSRCP(luma, sigma=[<span class="hljs-number">50</span>, <span class="hljs-number">200</span>, <span class="hljs-number">350</span>], upper_thr=<span class="hljs-number">0.005</span>)<br>    <span class="hljs-keyword">return</span> core.std.Expr([kirsch(luma), ret.tcanny.TCanny(mode=<span class="hljs-number">1</span>, sigma=sigma).std.Minimum(coordinates=[<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>])], <span class="hljs-string">&#x27;x y +&#x27;</span>)<br></code></pre></td></tr></table></figure><p>进一步地，借助<code>std.Binarize</code>（或类似的高通&#x2F;低通函数），以及<code>std.Maximum</code>、<code>std.Inflate</code>的单独&#x2F;组合调用。我们可以把这一 mask 变成适用性更强的 mask，以应用于去色带或者其他需要精确 mask 的场合。</p><h3 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h3><p>绝大部分边缘检测算法均为简单的卷积运算，在 HD 源上使用也能达到 100fps 以上的速度，像 Retinex 这样复杂的算法当然不能与之相比。虽然使用 Sobel 算子进行简单的边缘检测，速度能超过 200fps，但组合 Retinex 算法后仅为 25 fps。速度瓶颈在 Retinex 算法上，单独使用 Retinex 算法速度约为 36.6fps。一种类似但低精度的暗场增强方法为调整亮度曲线，以暴露低对比度的边缘。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">bright = core.std.Expr(src, <span class="hljs-string">&#x27;x 65535 / sqrt 65535 *&#x27;</span>)<br></code></pre></td></tr></table></figure><p>理论上，可以通过调整亮度来改善暗场区域的边缘检测效果。</p><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>数十年来，边缘检测一直是图像处理的强大工具，可以缩减图像处理的范围，助推图像分析。在视频处理中同样有重要作用，可以最大限度地降低的副作用与瑕疵。通过卷积可以快速而准确地建立边缘 mask，并且可以通过调整内核参数来自定义卷积，以用于不同目的。此外，还可以通过局部对比度增强来提高检测精度，虽然速度会慢得多。</p><p>文中提到的代码可以在<a href="https://github.com/Irrational-Encoding-Wizardry/kagefunc/blob/master/kagefunc.py">这里</a>找到。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文翻译自 &lt;a href=&quot;https://blog.kageru.moe/legacy/edgemasks.html&quot;&gt;Edge Masks&lt;/a&gt;，原作者：&lt;a href=&quot;https://github.com/kageru&quot;&gt;kageru&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;译者：“mask”的中文译名应该是“蒙版”，不太习惯这个词，于是把标题写成了边缘检测，文内还是直接用英文“mask”。&lt;/em&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="图像处理" scheme="http://yoursite.com/categories/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    
    
    <category term="VapourSynth" scheme="http://yoursite.com/tags/VapourSynth/"/>
    
  </entry>
  
  <entry>
    <title>解释 RemoveGrain</title>
    <link href="http://yoursite.com/2020/04/27/explaining-removegrain/"/>
    <id>http://yoursite.com/2020/04/27/explaining-removegrain/</id>
    <published>2020-04-26T17:22:04.000Z</published>
    <updated>2020-04-26T17:22:04.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文翻译自 <a href="https://blog.kageru.moe/legacy/removegrain.html">Actually Explaining RemoveGrain</a>，原作者：<a href="https://github.com/kageru">kageru</a>。</p><span id="more"></span><h3 id="Mode-11-与-12"><a href="#Mode-11-与-12" class="headerlink" title="Mode 11 与 12"></a>Mode 11 与 12</h3><p>Mode 11 与 12 等价于</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">std.Convolution(matrix=[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>])<br></code></pre></td></tr></table></figure><p>Mode 11 和 Mode 12 没有区别，从代码上看是复制过来的，下面的测试也证明了这一点。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">&gt;&gt;&gt; d = core.std.<span class="hljs-constructor">Expr([<span class="hljs-params">clip</span>.<span class="hljs-params">rgvs</span>.RemoveGrain(<span class="hljs-params">mode</span>=11)</span>,<br>clip.rgvs.<span class="hljs-constructor">RemoveGrain(<span class="hljs-params">mode</span>=12)</span>], &#x27;x y - abs&#x27;)<br>&gt;&gt;&gt; d = d.std.<span class="hljs-constructor">PlaneStats()</span><br>&gt;&gt;&gt; d.get<span class="hljs-constructor">_frame(0)</span>.props.PlaneStatsAverage<br><span class="hljs-number">0.0</span><br></code></pre></td></tr></table></figure><p>但这两种模式与对应的卷积操作存在细微差别。</p><p><strong>Edit</strong>：这也可能是 VapourSynth-R36 中已修复的 PlaneStats bug 导致的，因为 0.05 的误差确实太大了。</p><p>（译者注：应该是 bug 导致的，在 VapourSynth-R49 中测试没有差别，下述结果为译者测试结果）</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">&gt;&gt;&gt; d = core.std.<span class="hljs-constructor">Expr([<span class="hljs-params">src</span>.<span class="hljs-params">rgvs</span>.RemoveGrain(<span class="hljs-params">mode</span>=12)</span>,<br>src.std.<span class="hljs-constructor">Convolution(<span class="hljs-params">matrix</span>=[1, 2, 1, 2, 4, 2, 1, 2, 1])</span>], &#x27;x y - abs&#x27;)<br>&gt;&gt;&gt; d = d.std.<span class="hljs-constructor">PlaneStats()</span><br>&gt;&gt;&gt; d.get<span class="hljs-constructor">_frame(0)</span>.props.PlaneStatsAverage<br><span class="hljs-number">0.0</span><br></code></pre></td></tr></table></figure><p>VapourSynth 内置的卷积滤镜通过插值处理边缘，而 RemoveGrain 则不处理边缘。</p><h3 id="Mode-13-16"><a href="#Mode-13-16" class="headerlink" title="Mode 13 - 16"></a>Mode 13 - 16</h3><p>这些模式为场内插值，速度非常快，但也非常不精确，类似粗制滥造的 EEDI。没有必要使用这些模式（EEDI2 于2005年发布，无论是这些模式还是 EEDI 都没必要使用）。</p><h3 id="Mode-17"><a href="#Mode-17" class="headerlink" title="Mode 17"></a>Mode 17</h3><blockquote><p>Clips the pixel with the minimum and maximum of respectively the maximum and minimum of each pair of opposite neighbour pixels.</p></blockquote><p>听上去可能有些困惑，但描述得很准确。这一模式会创建一个数组，包含极小值（lower）和极大值（upper），然后将中心像素限制在极大值的最小数和极小值的最大数之间。</p><h3 id="Mode-21-与-22"><a href="#Mode-21-与-22" class="headerlink" title="Mode 21 与 22"></a>Mode 21 与 22</h3><h4 id="Mode-21"><a href="#Mode-21" class="headerlink" title="Mode 21"></a>Mode 21</h4><p>中心像素替换为周围四对数字的最大值与最小值的均值。</p><h4 id="Mode-22"><a href="#Mode-22" class="headerlink" title="Mode 22"></a>Mode 22</h4><p>与 Mode 21 类似，但近似方式不同，比 Mode 21 更快。</p><h3 id="Mode-23-与-24"><a href="#Mode-23-与-24" class="headerlink" title="Mode 23 与 24"></a>Mode 23 与 24</h3><p>我难以解释这两个模式，也不知道这两个模式有什么用，如果想了解建议阅读代码。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文翻译自 &lt;a href=&quot;https://blog.kageru.moe/legacy/removegrain.html&quot;&gt;Actually Explaining RemoveGrain&lt;/a&gt;，原作者：&lt;a href=&quot;https://github.com/kageru&quot;&gt;kageru&lt;/a&gt;。&lt;/p&gt;</summary>
    
    
    
    <category term="图像处理" scheme="http://yoursite.com/categories/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    
    
    <category term="VapourSynth" scheme="http://yoursite.com/tags/VapourSynth/"/>
    
    <category term="Avisynth" scheme="http://yoursite.com/tags/Avisynth/"/>
    
  </entry>
  
  <entry>
    <title>Grain 与 Noise</title>
    <link href="http://yoursite.com/2020/04/26/grain-and-noise/"/>
    <id>http://yoursite.com/2020/04/26/grain-and-noise/</id>
    <published>2020-04-26T12:16:10.000Z</published>
    <updated>2020-04-26T12:16:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文翻译自 <a href="https://blog.kageru.moe/legacy/grain.html">Grain and Noise</a>，原作者：<a href="https://github.com/kageru">kageru</a>。</p><h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>在数字图像处理中存在多种噪声（noise）和瑕疵（artifacts），同时也有多种降噪算法。在本文中，有时将 grain 与 noise 作为同义词使用；通常而言，noise 是一种不符合预期的瑕疵，而 grain 则是为了实现某种特效——如回忆特效、模仿胶片电影颗粒感而添加，或为掩盖色带（banding）而添加。</p><p>Grain 增加了画面混乱程度，是熵增的过程，在视频编码时会导致比特率增加，特别是对于用来掩盖色带的噪点。这种比特率的增加并不能提升编码质量（梯度除外，这个问题我们会在后续讨论）。</p><p>Grain 并非都是坏的，对于消除或减弱色带而言甚至是必要的，但工业化制作时通常会使用动态 grain，这会极大地占用比特率。与此形成对比的是，采用 10bit 编码时，色带的问题并不明显，而且诸如静态 grain （如 f3kdb 的 grain）同样能实现良好的去色带效果。</p><p>有些人为获得干净的画面，喜欢降噪处理（denoise &#x2F; degrain），仁者见仁智者见智。</p><span id="more"></span><h3 id="不同类型的-grain-与-noise"><a href="#不同类型的-grain-与-noise" class="headerlink" title="不同类型的 grain 与 noise"></a>不同类型的 grain 与 noise</h3><h4 id="1-回忆特效（Flashbacks）"><a href="#1-回忆特效（Flashbacks）" class="headerlink" title="1.回忆特效（Flashbacks）"></a>1.回忆特效（Flashbacks）</h4><h4 id="2-静态胶片颗粒（Constant-film-grain）"><a href="#2-静态胶片颗粒（Constant-film-grain）" class="headerlink" title="2.静态胶片颗粒（Constant film grain）"></a>2.静态胶片颗粒（Constant film grain）</h4><h4 id="3-背景噪点（Background-grain）"><a href="#3-背景噪点（Background-grain）" class="headerlink" title="3.背景噪点（Background grain）"></a>3.背景噪点（Background grain）</h4><h4 id="4-TV-横纹（TV-grain）"><a href="#4-TV-横纹（TV-grain）" class="headerlink" title="4.TV 横纹（TV grain）"></a>4.TV 横纹（TV grain）</h4><h4 id="5-其他特效噪点（Exceptional-grain）"><a href="#5-其他特效噪点（Exceptional-grain）" class="headerlink" title="5.其他特效噪点（Exceptional grain）"></a>5.其他特效噪点（Exceptional grain）</h4><h3 id="不同的降噪方法"><a href="#不同的降噪方法" class="headerlink" title="不同的降噪方法"></a>不同的降噪方法</h3><h4 id="1-基于傅里叶变换的频域降噪（如-dfttest、FFT3D）"><a href="#1-基于傅里叶变换的频域降噪（如-dfttest、FFT3D）" class="headerlink" title="1.基于傅里叶变换的频域降噪（如 dfttest、FFT3D）"></a>1.基于傅里叶变换的频域降噪（如 dfttest、FFT3D）</h4><p>dfftest 是一个较旧的滤镜，自 2007 年起开始开发，是一个很有效的滤镜，具有良好的细节保留能力，但会大幅降低速度，特别是在缺乏多线程支持的 AviSynth 下。VapourSynth 接口的 dfftest 速度更快，且有相同的效果。</p><p>FFT3DGPU 具有硬件加速功能，同样使用了频域降噪算法，速度更快，但细节保留方面精度较低，同时可能更容易导致模糊，可以通过反差补偿锐化来修补。该滤镜提供了 AviSynth 和 VapourSynth 接口，二者没有太大区别。</p><p>关键参数为<code>sigma</code>。</p><h4 id="2-非局部均值降噪（如-KNLmeans、TNLmeans）"><a href="#2-非局部均值降噪（如-KNLmeans、TNLmeans）" class="headerlink" title="2.非局部均值降噪（如 KNLmeans、TNLmeans）"></a>2.非局部均值降噪（如 KNLmeans、TNLmeans）</h4><p>非局部均值（non-local means）降噪由一系列 solid 降噪方法组成。KNLmeans 降噪滤镜基于 OpenCL 对 GPU 运算进行了高度优化，对整体图像处理速度无显著影响，这一点非常吸引人。在较旧的 AviSynth 视频处理框架下，与FFT3DGPU类似，使用GPU版 KNLmeans 还可以绕开 AviSynth 的单线程限制。因此除非无 GPU 设备，否则没有理由使用 CPU 版本（译者注：由于 KNLmeans 基于 OpenCL 进行 GPU 优化，所以在 NVIDIA、AMD、Intel 三家平台通用，很难遇上无 GPU 可用的情况，但在某些 GPU 设备上 KNLmeans 可能因 Bug 而无法使用，这时候才需要考虑 CPU 版本的 TNLmeans）。</p><p>KNLmeans 可以消除相当一部分（a lot of） noise，同时保留很多（a lot of）细节（尽管少于 dft 或 BM3D）。对于历史较久远的动画，推荐使用这一滤镜，因为这些动画往往存在很多 grain（通常是在蓝光重制时添加），但细节并不丰富。这种情况下，适合使用具有硬件加速且降噪力度大的滤镜，比起 FFT3D，KNLmeans 更加合适 。</p><p>需要注意这一滤镜的时-空混合模式（Spatio-Temporal mode），在默认设置下，AviSynth 和 VapourSynth 版本的 KNLmeans 均不使用时间参考帧，当参数<code>d</code>大于 0 时，在降噪中启用时间参考帧，开启时间参考帧可以改善质量。对于 YUV444 采样格式的视频，请将<code>cmode</code>参数设置为<code>True</code>，以开启色度平面降噪，因为在默认设置下仅对亮度平面进行处理。</p><p>上述两个参数的设置均会降低速度，但除非使用古老的 GPU 或者同时使用多个 GPU 优化的滤镜，否则不会对编码速度产生明显影响，控速步仍为 CPU 的编码过程。KNLmeans 的文档在<a href="https://github.com/Khanattila/KNLMeansCL/wiki">这里</a>。</p><h4 id="3-三维块匹配算法（BM3D）"><a href="#3-三维块匹配算法（BM3D）" class="headerlink" title="3.三维块匹配算法（BM3D）"></a>3.三维块匹配算法（BM3D）</h4><p>BM3D 很有价值，也很慢，仅有 VapourSynth 接口。在 AviSynth 上运行可能会导致崩溃，除非大幅优化内存占用，否则很难实现 AviSynth 接口。</p><p>BM3D可以并行化并在 GPU 上运行（可参考此处的<a href="https://books.google.com/books?id=xqfNBQAAQBAJ&pg=PA380&lpg=PA380&dq=bm3d+GPU+parallel&source=bl&ots=MS9-Kzi-8u&sig=fMcblGOrD-wCUrZzijmAdQF2Tj8&hl=en&sa=X&ei=wljeVI-LKcqAywPVyILgDQ&ved=0CDQQ6AEwBA#v=onepage&q=bm3d%20GPU%20parallel&f=false">文献</a>，译者注：BM3D 已经有诸多 GPU 版本，可以在 Github 等地方搜索到），但 AviSynth 或 VapourSynth 尚无 GPU 实现。</p><p>BM3D 实现了模糊程度与体积的最佳平衡（因此也导致了细节损失），但在基于 CPU 的降噪滤镜中，BM3D 是速度最慢的。</p><p>值得注意的是，BM3D 滤镜有一个<code>ref</code>参数，用以设定降噪时的参考视频，可以将<code>ref</code>设定为其他降噪滤镜的处理结果，从而实现 BM3D 与其他降噪滤镜的协同处理。在 BM3D <a href="https://github.com/HomeOfVapourSynthEvolution/VapourSynth-BM3D">文档</a>中有如下举例：</p><blockquote><p>使用自定义降噪滤镜作为基础降噪结果，并使用V-BM3D的最终降噪函数做精细化处理</p><p>这样做可以在两种降噪滤镜间取长补短。在下面的例子中，SMDegrain滤镜在时空平滑上很有效，但可能导致鬼影（blending）和细节损失，V-BM3D可以很好地保留细节，但对于大的噪声pattern（例如粗颗粒）效果不好</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">src = core.bm3d.RGB2OPP(src)<br>ref = haf.SMDegrain(src)<br>flt = core.bm3d.VFinal(src, ref, radius=<span class="hljs-number">1</span>, matrix=<span class="hljs-number">100</span>).bm3d.VAggregate(radius=<span class="hljs-number">1</span>)<br>flt = core.bm3d.OPP2RGB(flt)<br></code></pre></td></tr></table></figure></blockquote><p>最关键的参数为<code>sigam</code>，可以为不同平面设定不同的数值。</p><h4 id="4-SMDegrain"><a href="#4-SMDegrain" class="headerlink" title="4.SMDegrain"></a>4.SMDegrain</h4><p>SMDegrain 似乎是很多人降噪的首选，因为它不会导致过多的模糊，而且降噪效果似乎弱到对图像没有明显影响，不会明显改变文件体积。</p><p>较弱的降噪效果也能使（因降噪而暴露的）色带更少，这在希望保留细节而不太考虑比特率的情况下很有用。</p><p>与此同时，即使不在降噪后进行反差补偿锐化，SMDegrain 似乎也可以对某些边缘起到收线&#x2F;细化线条的效果。</p><p>需要注意的是，SMDegrain 在处理色度平面时可能会带来副作用，AviSynth Wiki 描述如下：</p><blockquote><p>注意在<code>plane=1-4</code>时色度平面可能会产生色度鬼影，这种情况下建议在空域中处理色度平面。</p></blockquote><p>事实上，这可以通过将多个帧模糊为单个帧进行修补。</p><h4 id="5-基于卷积神经网络的-Waifu2x"><a href="#5-基于卷积神经网络的-Waifu2x" class="headerlink" title="5.基于卷积神经网络的 Waifu2x"></a>5.基于卷积神经网络的 Waifu2x</h4><p>Waifu2x 使用深度卷积神经网络进行超分辨率与降噪，听上去很棒但需要大量算力。在图形处理器上使用 Waifu2x 对 720p 视频进行降噪，其速度可能低于 1fps（译者注：Waifu2x 进行了更新，见下文的<strong>Edit</strong>）。降噪有三种级别可供选择，2 级和 3 级降噪难以保留细节，无法使用，1 级降噪可以恰当地去除 grain，但细节的保留程度可能与输入源关系很大，且无法调节。因此在使用中，要么接受 Waifu2x 单一模式的降噪结果（而且这还可能是最慢的算法），要么换用其他降噪滤镜（译者注：Waifu2x 进行了更新，见下文的<strong>Edit</strong>）。</p><p>基于深度神经网络的算法还有很多（如<a href="https://www.researchgate.net/publication/300688682_Deep_Gaussian_Conditional_Random_Field_Network_A_Model-Based_Deep_Network_for_Discriminative_Denoising">文献</a>），但多数未公开算法。</p><p>对于动画风格的图像使用 Waifu2x 进行降噪没有问题，但对于真实图像，其纹理可能被识别为噪点，进而被破坏。</p><p><strong>Edit</strong>：在写完本节后，Waifu2x 进行了重大升级，速度进一步提升，并且在降噪功能上提供了更多选项。</p><h4 id="6-去色带（Debanding）"><a href="#6-去色带（Debanding）" class="headerlink" title="6.去色带（Debanding）"></a>6.去色带（Debanding）</h4><p>部分降噪算法在体积控制&#x2F;压缩率方面效果明显，但它们都有一个共同的问题，色带。为解决这个问题，我们需要进行进行去色带，并将颗粒施加到画面颜色渐变的部分。这听上去可能反直觉，因为我们刚刚花费了大量的时间来去除颗粒，我们接下来会谈论这个问题。</p><p>（原文中有图片）在使用 BM3D 降噪后，使用 f3kdb 进行去色带，并且使用合适的 mask 保护图中的纹理。</p><h3 id="Grain-编码"><a href="#Grain-编码" class="headerlink" title="Grain 编码"></a>Grain 编码</h3>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文翻译自 &lt;a href=&quot;https://blog.kageru.moe/legacy/grain.html&quot;&gt;Grain and Noise&lt;/a&gt;，原作者：&lt;a href=&quot;https://github.com/kageru&quot;&gt;kageru&lt;/a&gt;。&lt;/p&gt;
&lt;h3 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h3&gt;&lt;p&gt;在数字图像处理中存在多种噪声（noise）和瑕疵（artifacts），同时也有多种降噪算法。在本文中，有时将 grain 与 noise 作为同义词使用；通常而言，noise 是一种不符合预期的瑕疵，而 grain 则是为了实现某种特效——如回忆特效、模仿胶片电影颗粒感而添加，或为掩盖色带（banding）而添加。&lt;/p&gt;
&lt;p&gt;Grain 增加了画面混乱程度，是熵增的过程，在视频编码时会导致比特率增加，特别是对于用来掩盖色带的噪点。这种比特率的增加并不能提升编码质量（梯度除外，这个问题我们会在后续讨论）。&lt;/p&gt;
&lt;p&gt;Grain 并非都是坏的，对于消除或减弱色带而言甚至是必要的，但工业化制作时通常会使用动态 grain，这会极大地占用比特率。与此形成对比的是，采用 10bit 编码时，色带的问题并不明显，而且诸如静态 grain （如 f3kdb 的 grain）同样能实现良好的去色带效果。&lt;/p&gt;
&lt;p&gt;有些人为获得干净的画面，喜欢降噪处理（denoise &amp;#x2F; degrain），仁者见仁智者见智。&lt;/p&gt;</summary>
    
    
    
    <category term="图像处理" scheme="http://yoursite.com/categories/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    
    
    <category term="VapourSynth" scheme="http://yoursite.com/tags/VapourSynth/"/>
    
    <category term="Avisynth" scheme="http://yoursite.com/tags/Avisynth/"/>
    
  </entry>
  
</feed>
