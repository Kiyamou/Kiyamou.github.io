<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>308实验室</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2021-03-28T03:44:25.773Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Kiyamou</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>2020 年终总结：只一眼，梵音也渐远</title>
    <link href="http://yoursite.com/2021/01/12/2020-summary/"/>
    <id>http://yoursite.com/2021/01/12/2020-summary/</id>
    <published>2021-01-12T03:37:25.000Z</published>
    <updated>2021-03-28T03:44:25.773Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>若非那年 总角放纸鸢</p><p>风中断线 恣意翩跹</p><p>空旷禅院 独落你脚边</p><p>只一眼 梵音也渐远</p></blockquote><p>因为疫情，回望2020年，显得尤为短暂。仿佛前两天还是2020年寒假前坐在屏幕前敲代码的时光，现在却是另一番光景。</p><a id="more"></a><h3 id="工作与学习"><a href="#工作与学习" class="headerlink" title="工作与学习"></a>工作与学习</h3><p>10月底的时候，和P见了一面，把我暑假以及9月的经历和P简单说了一下。P说，“你胆子还真大”。也确实是这样，面试的时候没有太多感觉，但结束之后回想，些许有股不知天高地厚的样子。</p><p>由此前推，我在面试时说得最多的，或者说面试官最感兴趣的，还是我4月份之后以及6月回到学校期间做的东西。这也让我感受到一个朴素的道理，前行的路、积累的过程，并不是线性的。如果走到一半或者快到尽头时放弃，得到的往往不是50%或者85%，而很可能只有10%。</p><p>而回望这一年的学习和工作，最深的感受就是，心态和环境真的影响很大。新年刚过，起步阶段，状态很好；刚回家时，换了新环境，效率也很高；然后就开始了情绪波动，状态萎靡，不过幸好坚持做了去雾的项目，萎靡中的坚持同样重要，甚至更可贵，这才是告别”在感叹时光流失中让时光再次流失”的方法；回到学校，又是经历从高效到颓废的变化，后期有相当一段时间都在打游戏。好在最后能找回状态。</p><p>在2020的最后一天，和同组的老师同学畅谈了过去的经历，当我能平淡甚至面带笑容说出过去不愿回想的经历，我应该算是从过去走出了吧。在11月、12月的时候，我对我自己说，让自己得到救赎，大概就是如此。</p><h3 id="之前的路"><a href="#之前的路" class="headerlink" title="之前的路"></a>之前的路</h3><p>疫情期间，闷在家里，每天刷手机刷网络。先是在知乎上看到了一位当年吧友，之后便心血来潮翻过去的帖子，再后便是偶然搜到了龙崎和余哥的主页，得知了他们的近况。原来他们一直都没有离开，只是换了一种方式存在。那时候我受了很大的…心理波动吧，“感觉命运给我开了一个玩笑”。就像我在年末和同组同学说的那样，大家都当真了，只有我在开玩笑。能够为自己做选择，能够去追逐热爱的事情，这是一件多么好的事情啊。就像《四月》里说的那样，“喜欢和不讨厌之间，可是隔了数亿光年都不止的距离”。</p><p>疫情给我上网方式带来的另一个变化，是让我回归了传统的论坛和bbs的交流方式。时不时会在论坛上看到一些感叹个人生活的帖子，无论他们的年龄比我小还是大，大部分时候我都会感觉，我自己已经能够不再为类似的事情感慨了，这大概就是我长大了吧。</p><p>在Github上交流，这对我是一个全新的体验，感觉很愉快。而在现实中，或者是在带有现实的微信中，也尝试了和陌生人去交流，那种破冰的感觉，也很久不曾体验了。</p><h3 id="生活、做饭"><a href="#生活、做饭" class="headerlink" title="生活、做饭"></a>生活、做饭</h3><p>疫情的又一个影响，我开始做饭了。从煮挂面开始，到煮菜煮鸡胸肉，再到炒菜烩菜。看了那么多烹饪视频，终于有了行动，而小时候常常幻想的做饭场景也终于成为了现实。</p><p>开始真正的做饭，应该说正是疫情闷在家里快闷坏了的阶段。做一顿饭，确实是生活中很好的调剂。</p><p>到了5月，疫情渐渐消退，我也终于挪出了家门，经常性地出门走走。虽然通常只是买杯咖啡带回家，但也足够呼吸新鲜空气了。虽然家在县城，但比村里的学校还是方便多了，走不远就是肯德基和麦当劳。话说肯德基的大神卡买咖啡真的很划算，肯德基的咖啡也不比星巴克差，至少我喝不出来。</p><p>回到学校之后，尝试了多种咖啡，从速溶黑咖啡到手冲。第一次泡手冲，推开宿舍门，真是满屋的香气。后来了解了一些咖啡知识，知道了星巴克等咖啡馆，拿铁也是要加奶泡的，而奶泡是用商业级设备打出来的，家里面很难复现。所以我终于明白了，为什么自己兑的咖啡牛奶、肯德基的拿铁，和星巴克的味道总是不一样了。但回到主题，我用手冲泡出来的咖啡，和星巴克的美式，喝不出区别。原来3块钱也能做到30块钱的效果。</p><h3 id="结语以及之后"><a href="#结语以及之后" class="headerlink" title="结语以及之后"></a>结语以及之后</h3><p>有的时候会感觉，想努力却没有平台。所谓“比你优秀的比你还努力”，问题并不一定出在思想和自制力上，而是由于不知道怎么跳出无效的努力，或者找不到有效的平台。相反地，当我找到属于我的铁轨之后，并不是工作结束了，而是我能给我自己提供一个方向。所谓“成长的烦恼”、已经OK了为什么还要继续，可以批判地看待这些话，但不得不说反映了客观的道理。</p><p>大概这就是2020年了。写年终总结的时候，因为有些事情过去的比较久了，记不太清了，年终总结往往会变成季度总结+新一年的flag。但还是要尽量避免。我希望这一年能沉淀下一些东西，而不是把近期还未成熟的感受强化。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;若非那年 总角放纸鸢&lt;/p&gt;
&lt;p&gt;风中断线 恣意翩跹&lt;/p&gt;
&lt;p&gt;空旷禅院 独落你脚边&lt;/p&gt;
&lt;p&gt;只一眼 梵音也渐远&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;因为疫情，回望2020年，显得尤为短暂。仿佛前两天还是2020年寒假前坐在屏幕前敲代码的时光，现在却是另一番光景。&lt;/p&gt;
    
    </summary>
    
    
      <category term="日记" scheme="http://yoursite.com/categories/%E6%97%A5%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>2020 年中书单/影评：在终止彷徨，在结束动荡</title>
    <link href="http://yoursite.com/2020/07/28/2020-mid-books/"/>
    <id>http://yoursite.com/2020/07/28/2020-mid-books/</id>
    <published>2020-07-27T18:32:18.000Z</published>
    <updated>2020-07-27T18:33:43.243Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>你在终止彷徨  你在结束动荡</p><p>你成为垂衣驭八荒的王</p><p>你低下头与我相望  将金色徽章戴在我肩膀</p><p>你眼中分明蛰藏  锁死我危险却迷人的欲望</p><p>——《国境四方》</p></blockquote><p>开了一个新系列，记载 2019 年下半年至 2020 年上半年读过的书和看过的视频。</p><a id="more"></a><h3 id="技术类书籍"><a href="#技术类书籍" class="headerlink" title="技术类书籍"></a>技术类书籍</h3><h4 id="1-《深入理解-C-指针》"><a href="#1-《深入理解-C-指针》" class="headerlink" title="1.《深入理解 C 指针》"></a>1.《深入理解 C 指针》</h4><p>推荐指数：★ ★ ★ ★ ★</p><p>这段时间以来看的书，首推这本《深入理解 C 指针》。这是一本超越了字典/百科全书式的各类 C/C++ 教程的专项书籍，是进阶的开端书籍。看这本书大概是在 2019 年 12 月，当时正在写 JincResize 和 AreaResize，刚接触图像处理中双重 for 循环遍历元素与指针移动的过程，看这本书让我迅速理解了上述内容。</p><h4 id="2-《现代-C-教程：高速上手-C-11-14-17-20》"><a href="#2-《现代-C-教程：高速上手-C-11-14-17-20》" class="headerlink" title="2.《现代 C++ 教程：高速上手 C++11/14/17/20》"></a>2.《现代 C++ 教程：高速上手 C++11/14/17/20》</h4><p>推荐指数：★ ★ ★ ★ ★</p><p>龙崎哥写的开源书籍， Github 仓库在<a href="https://github.com/changkun/modern-cpp-tutorial" target="_blank" rel="noopener">这里</a>。</p><p>龙崎哥是真的厉害，我只记得当年在数吧里看到他提了一下，说在学 C++。没想到写出了这么棒的书。</p><p>我主要是 2020 年 2 月 ~ 3 月在看这本书，没有太注意 C++ 20 的内容（毕竟在不断更新中）。如龙崎哥所言，这本书由于各章节独立，适合零碎的阅读、查阅。我主要看了智能指针部分，其次是一些相对零碎的新特性，而多线程部分虽然看了…但没看太懂。</p><p>会感慨固然人生路远，但能遇见的人就这么多，当年仰慕的人并没有消失，只是换了一种方式存在。题记中引用了一首歌，《国境四方》，我想表达的便是这个含义。</p><h4 id="3-《OpenCV-3-编程入门》"><a href="#3-《OpenCV-3-编程入门》" class="headerlink" title="3.《OpenCV 3 编程入门》"></a>3.《OpenCV 3 编程入门》</h4><p>推荐指数：★ ★ ★ ★ ★（新手视角）| ★ ★ ★ ★ ☆（一般视角）</p><p>适合新手阅读的一本书，书的内容包括如下几个部分：1.编程扫盲部分，讲了变量命名规则与习惯、C/C++ 的一些常识；2. OpenCV 3 入门部分，讲了 OpenCV 3 的一些设计思路和数据结构；3.逐条讲解主要函数，同时讲了一些图像处理的基础理论。在 2019 年 11月 ~ 2020 年 2 月看了这本书，不得不说让懵懂的我学了很多，但站在一般向的视角上，内容略显简单（当然，对于封装这么成熟的 OpenCV，把书写复杂可能既不容易也没必要）。</p><h4 id="4-《21-天学通-C-》"><a href="#4-《21-天学通-C-》" class="headerlink" title="4.《21 天学通 C++》"></a>4.《21 天学通 C++》</h4><p>推荐指数：★ ★ ★ ★ ☆</p><p>没什么好说的，这是我用来当手册/字典的书籍，大概可以分为三部分：C/C++ 通用语法、C++ 特性语法、STL 库。这本书我好像没有在博文中看到过有人推荐，接触这本书因为《21 天实战 Caffe》，后者的作者说他就是在《21 天学通 C++》启发下写了《21 天实战 Caffe》。</p><p>但有一说一，《21 天实战 Caffe》真的是分了 21 个章节，而《21 天学通 C++》…除了书名之外，好像没看到和 21 相关的东西 Orz…</p><h4 id="5-《C-C-常用算法手册》"><a href="#5-《C-C-常用算法手册》" class="headerlink" title="5.《C/C++ 常用算法手册》"></a>5.《C/C++ 常用算法手册》</h4><p>推荐指数：★ ★ ★ ☆</p><p>很基础的书籍，讲了常见的数据结构和基础的算法，适合新手，也是我在浮躁状态下难得读得进去的书。但平心而论，书的内容本身并谈不上有多好，代码风格陈旧且不说，前后代码重复让人感觉有点冗杂。</p><h3 id="文学类书籍"><a href="#文学类书籍" class="headerlink" title="文学类书籍"></a>文学类书籍</h3><h4 id="1-《文在寅自传：命运》"><a href="#1-《文在寅自传：命运》" class="headerlink" title="1.《文在寅自传：命运》"></a>1.《文在寅自传：命运》</h4><p>本来不想提到这本书的，因为避免谈政治。只是书的一句话印象太深刻了，“愿为江水，与君同行”。</p><h4 id="2-《透过机器人与你相恋》"><a href="#2-《透过机器人与你相恋》" class="headerlink" title="2.《透过机器人与你相恋》"></a>2.《透过机器人与你相恋》</h4><p>轻小说。接触这本书是因为插画师 loundraw。早前在 P 站看到 loundraw 的一幅画，还用来当了一段时间的台式机壁纸。没想到这幅画同样是《透过机器人与你相恋》的封面图，于是就把小说买来看了。目前只看了开头，还没有看到故事的核心。</p><h3 id="网课"><a href="#网课" class="headerlink" title="网课"></a>网课</h3><p>点开看过的网课有以下几个。</p><p><strong>1.某培训班的通用 C++ 网课</strong></p><p><strong>2.国防科大《编译原理》</strong></p><p><strong>3.郝斌《数据结构》</strong></p><p><strong>4.北理工 2020 冬季 ACM 培训</strong></p><p><strong>5.某编程算法教程</strong></p><p>这几个网课收获都不小。应该说第一个 C++ 网课没什么特色，但对于新手还是友好的。第二个编译原理网课虽然只是浅看，但很受启发，确实有种“学了编译原理你就明白了的感觉”。重点看的是第三、四个，数据结构的入门和 STL 库的讲解（众所周知，ACM 用的 C++ = C + STL）。最后一个是付费购买的，面向面试的教程，物有所值。</p><h3 id="影视"><a href="#影视" class="headerlink" title="影视"></a>影视</h3><h4 id="1-《樱花庄的宠物女孩》"><a href="#1-《樱花庄的宠物女孩》" class="headerlink" title="1.《樱花庄的宠物女孩》"></a>1.《樱花庄的宠物女孩》</h4><p>2019 年下半年开了三部番，《冰菓》、《境界的彼方》、《樱花庄》，前两者没有弃但到现在都没看完，《樱花庄的宠物女孩》是日常向，所以看得进度快。这三部番陪着我走过了 2019 年 9 月到 12 月，从轻松到迷茫再到找到方向。</p><p>《樱花庄》里的生活确实让人羡慕，但或许因为我不是天才吧，若客观地分析人物塑造，还是有些贴标签的感觉。剧中的人物塑造方式，对于龙哥这样的配角而言，没什么问题，感觉不到贴标签，简略描写增加的神秘感反而更适合龙哥。三鹰学长学姐倒也没什么问题，一开始贴上两个人都能力超群的标签，但进一步的剧情展开则说明，看似无所不能的学长，专业技能反倒逊色于嘻嘻哈哈的学姐，这提供了戏剧冲突，也让人物形象丰满了一些，对于配角也可以了。但说到主角真白，仍把塑造配角的方式拿来用，就感觉有些僵硬。</p><p>不过嘛，《樱花庄》毕竟是在日常基础上深入的，看的时候让人开心和感动就足够了。</p><h4 id="2-《狼与香辛料》第一季"><a href="#2-《狼与香辛料》第一季" class="headerlink" title="2.《狼与香辛料》第一季"></a>2.《狼与香辛料》第一季</h4><p>同样是在 2019 年下半年看的，没和上面三部番写到一起，是觉得风格不太一样。这部番被调侃为“夫妻行骗记”，但我更喜欢另一个评价，这部番是把女性作为独立个体的番剧。且不和一众后宫番比较，就是和非后宫普通番剧乃至没什么男性的百合番相比，能把女性独立人格塑造出来，除了《狼与香辛料》，我看过的番中只有柯南剧场版《战栗的乐谱》。</p><h4 id="3-《非自然死亡》"><a href="#3-《非自然死亡》" class="headerlink" title="3.《非自然死亡》"></a>3.《非自然死亡》</h4><p>好剧，不需要多说。特别是在新冠疫情的背景下，第一集甚至有了代入感。每一集的片尾曲《Lemon》都是神插入。看《境界的彼方》时，弹幕经常说 OP 神插入，但我倒没有明显感觉。片中时不时出现的名台词，可以当壁纸的石原里美的名场景，更让人印象深刻。而六郎对人生的思考，也让当时迷茫的我有了共鸣。</p><p>在主要剧情之外，看这部剧时不时会跳戏，且不说作为所长的<del>五郎</del>（欸，所长名字是啥来着？），光是里面的名字就让人跳戏，美琴、想见美琴的白井同学、神经大条的毛利警官。</p><p>喜欢 B 站的一条评论，看这部剧还能因为 cp 掐起来，应该把脑子泡在福尔马林里。</p><h4 id="4-《理科生坠入情网，故尝试证明。》"><a href="#4-《理科生坠入情网，故尝试证明。》" class="headerlink" title="4.《理科生坠入情网，故尝试证明。》"></a>4.《理科生坠入情网，故尝试证明。》</h4><p>应该是这一年追的唯一一部新番，也不能叫追，因为不知道是网飞还是亚马逊加持，一次性更完 12 集。虽然还是让人感觉有些夸张，就是这类番剧中常见的过分夸张数理知识的感觉。但一些细节还是有意思的，真的很佩服在 Ubuntu 下玩 galgame 的师弟，不知是创作者是真在 Linux 下玩过 galgame，还是只是单纯营造人设。</p><h4 id="5-《无法成为野兽的我们》"><a href="#5-《无法成为野兽的我们》" class="headerlink" title="5.《无法成为野兽的我们》"></a>5.《无法成为野兽的我们》</h4><p>冲着新垣结衣去看的，但可能是我还没有步入职场吧，感触一般。</p><h4 id="6-《轻音少女》第一季"><a href="#6-《轻音少女》第一季" class="headerlink" title="6.《轻音少女》第一季"></a>6.《轻音少女》第一季</h4><p>治愈的日常番。</p><h4 id="7-《Fate-stay-night-Heaven’s-Feel-II-lost-butterfly》"><a href="#7-《Fate-stay-night-Heaven’s-Feel-II-lost-butterfly》" class="headerlink" title="7.《Fate/stay night [Heaven’s Feel] II.lost butterfly》"></a>7.《Fate/stay night [Heaven’s Feel] II.lost butterfly》</h4><p>在 2019 年 7 月还是 8 月，和 G 和 H 去电影院看的。因为在七八月份，就写了进来，其实从心境上看，应该归到上半年。电影院里的感受自然和十几寸二十几寸的屏幕不一样，特别是对于 Fate 这种大制作的番剧。樱真的惹人喜欢。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;你在终止彷徨  你在结束动荡&lt;/p&gt;
&lt;p&gt;你成为垂衣驭八荒的王&lt;/p&gt;
&lt;p&gt;你低下头与我相望  将金色徽章戴在我肩膀&lt;/p&gt;
&lt;p&gt;你眼中分明蛰藏  锁死我危险却迷人的欲望&lt;/p&gt;
&lt;p&gt;——《国境四方》&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;开了一个新系列，记载 2019 年下半年至 2020 年上半年读过的书和看过的视频。&lt;/p&gt;
    
    </summary>
    
    
      <category term="日记" scheme="http://yoursite.com/categories/%E6%97%A5%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>DehazingCE：基于对比度增强的去雾算法及 VapourSynth 迁移</title>
    <link href="http://yoursite.com/2020/06/26/dehazingce-port/"/>
    <id>http://yoursite.com/2020/06/26/dehazingce-port/</id>
    <published>2020-06-25T16:42:53.000Z</published>
    <updated>2020-07-24T15:37:16.531Z</updated>
    
    <content type="html"><![CDATA[<p>这一去雾算法在2013年提出，论文见 <a href="http://mcl.korea.ac.kr/projects/dehazing/#userconsent#" target="_blank" rel="noopener">Optimized contrast enhancement for real-time image and video dehazing</a>，我们称其为 DehazingCE （CE = contrast enhancement）。</p><h3 id="算法概述"><a href="#算法概述" class="headerlink" title="算法概述"></a>算法概述</h3><p>DehazingCE 基于大气散射模型，分别估计大气光强度和透射率，得到去雾结果。</p><a id="more"></a><p>大气光估计通过图像分块、寻找像素差异最小的子块，以该子块最亮的点作为大气光的估计值。但这里存在一个问题，不知道是我理解有问题，还是我代码迁移有问题，或者算法本身就有问题。如果图像整体偏暗，那寻找到的子块就会很暗，最后以一个像素值很小的点作为大气光估计值，用这个值继续计算，最终结果就是全黑。我对迁移到 VapourSynth 的代码进行测试，确实发现了这一问题。</p><p>透射率估计分为粗算和细化两步。粗算是基于大气散射模型进行次数不多的迭代，并自定义像素损失值（大气散射模型的直接计算结果可能会超过 [0, peak]，导致像素越界）以决定是否继续迭代。细化通过导向滤波实现。</p><p>后处理包括 Gamma 亮度调整和类似均值滤波的均值化计算。前者是避免去雾后图像过暗，后者是避免透射率过低时导致的块效应。在我迁移的代码中，Gamma 亮度调整表现不错，但均值化计算可能是我的代码还有问题，测试结果是不如不做，做了反而凭空多了瑕疵。</p><h3 id="代码迁移"><a href="#代码迁移" class="headerlink" title="代码迁移"></a>代码迁移</h3><p>代码迁移着实花了很久，满打满算从 4 月份开始读原始代码，到 6 月份完成初版的迁移，几乎花了两个月…原始代码风格很古典，着实有点费力。</p><h4 id="从-OpenCV-2-到-OpenCV-3"><a href="#从-OpenCV-2-到-OpenCV-3" class="headerlink" title="从 OpenCV 2 到 OpenCV 3"></a>从 OpenCV 2 到 OpenCV 3</h4><p>在最开始，我觉得一下子迁移到 VapourSynth 有点费力，便想尝试着把原始代码先跑起来。原始代码基于 OpenCV 2，存储图像还是用的 IplImage 指针而非 Mat 类。这一部分工作在<a href="https://kiyamou.github.io/2020/04/28/dehazing/" target="_blank" rel="noopener">前面的博文</a>有提到。但折腾好久，也没把原始代码跑起来，最后放弃了，直接迁移。</p><h4 id="YUV-还是-RGB"><a href="#YUV-还是-RGB" class="headerlink" title="YUV 还是 RGB"></a>YUV 还是 RGB</h4><p>在着手迁移之初，是先支持 YUV 还是先支持 RGB 纠结了好久。其中一部分原因是我还没完全搞懂原始代码的处理流程，从大气光估计部分看，原始代码用的是 RGB 格式，从透射率估计看，原始代码既有只算灰度的（这像是面向 YUV），又有 RGB 三个通道都计算的。最后决定先支持 RGB（因为我先读明白了原始代码的大气光估计部分，沿用了这一部分的 RGB 格式）。</p><h4 id="数据结构的转换与基础操作的迁移"><a href="#数据结构的转换与基础操作的迁移" class="headerlink" title="数据结构的转换与基础操作的迁移"></a>数据结构的转换与基础操作的迁移</h4><p>确定 RGB 后便开始转换图像数据结构，为减少工作量，尽量不去动原始代码的函数输入输出模式，把 VapourSynth 接口传递过来的图像指针转化为普通指针，送给核心计算函数。在这个过程中，我越来越感觉到 VapourSynth 接口的概念，或者什么叫接口。我渐渐懂得把核心处理剥离开，不再依赖 VapourSynth API 提供的数据类型，而是使用普通指针和数组完成核心计算，在把结果送给 VapourSynth API。</p><p>在计算过程中需要进行图像分块、计算图像像素值均值和标准差。在原始代码中，这些操作都是使用的 OpenCV 函数。对于这些并不复杂的操作，我自然不能接受调用第三方库来实现。图像分块最开始是用两层 for 循环赋值，后来才想到用<code>memcpy()</code>函数直接拷贝。计算均值和标准差直接 copy 了一份代码。</p><p>完成上述操作后，迁移过程就没什么困难的了，写个集成函数去调用各步计算即可。</p><h4 id="VapourSynth-API-的一些事情"><a href="#VapourSynth-API-的一些事情" class="headerlink" title="VapourSynth API 的一些事情"></a>VapourSynth API 的一些事情</h4><p>虽说已经没有大的困难，但具体细节上还是要花时间的。我之前没有写过 ref 参考片段，之前也不知道 VapourSynth 接口没有提供 bool 类型。好在有前辈们写成的其他滤镜，有很多可以参考（copy）的代码。</p><h3 id="Debug"><a href="#Debug" class="headerlink" title="Debug"></a>Debug</h3><h4 id="指针读取冲突"><a href="#指针读取冲突" class="headerlink" title="指针读取冲突"></a>指针读取冲突</h4><p> 读取位置 … 时发生访问冲突。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">srcInterleaved[pos] = srcpB[x];<br>srcInterleaved[pos + <span class="hljs-number">1</span>] = srcpG[x];<br></code></pre></td></tr></table></figure><p>这里就出问题是我没有想到的，因为这部分代码之前在AreaResize中已经用过了，没有问题。</p><p>回到报错本身，“发生访问冲突”表明指针访问内存时出问题了，指针指向了不属于自己的内存地址，是一个基础的问题。</p><p>发现在vs接口部分忘记释放ref，释放之后同样报访问冲突，但这次的报错位置是大气光估计函数的图像分块位置，这才是意料之中（这部分代码最开始写的时候就迷迷糊糊的）。</p><p>但另一个引发该错误的原因就很蠢了，假如读入的不是 RGB 格式，而是 YUV 格式，也会引发该错误。这是自然的，YUV 的第二、三个通道的宽高分别是第一个通道的一半，自然会越界。</p><h3 id="构建与C-语法"><a href="#构建与C-语法" class="headerlink" title="构建与C++语法"></a>构建与C++语法</h3><p>从这次开始我使用了 cmake 进行构建，一开始都是一些技术问题，直到部署 CI 的时候，才通过 cmake 意识到一些 C++ 语法的问题，一些我在很早的时候就看到过但没有读懂的问题。</p><h4 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h4><p>智能指针是 C++11 引入的，但<code>std::make_unique</code>被忘记写入标准了，直到 C++14 才被引入…</p><h4 id="noexcept"><a href="#noexcept" class="headerlink" title="noexcept"></a>noexcept</h4><p><code>noexcept</code>在 C++11 引入。</p><p>不搞清这些标准问题，在 travis-ci 的编译器上会报错…</p><h3 id="高位深支持"><a href="#高位深支持" class="headerlink" title="高位深支持"></a>高位深支持</h3><p>高位深支持需要解决两个方面的问题，一是算法本身计算过程的修改，这一部分我改到现在还是有问题…图像暗场处理后会直接变黑…另一是C++语法的问题，带有模板的成员函数怎么写。</p><h4 id="语法层面的问题"><a href="#语法层面的问题" class="headerlink" title="语法层面的问题"></a>语法层面的问题</h4><p>我之前用模板，借用做饭的话说就是现用现做，而成员函数的声明和定义分开写在两个文件中，这时候再用模板就会出现链接器错误。但把声明和定义写在一起我不太愿意这么搞，于是折中的办法是在 main.cpp 同时 include 含有声明的 .h 和定义的 .cpp 文件。</p><h4 id="算法层面的问题"><a href="#算法层面的问题" class="headerlink" title="算法层面的问题"></a>算法层面的问题</h4><p>按照惯例，至少对于从 8bit 到 16bit 的扩充，把类似含有 255 的地方改成 peak 就可以了，但这次遇到了不少问题。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这一去雾算法在2013年提出，论文见 &lt;a href=&quot;http://mcl.korea.ac.kr/projects/dehazing/#userconsent#&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Optimized contrast enhancement for real-time image and video dehazing&lt;/a&gt;，我们称其为 DehazingCE （CE = contrast enhancement）。&lt;/p&gt;
&lt;h3 id=&quot;算法概述&quot;&gt;&lt;a href=&quot;#算法概述&quot; class=&quot;headerlink&quot; title=&quot;算法概述&quot;&gt;&lt;/a&gt;算法概述&lt;/h3&gt;&lt;p&gt;DehazingCE 基于大气散射模型，分别估计大气光强度和透射率，得到去雾结果。&lt;/p&gt;
    
    </summary>
    
    
      <category term="图像处理" scheme="http://yoursite.com/categories/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    
    
      <category term="构建与编译" scheme="http://yoursite.com/tags/%E6%9E%84%E5%BB%BA%E4%B8%8E%E7%BC%96%E8%AF%91/"/>
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
      <category term="VapourSynth" scheme="http://yoursite.com/tags/VapourSynth/"/>
    
  </entry>
  
  <entry>
    <title>《饥荒》食谱个人点评</title>
    <link href="http://yoursite.com/2020/05/30/Dont-starve/"/>
    <id>http://yoursite.com/2020/05/30/Dont-starve/</id>
    <published>2020-05-29T17:56:26.000Z</published>
    <updated>2020-07-27T14:22:22.202Z</updated>
    
    <content type="html"><![CDATA[<h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>这几天一直在玩《饥荒》，起因是想起大一和几个室友联机打游戏的场景；而且虽然我已经在 Steam 补票，但一直没怎么玩，于是重新开始，沉迷了几天。写一写这几天打游戏的感受，主要是点评食谱以及围绕食谱展开的生存模式。</p><a id="more"></a><p>内容比较基础，适合萌新观看。</p><p>额…再多说两句，我玩的是《饥荒》原始版，而大部分教程以及攻略都是基于《饥荒》巨人国DLC 展开的，在巨人王朝中添加了很多新内容，食谱也随之丰富，所以我的内容会比较少。</p><p><strong>Update</strong>：之后我买了巨人国DLC，又在夏日特卖时买了海滩DLC，所以对食谱做了少量更新，仍然是围绕基础版/巨人国展开，海滩的内容只加入了甘薯和咖啡豆（前者在兼容海滩的巨人国中也能种植获得，后者可以通过海滩穿越带到巨人国中）。</p><h3 id="我的食物风格"><a href="#我的食物风格" class="headerlink" title="我的食物风格"></a>我的食物风格</h3><p>我玩《饥荒》的风格可以概括为农场怪兽流，就是农场派+以怪兽肉为主要肉类，除了养一只鸟、一个蜂巢外，没有采取养猪、养兔子、捉火鸡等牧场派喜欢的模式。建猪舍只是因为之前没玩过，在开局早期倒是经常捉兔子，但之后就很少干了，而火鸡更是随缘。</p><h3 id="食物属性"><a href="#食物属性" class="headerlink" title="食物属性"></a>食物属性</h3><p>说食谱之前先整理一下食物属性，《饥荒》里将食物分为肉、蔬菜、水果、蛋、甜品等，并分别定义的了肉度、蔬菜度、果度、蛋度、甜品度（鱼还有鱼度，但基础版/巨人国中似乎用不上）。此外树枝、冰块在一定条件下也可以作为食谱填充物。</p><ul><li><strong>肉度</strong><ul><li>1.0 肉度：大肉、怪兽肉</li><li>0.5 肉度：小肉块、鱼、青蛙腿、鸡腿</li></ul></li><li><strong>蔬菜度</strong><ul><li>1.0 蔬菜度：各种蔬菜，包括夏季限定的仙人掌花</li><li>0.5 蔬菜度：红绿蓝三种颜色的蘑菇</li></ul></li><li><strong>果度</strong><ul><li>1.0 果度：各种水果</li><li>0.5 果度：浆果、咖啡豆（兼容海滩后从海滩穿越到巨人国可得）</li></ul></li><li><strong>蛋度</strong><ul><li>2.0 蛋度：高脚鸟蛋</li><li>1.0 蛋度：蛋（鸟蛋和企鹅蛋都是这同一个东西）</li></ul></li><li><strong>甜品度</strong><ul><li>蜂蜜和蜂巢，甜品度一样</li><li>非联机版无蜂王浆，不用考虑甜品度的问题</li></ul></li><li><strong>奶制品</strong><ul><li>羊奶、黄油</li><li>没有需要大于一个奶制品的食谱，所以奶制品不用考虑“度”的问题</li></ul></li><li><strong>鱼度</strong><ul><li>同样不甚了解，基础版与巨人国不用考虑，只有鱼和鳗鱼，鱼度一样</li></ul></li><li><strong>怪兽肉度</strong><ul><li>1.0 怪兽肉度：怪兽肉、榴莲（没有树枝的前提下，两个怪兽肉度会做出怪兽肉千层饼）</li></ul></li></ul><h3 id="我的食谱"><a href="#我的食谱" class="headerlink" title="我的食谱"></a>我的食谱</h3><p>正式开始说食谱，我个人将食谱分成如下几类。</p><p>在说食谱之前再啰嗦几句，由于肉丸是广为人知且较易得的饱食食谱，所以我的食谱主要侧重于回血与恢复精神。</p><p>对于回血，由蜘蛛腺体制作的治疗药膏可以回 20 血，以此为基准，大于 20 血的食谱都可以视为回血食谱。</p><p>对于恢复精神，大部分食物都只能加 5 精神，常见的恢复精神食谱包括蜂蜜类、冰类。</p><h4 id="喜欢且常做的食谱"><a href="#喜欢且常做的食谱" class="headerlink" title="喜欢且常做的食谱"></a>喜欢且常做的食谱</h4><ul><li><p><strong>波兰水饺</strong></p><p>波兰水饺是在我养鸟之后，最喜欢的食谱之一，有时候怪兽肉很多吃不完，做风干怪兽肉有点坑，把怪兽肉喂给鸟、变成蛋，就可以做波兰水饺了。</p><ul><li><strong>食谱属性</strong>：<strong>37.5 饱食、40 血、5 精神</strong>、20 秒烹饪、20 天保存</li><li><strong>通用食谱</strong>：1.0 蛋度 + 0.5 肉度 + 0.5 蔬菜度 + 其他（不能有树枝）</li><li><strong>我的食谱</strong>：一个蛋 + 一个怪兽肉 + 一个蔬菜或一个蘑菇 + 一个浆果或其他水果（注意不能有榴莲）</li><li><strong>额外说明</strong>：如前面所说，《饥荒》的食物属性中还有一个“怪兽肉度”，虽名为“肉度”，但并不限于肉，常见的怪兽肉、榴莲都是一个怪兽肉度。食谱中若包含两个怪兽肉度，则会做出不讨人喜欢的怪兽肉千层饼。所以一个怪兽肉加一个榴莲等效于两个怪兽肉，都会做出怪兽肉千层饼。</li></ul><p><strong>点评</strong>：回血神器、解决吃不完的怪兽肉、允许蘑菇给缺少蔬菜的冬季带来可能、保存时间也不错。</p></li><li><p><strong>火龙果派</strong></p><p>因为有农场，火龙果包括下面的南瓜都是比较容易获得的，所以很推荐又回血又饱腹制作简单粗暴的</p><ul><li><strong>食谱属性</strong>：<strong>75 饱食、40 血、5 精神</strong>、40 秒烹饪、15 天保存</li><li><strong>通用食谱</strong>：一个火龙果 + 其他（不能有肉）</li><li><strong>我的食谱</strong>：一个火龙果 + 三个树枝</li></ul><p><strong>点评</strong>：回血神器、饱食值也很高、能用三个树枝直接填满、保质期长，农场派的神器，特别是养鸟之后，可以得到火龙果种子。</p></li><li><p><strong>太妃糖、南瓜饼干</strong></p><p>这两个都是用来恢复精神的，而且主要依赖蜂蜜，所以放在了一起。</p><ul><li><p><strong>太妃糖</strong></p><ul><li><strong>食谱属性</strong>：<strong>25 饱食、-3 血、15 精神</strong>、40 秒烹饪、15 天保存</li><li><strong>通用食谱</strong>：三个蜂蜜或蜂巢 + 其他（不能有肉）</li><li><strong>我的食谱</strong>：三个蜂蜜 +一个树枝</li></ul></li><li><p><strong>南瓜饼干</strong></p><ul><li><strong>食谱属性</strong>：<strong>37.5 饱食、0 血、15 精神</strong>、40 秒烹饪、10 天保存</li><li><strong>通用食谱</strong>：一个南瓜 + 两个蜂蜜或蜂巢 + 其他（可以有肉，什么都可以）</li><li><strong>我的食谱</strong>：一个南瓜 + 两个蜂蜜 + 一个树枝</li></ul></li><li><p><strong>额外说明</strong> </p><ul><li>“三个蜂蜜或蜂巢 + 一个南瓜”做出上述两种食品的概率各为50%（当然也没理由这么做）</li><li>这两种食品优先度相当高，在其他大部分食谱中，都不能以曼德拉草为填充物（当然同样没理由把珍贵的曼德拉草来烹饪一般食物，所以上面没有提），但这两种食品都可以以曼德拉草为填充物，做出对应食品或曼德拉草汤的概率各为50%</li></ul></li></ul><p><strong>点评</strong>：回 san 食谱，虽然看上去需要很多蜂蜜，但其实养一个蜂巢就够了。由于生吃南瓜就可以得到 37.5 饱食和 3 点血，烤南瓜则提高到 8 点血，所以在蜂蜜充足的情况下，完全建议做太妃糖而不是南瓜饼，太妃糖扣的血量靠吃南瓜就可以弥补，还能增加更多的饱食度。</p><p>假如有三个蜂蜜 + 一个南瓜，两种组合方式及效果如下。</p><table><thead><tr><th align="center">食谱</th><th align="center">太妃糖 + 烤南瓜</th><th align="center">南瓜饼 + 蜂蜜</th></tr></thead><tbody><tr><td align="center">饱食</td><td align="center">25 + 37.5 = 62.5</td><td align="center">37.5 + 9.375 = 46.875</td></tr><tr><td align="center">血量</td><td align="center">-3 + 8 = 5</td><td align="center">0 + 3 = 3</td></tr><tr><td align="center">san 值</td><td align="center">15</td><td align="center">15</td></tr></tbody></table><p>“太妃糖 + 烤南瓜”的饱食度赶上一个肉丸了有木有？！</p></li><li><p><strong>西瓜冰</strong></p><ul><li><strong>食谱属性</strong>：<strong>12.5 饱食、3 血、20 精神</strong>、10 秒烹饪、3 天保存</li><li><strong>通用食谱</strong>：一个生西瓜 + 一个冰 + 一个树枝 + 填充物（不能是肉、蛋、蔬菜）</li><li><strong>我的食谱</strong>：一个生西瓜 + 一个冰 + 两个树枝</li></ul><p><strong>点评</strong>：<strong>西瓜为巨人国DLC增加</strong>，回 san 食谱，比太妃糖/南瓜饼回 san 更高，但西瓜毕竟是种出来的，而且保存期不是很长，不像太妃糖那样存着蜂蜜想做随时都有（其实单从回 san 角度，烤绿蘑菇是最简单粗暴的了，但毕竟还要趁着黄昏去桦树林或沼泽摘蘑菇，不像太妃糖那样宅在家里饭来张口。嗯…在游戏里我也喜欢宅 Orz…）。</p></li><li><p><strong>培根煎蛋</strong></p><ul><li><strong>食谱属性</strong>：<strong>75 饱食、20 血、5 精神</strong>、40 秒烹饪、20 天保存</li><li><strong>通用食谱</strong>：2.0 蛋度 + 至少 1.5 肉度</li><li><strong>我的食谱</strong>：两个蛋 + 一个怪兽肉 + 一个小肉</li></ul><p><strong>点评</strong>：保质期长的饱食回血食谱，可以视为增强版的肉丸。</p></li><li><p><strong>肉丸</strong></p><ul><li><strong>食谱属性</strong>：<strong>62.5 饱食、3 血、5 精神</strong>、15 秒烹饪、10 天保存</li><li><strong>通用食谱</strong>：肉度大于等于 0.5 小于等于 3.0 + 其他（不能是树枝、蜂蜜）</li><li><strong>我的食谱</strong>：一个怪兽肉/小肉 + 三个蔬菜/水果（避免怪兽肉 + 榴莲、鱼 + 玉米的组合）</li></ul><p><strong>点评</strong>：没什么好说的，增加饱食的易得利器，0.5 个肉度，也就是一个小肉即可，肉度大于 3.0 会做成肉汤。特别是条件不太好时，只为增加饱食又不太追求保质期，基本上没必要追求其他食谱。</p></li></ul><h4 id="比较喜欢的食谱"><a href="#比较喜欢的食谱" class="headerlink" title="比较喜欢的食谱"></a>比较喜欢的食谱</h4><ul><li><p><strong>青蛙腿三明治</strong></p><ul><li><strong>食谱属性</strong>：<strong>37.5 饱食、20 血、5 精神</strong>、10 秒烹饪、10 天保存</li><li><strong>通用食谱</strong>：一个青蛙腿 + 0.5 蔬菜度 + 其他</li><li><strong>我的食谱</strong>：一个青蛙腿  + 一个胡萝卜或一个蘑菇 + 两个树枝</li></ul><p><strong>点评</strong>：只需要 0.5 个蔬菜度、可以放两个树枝，如果有青蛙腿，则是一道很易得的回血食谱了。</p></li><li><p><strong>蜜汁火腿</strong></p><ul><li><strong>食谱属性</strong>：<strong>75 饱食、30 血、5 精神</strong>、40 秒烹饪、15 天保存</li><li><strong>通用食谱</strong>：2.0 肉度 + 一个蜂蜜（不能是蜂巢） + 其他（不能有树枝、蛋）</li><li><strong>我的食谱</strong>：一个大肉 + 一个怪兽肉 + 一个蜂蜜 + 一个蔬菜/水果（不能有榴莲）</li></ul><p><strong>点评</strong>：似乎很多人推荐蜜汁火腿，但由于需要两个肉度，至少也要一个大肉加一个怪兽肉，或者两个小肉加一个怪兽肉。<br>对农场派的我而言，大肉是难得的食材，有大肉我更倾向于直接做晾干成风干肉；而拿出两个小肉来做也是有点奢侈。蜜汁火腿的优势可能在于饱食+回血，但对于农场派有更好且更廉价的选择，就是火龙果派。</p></li></ul><h4 id="推荐的单品"><a href="#推荐的单品" class="headerlink" title="推荐的单品"></a>推荐的单品</h4><p><strong>肉干类</strong></p><ul><li><p>风干肉</p><ul><li><strong>食谱属性</strong>：<strong>25 饱食、20 血、15 精神</strong>、20 天保存</li></ul></li><li><p>小风干肉</p><ul><li><strong>食谱属性</strong>：<strong>12.5 饱食、8 血、10 精神</strong>、20 天保存</li></ul></li></ul><p><strong>回血果蔬</strong></p><ul><li><p>烤茄子</p><ul><li><strong>食谱属性</strong>：<strong>25 饱食、20 血、0 精神</strong>、6 天保存（生茄子 10 天保存）</li></ul><p><strong>点评</strong>：烤石榴（正式翻译是石榴切片）同样能回 20 血，但饱食度只有 12.5，而且只有 3 天保存（生石榴 6 天保存），相比之下就要比烤茄子逊色了。</p></li><li><p>蓝蘑菇</p><ul><li><strong>食谱属性</strong>：<strong>12.5 饱食、20 血、-15 精神</strong>、10 天保存</li></ul></li></ul><p><strong>回 san 蔬菜</strong></p><ul><li><p>烤绿蘑菇</p><ul><li><strong>食谱属性</strong>：<strong>0 饱食、-1 血、15 精神</strong>、10 天保存（绿蘑菇 10 天保存）</li></ul></li><li><p>烤仙人掌肉</p><ul><li><strong>食谱属性</strong>：<strong>12.5 饱食、1 血、15 精神</strong>、10 天保存（仙人掌肉 10 天保存）</li></ul><p><strong>点评</strong>：采摘仙人掌肉会损失 6 点血，夏天的时候会额外获得仙人掌花，仙人掌花回 8 点血，所以夏天采集仙人掌不会减血反而加血。</p></li><li><p>烤蓝蘑菇</p><ul><li><strong>食谱属性</strong>：<strong>0 饱食、-3 血、10 精神</strong>、10 天保存</li></ul></li></ul><p><strong>饱食蔬菜</strong></p><ul><li><p>烤南瓜</p><ul><li><strong>食谱属性</strong>：<strong>37.5 饱食、8 血、0 精神</strong>、6 天保存（生南瓜 10 天保存）</li></ul><p><strong>点评</strong>：饱食度比单块的肉还高，前面对南瓜饼与太妃糖的点评已经分析了烤南瓜作为单品食用的优势。</p></li></ul><h4 id="喜欢但不常做的食谱"><a href="#喜欢但不常做的食谱" class="headerlink" title="喜欢但不常做的食谱"></a>喜欢但不常做的食谱</h4><ul><li><p><strong>鱼排</strong></p><ul><li><strong>食谱属性</strong>：<strong>37.5 饱食、40 血、5 精神</strong>、40 秒烹饪、10 天保存</li><li><strong>通用食谱</strong>：一个鱼或鳗鱼 + 一个树枝 + 其他</li><li><strong>我的食谱</strong>：一个鱼  + 一个树枝 + 两个蔬菜/水果（玉米除外）</li><li><strong>额外说明</strong><ol><li>由于放了树枝，所以填充物可以时两个怪兽肉</li><li>“一个鱼 + 一个玉米”可能会做成炸鱼玉米饼（鱼塔可），37.5 饱食、20 血、5 精神、10 秒烹饪、6 天保存，虽然能放两个树枝，但明显浪费了食材</li></ol></li></ul><p><strong>点评</strong>：同样是回血神器，但我几乎不怎么钓鱼，只是偶尔靠被鱼人得到鱼，所以不怎么做。</p></li><li><p><strong>花瓣沙拉</strong></p><ul><li><strong>食谱属性</strong>：<strong>12.5 饱食、40 血、5 精神</strong>、10 秒烹饪、6 天保存</li><li><strong>通用食谱</strong>：一个仙人掌花 + 额外 1.5 蔬菜度 + 其他（不能有肉、蛋、水果、树枝、甜品，基本只能用冰）</li><li><strong>我的食谱</strong>：一个仙人掌花  + 三个蔬菜/蘑菇</li></ul><p><strong>点评</strong>：<strong>仙人掌为巨人国DLC增加</strong>，回血神器再 +1，但仙人掌花只有夏天跑到沙漠才能采，而且仙人掌花只有 3 天保存期，所以不经常做。只在初夏制作花衬衫的时候，顺便多采几个仙人掌来做。</p></li></ul><h4 id="不太喜欢的食谱"><a href="#不太喜欢的食谱" class="headerlink" title="不太喜欢的食谱"></a>不太喜欢的食谱</h4><ul><li><p><strong>蜜汁肉块</strong></p><ul><li><strong>食谱属性</strong>：<strong>37.5 饱食、20 血、5 精神</strong>、40 秒烹饪、15 天保存</li><li><strong>通用食谱</strong>：0.5 肉度 + 一个蜂蜜（不能是蜂巢） + 其他（不能有树枝、蛋）</li><li><strong>我的食谱</strong>：一个小肉  + 一个蜂蜜 + 两个蔬菜/水果</li></ul><p><strong>点评</strong>：蜜汁肉块的属性和青蛙腿三明治相当（除了保存时间多 5 天，烹饪时间多 30 秒）。</p></li></ul><h4 id="稀有食谱"><a href="#稀有食谱" class="headerlink" title="稀有食谱"></a>稀有食谱</h4><ul><li><p><strong>冰激凌</strong></p><ul><li><strong>食谱属性</strong>：<strong>25 饱食、0 血、50 精神</strong>、10 秒烹饪、3 天保存</li><li><strong>通用食谱</strong>：一个羊奶 + 一个蜂蜜/蜂巢 + 一个冰 + 其他（不能有肉、蛋、蔬菜、树枝）</li><li><strong>我的食谱</strong>：一个羊奶  + 一个蜂蜜 + 一个冰 + 一个浆果或冰</li></ul><p><strong>点评</strong>：<strong>羊奶为巨人国DLC增加</strong>，回 san 神器，回 san 最高的食谱。羊奶由被雷击的山羊掉落（100% 掉落）。让山羊被雷击有几种方式：自然状态下雨时被雷击、老奶奶读书、晨星锤攻击。通用而稳定的方法就是第三种，用晨星锤攻击。<br>晨星锤的制作需要羊角，羊角可由山羊或被雷击的山羊掉落，概率均为 25%。打山羊的时候通常是先用其他武器将山羊打到 100 血以下，再用晨星锤对山羊充电，最后杀死。</p></li></ul><h4 id="海滩穿越食谱"><a href="#海滩穿越食谱" class="headerlink" title="海滩穿越食谱"></a>海滩穿越食谱</h4><ul><li><p><strong>咖啡</strong></p><ul><li><strong>食谱属性</strong>：<strong>9.375 饱食、3 血、-5 精神</strong>、10 秒烹饪、10 天保存</li><li><strong>额外 Buff</strong>：增加 5 点移动速度，持续 4 分钟（半个游戏天）。普通角色移动速度为 6，相当于增加了 83% 的移动速度。</li><li><strong>通用食谱</strong>：三个烘焙咖啡豆 + 填充物（填充物只能为烘培咖啡豆、蜂蜜、羊奶）</li><li><strong>我的食谱</strong>：三个烘焙咖啡豆 + 一个蜂蜜</li></ul><p><strong>点评</strong>：颇费周折从海滩穿越过来，为的就是咖啡。跑在地图上飞快，配合手杖甚至夏天都可以到处乱跑。</p></li></ul><h3 id="我的食品生产模式"><a href="#我的食品生产模式" class="headerlink" title="我的食品生产模式"></a>我的食品生产模式</h3><p>在开头提到，我是农场怪兽流，所以农场 + 鸟是我的基本生产模式，此外还养了一个蜂巢，用于获取蜂蜜。前期靠鸟把怪兽肉变成蛋，后期食材较丰富后，开始喂给鸟火龙果、南瓜等重点果蔬，获得专门的火龙果种子和南瓜种子。</p><p>关于怪兽肉的获取，我把家建在了离池塘稍近的地方，靠青蛙与猎狗两方争斗获取怪兽肉，此外就是去刷蜘蛛（蜘蛛网也是捕鸟养鸟的前提，所以蜘蛛是农场派和怪兽肉的结合点）。没有把家建在猪舍旁，因为猪喜欢吃种子，对农场派而言有点烦。没有把家建在牛群旁，因为就算是农场派，需要肥料时再去找也就够了，不需要特别多。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h3&gt;&lt;p&gt;这几天一直在玩《饥荒》，起因是想起大一和几个室友联机打游戏的场景；而且虽然我已经在 Steam 补票，但一直没怎么玩，于是重新开始，沉迷了几天。写一写这几天打游戏的感受，主要是点评食谱以及围绕食谱展开的生存模式。&lt;/p&gt;
    
    </summary>
    
    
      <category term="二次元与游戏" scheme="http://yoursite.com/categories/%E4%BA%8C%E6%AC%A1%E5%85%83%E4%B8%8E%E6%B8%B8%E6%88%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>nnedi3 相关代码学习</title>
    <link href="http://yoursite.com/2020/04/30/nnedi3/"/>
    <id>http://yoursite.com/2020/04/30/nnedi3/</id>
    <published>2020-04-30T13:17:39.000Z</published>
    <updated>2020-05-01T07:07:42.176Z</updated>
    
    <content type="html"><![CDATA[<h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>其实不知道有没有必要像这样，为并不是很复杂的源码煞有介事地写一份包含个人感想的阅读笔记。但不得不说，<a href="https://forum.doom9.org/showthread.php?t=147695" target="_blank" rel="noopener">nnedi3</a> 相关的内容，从我最开始接触图像处理，就一直萦绕在心头。一直觉得 nnedi3 很神奇，抗锯齿用它，重采样放大也用它，因为用了神经网络更显得高大上。另一方面，随着 Deep Learning 浪潮涌起，有些人开始质疑对 Deep Learning 的跟风。于是有种错觉，用传统神经网络的 nnedi3，既套上了光环，又躲过了质疑。</p><p>起初接触 nnedi3 是通过 <a href="https://www.nmm-hd.org/newbbs/viewtopic.php?f=7&t=1117" target="_blank" rel="noopener">nnedi3_resize16</a> 这个流传甚广的缩放脚本。之后在我学会 deband 与边缘检测后，很长时间没有继续学新东西，几乎过了一年，我才接触到 nnedi3 的抗锯齿用途。又跨过大半年，在我熟悉 Github 之后，到第二年的秋天，我又看到了优化版的 <a href="https://github.com/sekrit-twc/znedi3" target="_blank" rel="noopener">znedi3</a> 和 <a href="(https://github.com/HomeOfVapourSynthEvolution/VapourSynth-NNEDI3CL)">nnedi3cl</a>。某种角度上，nnedi3 贯穿了我到目前为止的图像处理学习过程。</p><a id="more"></a><p>我已经忘记之前是在哪里看到，说 nnedi3 没有开源。我也模糊得记得，找过 eedi 系列滤镜，没找到代码（事实上也是开源的）。于是交错的印象下，在我开始写 C++ 之前，没有再深入了解 nnedi3。即使是之后开始写 VapourSynth Plugin，也是模仿着 Deblock 和 nnedi2 的框架（话说这对初学者而言，和 nnedi3 比也没什么区别喂喂，只是我当时选择性地无视了）。</p><p>BTW，学习代码不是自己写代码，有时候需要不求甚解，明白意思即可，不然也只是浪费时间。</p><h3 id="代码概览"><a href="#代码概览" class="headerlink" title="代码概览"></a>代码概览</h3><h4 id="代码框架"><a href="#代码框架" class="headerlink" title="代码框架"></a>代码框架</h4><p><a href="https://github.com/HomeOfVapourSynthEvolution/VapourSynth-NNEDI3CL" target="_blank" rel="noopener">VapourSynth-NNEDI3CL</a> 是 VapourSynth 框架下进行了 OpenCL 优化的 nnedi3 实现，除了 OpenCL 配置文件外，只有一份 nnedi3cl.cpp，代码结构也不复杂，VapourSynth Plugin 框架的四个函数 + 一个 process() 性质的函数。</p><p>重新审视一下 VapourSynth Plugin 框架的四个函数，初始化函数 Init() 和 释放内存函数 Free() 不必多说，从计算内容的角度看，GetFrame() 函数是与图像内容相关的计算，会用到像素点的数据，而 Create() 函数（除获取参数外）则是无关像素点数值的计算，至多会用到视频格式的信息。从两个函数的名字上看也能看出这一点。</p><p>NNEDI3CL 因为涉及 OpenCL，且参数较多，Create() 函数中报错信息占了较长的篇幅。nnedi3 最原始的用途是隔行插值反交错，所以在 GetFrame() 函数中，比只处理逐行的滤镜，多了 field / 场信息的判断。</p><p>大致浏览完这些信息，核心处理从<code>nnedi3_weights.bin</code>文件入手。</p><h4 id="主要数据"><a href="#主要数据" class="headerlink" title="主要数据"></a>主要数据</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++">compute::command_queue <span class="hljs-built_in">queue</span>;<br>compute::kernel kernel;<br>compute::image2d src, dst, tmp;<br>compute::buffer weights0, weights1Buffer;<br>cl_mem weights1;<br></code></pre></td></tr></table></figure><p>其中<code>queue</code>、<code>kernel</code>用于 OpenCL 框架，三个<code>image2D</code>类型的变量<code>src</code>、<code>dst</code>、<code>tmp</code>用于储存图像，余下三个变量则是与神经网络权值相关。</p><p>在 Create() 函数内，<code>weights0</code>、<code>weights1</code>都是<code>float</code>指针。</p><p><code>cl_mem</code>类型用于在设备上分配内存，<code>cl_mem</code>类型是”Memory Object“的句柄，提供了一种内存抽象。</p><h3 id="神经网络"><a href="#神经网络" class="headerlink" title="神经网络"></a>神经网络</h3><h4 id="IO-部分"><a href="#IO-部分" class="headerlink" title="IO 部分"></a>IO 部分</h4><p>由于使用传统神经网络，需要读入权值文件<code>nnedi3_weights.bin</code>。IO 部分基于头文件<code>&lt;cstdio&gt;</code>。</p><p>除了常见的<code>std::fopen</code>、<code>std::fclose</code>外，还用到了下面这些函数。</p><p><code>std::fread</code>-<code>std::size_t fread(void* buffer, std::size_t size, std::size_t count, std::FILE* stream)</code>：从输入流读取至多 <code>count</code> 个对象到数组 <code>buffer</code> 中，返回成功读取的对象数。</p><p><code>std::rewind</code>-<code>void rewind(std::FILE* stream)</code>：移动文件位置指示器到给定文件流的起始。</p><p><code>std::ftell</code>-<code>long ftell(std::FILE* stream)</code>：返回文件流文件位置指示器的当前值。</p><p>读入的<strong>权值数据保存在<code>bdata</code>中</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">long</span> correctSize = <span class="hljs-number">13574928</span>; <span class="hljs-comment">// Version 0.9.4 of the Avisynth plugin</span><br><br><span class="hljs-keyword">float</span> * bdata = <span class="hljs-keyword">reinterpret_cast</span>&lt;<span class="hljs-keyword">float</span> *&gt;(<span class="hljs-built_in">malloc</span>(correctSize));<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">size_t</span> bytesRead = <span class="hljs-built_in">std</span>::fread(bdata, <span class="hljs-number">1</span>, correctSize, weightsFile);<br></code></pre></td></tr></table></figure><h4 id="权值计算的后续"><a href="#权值计算的后续" class="headerlink" title="权值计算的后续"></a>权值计算的后续</h4><p>Create() 部分的权值有点复杂，先看看 Create() 权值计算结果是怎么用到 GetFrame() 上的吧。</p><p>如后文的”OpenCL 变量“部分所说，三个权值变量被 GetFrame() 调用的只有两个，<code>weights0</code>和<code>weights1</code>，被调用的位置和次数一样，只是<code>weights1</code>在 Free() 函数中多了一步释放。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">clReleaseMemObject(d-&gt;weights1);<br></code></pre></td></tr></table></figure><p>两个变量在三个分支的<code>if-else</code>中同时出现了四次，伪代码如下。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta"># bool d-&gt;dw, d-&gt;dh;</span><br><br><span class="hljs-keyword">if</span> (d-&gt;dw &amp;&amp; d-&gt;dh)<br>&#123;<br>    kernel.set_args(src, tmp, d-&gt;weights0, d-&gt;weights1, size_h_w, field, <span class="hljs-number">-1</span>);<br>    kernel.set_args(tmp, dst, d-&gt;weights0, d-&gt;weights1, size_w_h, field,  <span class="hljs-number">0</span>);<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (d-&gt;dw)<br>&#123;<br>    kernel.set_args(src, dst, d-&gt;weights0, d-&gt;weights1, size_h_w, field, <span class="hljs-number">-1</span>);<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>    kernel.set_args(src, dst, d-&gt;weights0, d-&gt;weights1, size_w_h, field,  <span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>很明显，是从 x，y 两个方向分别处理。在这四次调用中，<code>weights0</code>和<code>weights1</code>发挥的作用是等价。</p><p>进而来整体看下 GetFrame() 函数及 process() 函数（在 NNEDI3CL 里写作 <code>filter()</code>），常规而且仅有骨架，上面的伪代码便是核心而唯一的操作，除此之前唯一陌生的地方就是增加了 field 信息的判断。</p><p>于是，可以转向 .cl 文件看核心计算了。</p><h3 id="OpenCL-核心计算"><a href="#OpenCL-核心计算" class="headerlink" title="OpenCL 核心计算"></a>OpenCL 核心计算</h3><p>这部分是 .cl 文件中的代码学习笔记。</p><p>命名空间（好像说法不太对..）<code>kernel</code>下的函数有两个重载，分别对应<code>float</code>类型和 uint 类型，看看其中一个。（删去了<code>&quot;\n&quot;</code>）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++">__kernel __attribute__((reqd_work_group_size(<span class="hljs-number">4</span>, <span class="hljs-number">16</span>, <span class="hljs-number">1</span>)))<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">filter_uint</span><span class="hljs-params">(__read_only <span class="hljs-keyword">image2d_t</span> src, __write_only <span class="hljs-keyword">image2d_t</span> dst,</span></span><br><span class="hljs-function"><span class="hljs-params">                 __constant <span class="hljs-keyword">float</span> * weights0, __read_only <span class="hljs-keyword">image1d_buffer_t</span> weights1,</span></span><br><span class="hljs-function"><span class="hljs-params">                 <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> srcWidth, <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> srcHeight, <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> dstWidth,</span></span><br><span class="hljs-function"><span class="hljs-params">                 <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> dstHeight, <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> field_n, <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> off, <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> swap)</span></span><br></code></pre></td></tr></table></figure><p>和前面<code>filter()</code>函数中的核心处理相对应。</p><p>追踪一下<code>weights0</code>的传递过程。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">float8 output = PRESCREEN((<span class="hljs-keyword">const</span> __local <span class="hljs-keyword">float</span> (*)[INPUT_WIDTH])&amp;input[YDIAD2M1 - <span class="hljs-number">1</span> + localY][XDIAD2M1 - PSCRN_OFFSET + <span class="hljs-number">8</span> * localX],<br>                          &amp;flag, weights0);<br></code></pre></td></tr></table></figure><p>（这个<code>PRESCREEN()</code>是啥…）</p><h3 id="OpenCL-接口部分"><a href="#OpenCL-接口部分" class="headerlink" title="OpenCL 接口部分"></a>OpenCL 接口部分</h3><p>这部分是 Create() 函数中出现的 OpenCL 相关内容。</p><h4 id="相关函数"><a href="#相关函数" class="headerlink" title="相关函数"></a>相关函数</h4><h5 id="clCreateImage"><a href="#clCreateImage" class="headerlink" title="clCreateImage"></a><code>clCreateImage</code></h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">cl_mem <span class="hljs-title">clCreateImage</span><span class="hljs-params">(cl_context              context,</span></span><br><span class="hljs-function"><span class="hljs-params">                     cl_mem_flags            flags,</span></span><br><span class="hljs-function"><span class="hljs-params">                     <span class="hljs-keyword">const</span> cl_image_format  *image_format,</span></span><br><span class="hljs-function"><span class="hljs-params">                     <span class="hljs-keyword">const</span> cl_image_desc    *image_desc,</span></span><br><span class="hljs-function"><span class="hljs-params">                     <span class="hljs-keyword">void</span>                   *host_ptr,</span></span><br><span class="hljs-function"><span class="hljs-params">                     cl_int                 *errcode_ret)</span></span><br></code></pre></td></tr></table></figure><p>Creates a 1D image, 1D image buffer, 1D image array, 2D image, 2D image array or 3D image object.</p><p>创建一维图像、一维图像 buffer、一维图像数组、二维图像、二维图像数组或者三维图像对象。</p><h4 id="OpenCL-变量"><a href="#OpenCL-变量" class="headerlink" title="OpenCL 变量"></a>OpenCL 变量</h4><h5 id="d-gt-weights1"><a href="#d-gt-weights1" class="headerlink" title="d-&gt;weights1"></a><code>d-&gt;weights1</code></h5><p>结构体内的<code>weights1</code>定义如下。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">cl_mem mem = clCreateImage(context, <span class="hljs-number">0</span>, &amp;format, &amp;desc, <span class="hljs-literal">nullptr</span>, &amp;error);<br>d-&gt;weights1 = mem;<br></code></pre></td></tr></table></figure><p>其中，<code>mem</code>的主要数据来自<code>desc</code>。</p><p><code>desc</code>的数据，除了一些格式上的常数，一是来自<code>dims1</code>，一是来自权值<code>weights1Buffer</code>，也就是三个结构体内的数据之一。</p><p><code>dims1</code>的定义如下，都是常数计算，没有额外的东西。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> dims1 = nnsTable[nns] * <span class="hljs-number">2</span> * (xdiaTable[nsize] * ydiaTable[nsize] + <span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure><p>所以综上所述，<code>weights1</code>与<code>weights1Buffer</code>有种套娃之感，核心数据是一样的。（看一下名字啊，<code>weights1Buffer</code>=<code>weights1</code>+<code>buffer</code>）</p><h5 id="d-gt-weights0与d-gt-weights1Buffer"><a href="#d-gt-weights0与d-gt-weights1Buffer" class="headerlink" title="d-&gt;weights0与d-&gt;weights1Buffer"></a><code>d-&gt;weights0</code>与<code>d-&gt;weights1Buffer</code></h5><p>结构体内的<code>weights0</code>与<code>weights1Buffer</code>定义如下。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++">d-&gt;weights0 = compute::buffer&#123; context, <span class="hljs-built_in">std</span>::max(dims0, dims0new) * <span class="hljs-keyword">sizeof</span>(cl_float),<br>    CL_MEM_READ_ONLY | CL_MEM_COPY_HOST_PTR | CL_MEM_HOST_NO_ACCESS, weights0 &#125;;<br><br>d-&gt;weights1Buffer = compute::buffer&#123; context, dims1 * <span class="hljs-number">2</span> * <span class="hljs-keyword">sizeof</span>(cl_float),<br>    CL_MEM_READ_ONLY | CL_MEM_COPY_HOST_PTR | CL_MEM_HOST_NO_ACCESS, weights1 &#125;;<br></code></pre></td></tr></table></figure><p>事实上，<code>weights1Buffer</code>的调用范围仅限于 Create()，并没有在 GetFrame() 中调用。</p><h5 id="Create-内的同名变量"><a href="#Create-内的同名变量" class="headerlink" title="Create() 内的同名变量"></a>Create() 内的同名变量</h5><p>在 Create() 函数内，有两个临时变量性质的同名变量，定义如下。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">float</span>* weights0 = <span class="hljs-keyword">new</span> <span class="hljs-keyword">float</span>[<span class="hljs-built_in">std</span>::max(dims0, dims0new)];<br><span class="hljs-keyword">float</span>* weights1 = <span class="hljs-keyword">new</span> <span class="hljs-keyword">float</span>[dims1 * <span class="hljs-number">2</span>];<br></code></pre></td></tr></table></figure><p>它们在定义了<code>d-&gt;weights0</code>与<code>d-&gt;weights1Buffer</code>后被释放。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h3&gt;&lt;p&gt;其实不知道有没有必要像这样，为并不是很复杂的源码煞有介事地写一份包含个人感想的阅读笔记。但不得不说，&lt;a href=&quot;https://forum.doom9.org/showthread.php?t=147695&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;nnedi3&lt;/a&gt; 相关的内容，从我最开始接触图像处理，就一直萦绕在心头。一直觉得 nnedi3 很神奇，抗锯齿用它，重采样放大也用它，因为用了神经网络更显得高大上。另一方面，随着 Deep Learning 浪潮涌起，有些人开始质疑对 Deep Learning 的跟风。于是有种错觉，用传统神经网络的 nnedi3，既套上了光环，又躲过了质疑。&lt;/p&gt;
&lt;p&gt;起初接触 nnedi3 是通过 &lt;a href=&quot;https://www.nmm-hd.org/newbbs/viewtopic.php?f=7&amp;t=1117&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;nnedi3_resize16&lt;/a&gt; 这个流传甚广的缩放脚本。之后在我学会 deband 与边缘检测后，很长时间没有继续学新东西，几乎过了一年，我才接触到 nnedi3 的抗锯齿用途。又跨过大半年，在我熟悉 Github 之后，到第二年的秋天，我又看到了优化版的 &lt;a href=&quot;https://github.com/sekrit-twc/znedi3&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;znedi3&lt;/a&gt; 和 &lt;a href=&quot;(https://github.com/HomeOfVapourSynthEvolution/VapourSynth-NNEDI3CL)&quot;&gt;nnedi3cl&lt;/a&gt;。某种角度上，nnedi3 贯穿了我到目前为止的图像处理学习过程。&lt;/p&gt;
    
    </summary>
    
    
      <category term="图像处理" scheme="http://yoursite.com/categories/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
      <category term="VapourSynth" scheme="http://yoursite.com/tags/VapourSynth/"/>
    
  </entry>
  
  <entry>
    <title>一些较新的去雾（dehazing）算法</title>
    <link href="http://yoursite.com/2020/04/28/dehazing/"/>
    <id>http://yoursite.com/2020/04/28/dehazing/</id>
    <published>2020-04-28T13:12:23.000Z</published>
    <updated>2020-04-28T14:57:35.978Z</updated>
    
    <content type="html"><![CDATA[<p>提到去雾算法，首先想到的便是 2009 年的暗通道去雾算法，以及后续的导向滤波，搜索博客和 Github 发现了一些较新的去雾算法，也算是尝试跟上学术界的脚步。</p><a id="more"></a><ul><li><p>2013年基于对比度增强的去雾算法<br><a href="http://mcl.korea.ac.kr/projects/dehazing/#userconsent#" target="_blank" rel="noopener">http://mcl.korea.ac.kr/projects/dehazing/#userconsent#</a></p></li><li><p>2016年非局部均值去雾算法<br><a href="https://github.com/danaberman/non-local-dehazing" target="_blank" rel="noopener">https://github.com/danaberman/non-local-dehazing</a></p></li></ul><h3 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h3><p>基于对比度增强的去雾算法（以下简称 DehazingCE，CE =  Contrast enhancement）的作者给出了完整的 C++ 代码，只是是基于 OpenCV 2 的（而且代码风格也有些复古）。对我来说，从头完整地把代码迁移到 VapourSynth 上有点困难，所以先做原始代码从 OpenCV 2 到 OpenCV 3 的迁移。</p><h4 id="数据类型的变化"><a href="#数据类型的变化" class="headerlink" title="数据类型的变化"></a>数据类型的变化</h4><p>从 OpenCV 2 的 IplImage 到 OpenCV 3 的 Mat。</p><h4 id="函数名与类型名的变化"><a href="#函数名与类型名的变化" class="headerlink" title="函数名与类型名的变化"></a>函数名与类型名的变化</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">cvCopyImage → cvCopy<br>cvCvtPixToPlane → cvSplit<br>POINT → cv::Point           <span class="hljs-comment">// 这个像是手滑</span><br></code></pre></td></tr></table></figure><h4 id="数据类型的变化-1"><a href="#数据类型的变化-1" class="headerlink" title="数据类型的变化"></a>数据类型的变化</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">double</span> deMean[<span class="hljs-number">3</span>];<br>→<br>  <span class="hljs-keyword">double</span> deMean_value[<span class="hljs-number">3</span>];<br>  CvScalar dpMean = cvScalar(deMean_value[<span class="hljs-number">1</span>], deMean_value[<span class="hljs-number">2</span>], deMean_value[<span class="hljs-number">3</span>]);<br></code></pre></td></tr></table></figure><h4 id="添加头文件"><a href="#添加头文件" class="headerlink" title="添加头文件"></a>添加头文件</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;opencv2/videoio.hpp&gt;</span></span><br></code></pre></td></tr></table></figure><h4 id="补齐依赖项"><a href="#补齐依赖项" class="headerlink" title="补齐依赖项"></a>补齐依赖项</h4><p>缺少 OpenCV 2.4.3 的四个 .lib 静态库</p><p>缺少 MSVCP100D.dll、MSVCR100D.dll</p><h4 id="运行时遇到的问题"><a href="#运行时遇到的问题" class="headerlink" title="运行时遇到的问题"></a>运行时遇到的问题</h4><h5 id="问题1"><a href="#问题1" class="headerlink" title="问题1"></a>问题1</h5><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">引发了异常: 读取访问权限冲突。 **iminput** 是 <span class="hljs-literal">null</span>ptr。<br></code></pre></td></tr></table></figure><p>空指针，具体而言是没有定义输入图像…</p><h5 id="问题2"><a href="#问题2" class="headerlink" title="问题2"></a>问题2</h5><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">Run</span><span class="bash">-Time Check Failure <span class="hljs-comment">#2 - Stack around the variable 'deMean_value' was corrupted.</span></span><br></code></pre></td></tr></table></figure><p>指针越界了…</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;提到去雾算法，首先想到的便是 2009 年的暗通道去雾算法，以及后续的导向滤波，搜索博客和 Github 发现了一些较新的去雾算法，也算是尝试跟上学术界的脚步。&lt;/p&gt;
    
    </summary>
    
    
      <category term="图像处理" scheme="http://yoursite.com/categories/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    
    
  </entry>
  
  <entry>
    <title>周记 2020.03.16-03.22</title>
    <link href="http://yoursite.com/2020/04/28/week-202003-3/"/>
    <id>http://yoursite.com/2020/04/28/week-202003-3/</id>
    <published>2020-04-28T08:25:36.000Z</published>
    <updated>2020-04-28T08:26:57.811Z</updated>
    
    <content type="html"><![CDATA[<p>strncpy() -&gt; memcpy() 从内存中复制，gcc对后者兼容性更好？避免warning？</p><p>学习编程的三个方向<br>1.整体结构设计，特别以类和对象为基础的面向对象的构成<br>2.算法优化，同样一个算法，怎么运行更快，这是coder该想的事情，而非算法专家想的事情<br>3.Debug，找bug并更正的能力</p><a id="more"></a><p>再拖着不接触核心算法真不是事，先用vs框架实现算法吧</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">tmp_array.resize(tmp_array.size() + coeff_per_pixel, <span class="hljs-number">0.f</span>); <span class="hljs-comment">// 调整大小，填零</span><br></code></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;strncpy() -&amp;gt; memcpy() 从内存中复制，gcc对后者兼容性更好？避免warning？&lt;/p&gt;
&lt;p&gt;学习编程的三个方向&lt;br&gt;1.整体结构设计，特别以类和对象为基础的面向对象的构成&lt;br&gt;2.算法优化，同样一个算法，怎么运行更快，这是coder该想的事情，而非算法专家想的事情&lt;br&gt;3.Debug，找bug并更正的能力&lt;/p&gt;
    
    </summary>
    
    
      <category term="笔记" scheme="http://yoursite.com/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>周记 2020.03.09-03.15</title>
    <link href="http://yoursite.com/2020/04/28/week-202003-2/"/>
    <id>http://yoursite.com/2020/04/28/week-202003-2/</id>
    <published>2020-04-28T08:23:47.000Z</published>
    <updated>2020-04-28T08:25:04.532Z</updated>
    
    <content type="html"><![CDATA[<h3 id="C-语法"><a href="#C-语法" class="headerlink" title="C++语法"></a>C++语法</h3><h4 id="explicit"><a href="#explicit" class="headerlink" title="explicit"></a><code>explicit</code></h4><p><code>explicit</code>用来修饰构造函数、转换函数（C++11）、推导指引（C++17），C++20可以在其后加表达式（详见：<a href="https://zh.cppreference.com/w/cpp/language/explicit）。" target="_blank" rel="noopener">https://zh.cppreference.com/w/cpp/language/explicit）。</a></p><p><strong>功能</strong></p><ul><li>被修饰的构造函数的类，不能进行隐式类型转换，只能进行显示类型转换</li><li>不能用于复制初始化</li></ul><p><strong>注意</strong></p><ul><li><code>explicit</code>只能用于构造函数的声明</li></ul><a id="more"></a><p><a href="https://www.cnblogs.com/this-543273659/archive/2011/08/02/2124596.html" target="_blank" rel="noopener">这篇博文</a>中的例子。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/* without explicit */</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">circle</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>    circle(<span class="hljs-keyword">double</span> r) : R(r) &#123;&#125;<br>    circle(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y = <span class="hljs-number">0</span>) : X(x), Y(y) &#123;&#125;<br>    circle(<span class="hljs-keyword">const</span> circle&amp; c) : R(c.R), X(c.X), Y(c.Y) &#123;&#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">double</span> R;<br>    <span class="hljs-keyword">int</span> X, Y;<br>&#125;;<br><br><span class="hljs-keyword">int</span> _tmain()<br>&#123;<br>    circle A = <span class="hljs-number">1.23</span>;<br>    circle B = <span class="hljs-number">123</span>;<br>    circle C = A;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/* with explicit */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">circle</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-keyword">public</span>:<br>    explicit circle(double r) : R(r) &#123;&#125;<br>    explicit circle(int x, int y = 0) : X(x), Y(y) &#123;&#125;<br>    explicit circle(const circle&amp; c) : R(c.R), X(c.X), Y(c.Y) &#123;&#125;<br>    <span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">double</span> R;<br>    <span class="hljs-keyword">int</span> X, Y;<br>&#125;;<br><br><span class="hljs-keyword">int</span> _tmain()<br>&#123;<br>    <span class="hljs-function">circle <span class="hljs-title">A</span><span class="hljs-params">(<span class="hljs-number">1.23</span>)</span></span>;<br>    <span class="hljs-function">circle <span class="hljs-title">B</span><span class="hljs-params">(<span class="hljs-number">123</span>)</span></span>;<br>    <span class="hljs-function">circle <span class="hljs-title">C</span><span class="hljs-params">(A)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在结构中也可以这么用。</p><h4 id="非常量引用的初始值必须是左值"><a href="#非常量引用的初始值必须是左值" class="headerlink" title="非常量引用的初始值必须是左值"></a>非常量引用的初始值必须是左值</h4><p>可能是存在不被允许的隐式类型转换。</p><h4 id="assert"><a href="#assert" class="headerlink" title="assert"></a><code>assert</code></h4><p><code>assert</code>是宏，不仅用来报错。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;C-语法&quot;&gt;&lt;a href=&quot;#C-语法&quot; class=&quot;headerlink&quot; title=&quot;C++语法&quot;&gt;&lt;/a&gt;C++语法&lt;/h3&gt;&lt;h4 id=&quot;explicit&quot;&gt;&lt;a href=&quot;#explicit&quot; class=&quot;headerlink&quot; title=&quot;explicit&quot;&gt;&lt;/a&gt;&lt;code&gt;explicit&lt;/code&gt;&lt;/h4&gt;&lt;p&gt;&lt;code&gt;explicit&lt;/code&gt;用来修饰构造函数、转换函数（C++11）、推导指引（C++17），C++20可以在其后加表达式（详见：&lt;a href=&quot;https://zh.cppreference.com/w/cpp/language/explicit）。&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://zh.cppreference.com/w/cpp/language/explicit）。&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;功能&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;被修饰的构造函数的类，不能进行隐式类型转换，只能进行显示类型转换&lt;/li&gt;
&lt;li&gt;不能用于复制初始化&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;explicit&lt;/code&gt;只能用于构造函数的声明&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="笔记" scheme="http://yoursite.com/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>从 VapourSynth API 到 C++ 基础知识</title>
    <link href="http://yoursite.com/2020/04/28/from-vs-to-cpp/"/>
    <id>http://yoursite.com/2020/04/28/from-vs-to-cpp/</id>
    <published>2020-04-28T08:16:44.000Z</published>
    <updated>2020-04-28T08:17:57.426Z</updated>
    
    <content type="html"><![CDATA[<p><del>副标题：从 C + isotream 到 C++</del></p><p>（这是1月底写一点随笔，然后就被丢到一边不管了）</p><h3 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h3><p>全面讲述智能指针的文章：<a href="https://juejin.im/post/5dcaa857e51d457f7675360b" target="_blank" rel="noopener">https://juejin.im/post/5dcaa857e51d457f7675360b</a></p><p>熟悉的<code>unique_ptr</code>，是“拥有独有对象所有权语义的智能指针”。</p><a id="more"></a><h4 id="智能指针的释放"><a href="#智能指针的释放" class="headerlink" title="智能指针的释放"></a>智能指针的释放</h4><p>一个基本概念，要用<code>.</code>而非<code>-&gt;</code>。（<a href="https://blog.csdn.net/delphicui/article/details/4213811）" target="_blank" rel="noopener">https://blog.csdn.net/delphicui/article/details/4213811）</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">smartPointer.release();   <span class="hljs-comment">// 正确</span><br>smartPointer-&gt;release();  <span class="hljs-comment">// 错误</span><br></code></pre></td></tr></table></figure><p>在 VapourSynth Plugin 的编写时，要在<code>Free()</code>函数里写<code>delete d;</code>，但又在<code>Create()</code>函数里写了<code>d.release()</code>。可不可以这么理解，智能指针<code>d</code>在<code>Creat()</code>函数里被声明，所以要在<code>Create()</code>函数内释放一次，但其他地方也用到了<code>d</code>，所以又要写一次<code>delete d</code>？<del>我感觉我在胡说八道</del></p><h4 id="智能指针与数组"><a href="#智能指针与数组" class="headerlink" title="智能指针与数组"></a>智能指针与数组</h4><p>用智能指针创建数组，类似下面这样。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">unique_ptr</span>&lt;<span class="hljs-keyword">float</span>[]&gt; <span class="hljs-built_in">array</span>[<span class="hljs-number">5</span>];<br></code></pre></td></tr></table></figure><p>而且用后并没有释放，这是自然，毕竟智能指针的本意即是如此。</p><p>但我不知道，对于查表用的大数组，有没有必要“升级”成智能指针，对于使用<code>new</code>创建的指针呢？</p><h3 id="com组件"><a href="#com组件" class="headerlink" title="com组件"></a>com组件</h3><p>（被淘汰的技术）</p><p>（我不知道 VapourSynth API 里的 com 是不是这个 com）</p><h3 id="lamda表达式"><a href="#lamda表达式" class="headerlink" title="lamda表达式"></a>lamda表达式</h3><p>（额外延伸的，稍后再看）</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;del&gt;副标题：从 C + isotream 到 C++&lt;/del&gt;&lt;/p&gt;
&lt;p&gt;（这是1月底写一点随笔，然后就被丢到一边不管了）&lt;/p&gt;
&lt;h3 id=&quot;智能指针&quot;&gt;&lt;a href=&quot;#智能指针&quot; class=&quot;headerlink&quot; title=&quot;智能指针&quot;&gt;&lt;/a&gt;智能指针&lt;/h3&gt;&lt;p&gt;全面讲述智能指针的文章：&lt;a href=&quot;https://juejin.im/post/5dcaa857e51d457f7675360b&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://juejin.im/post/5dcaa857e51d457f7675360b&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;熟悉的&lt;code&gt;unique_ptr&lt;/code&gt;，是“拥有独有对象所有权语义的智能指针”。&lt;/p&gt;
    
    </summary>
    
    
      <category term="图像处理" scheme="http://yoursite.com/categories/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
      <category term="VapourSynth" scheme="http://yoursite.com/tags/VapourSynth/"/>
    
  </entry>
  
  <entry>
    <title>色调映射（Tone mapping）</title>
    <link href="http://yoursite.com/2020/04/28/Tonemapping/"/>
    <id>http://yoursite.com/2020/04/28/Tonemapping/</id>
    <published>2020-04-28T08:07:48.000Z</published>
    <updated>2020-04-28T08:48:54.019Z</updated>
    
    <content type="html"><![CDATA[<p>在<a href="https://kiyamou.github.io/2020/02/08/ISP-learn-1/" target="_blank" rel="noopener">之前的博文</a>中提到过色调映射，色调映射可以做很多事情，既包括对相机 raw 文件的亮度调整，也可以做 HDR 的转换。</p><a id="more"></a><p>在 VapourSynth 社区中，原生的色调映射滤镜/脚本有两个，一个<a href="https://github.com/ifb/vapoursynth-tonemap" target="_blank" rel="noopener">滤镜</a>、一个<a href="https://github.com/age1988/vapoursynth-tonemapping" target="_blank" rel="noopener">脚本</a>，另外还有基于 placebo 库的<a href="https://github.com/Lypheo/vs-placebo" target="_blank" rel="noopener">vs-placebo滤镜</a>，以及一个<a href="https://github.com/xyx98/my-vapoursynth-script/blob/master/xvs.py#L1087" target="_blank" rel="noopener">高级函数</a>。</p><p>这些工具中，除了基于 placebo 库的 vs-placebo，因为要用 vulkan 而我的老旧设备不支持外，其余都尝试过了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在&lt;a href=&quot;https://kiyamou.github.io/2020/02/08/ISP-learn-1/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;之前的博文&lt;/a&gt;中提到过色调映射，色调映射可以做很多事情，既包括对相机 raw 文件的亮度调整，也可以做 HDR 的转换。&lt;/p&gt;
    
    </summary>
    
    
      <category term="图像处理" scheme="http://yoursite.com/categories/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    
    
  </entry>
  
  <entry>
    <title>Retinex 算法</title>
    <link href="http://yoursite.com/2020/04/28/Retinex/"/>
    <id>http://yoursite.com/2020/04/28/Retinex/</id>
    <published>2020-04-28T08:01:38.000Z</published>
    <updated>2020-04-28T08:04:40.377Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><p>Retinex系列算法如下。</p><h4 id="SSR"><a href="#SSR" class="headerlink" title="SSR"></a>SSR</h4><p>SSR（Single-Scale Retinex）：单尺度 Retinex 算法。</p><h4 id="MSR"><a href="#MSR" class="headerlink" title="MSR"></a>MSR</h4><p>MSR（Multi-Scale Retinex）：多尺度 Retinex 算法，对多个单尺度 Retinex 的结果进行平均。</p><h4 id="MSRCP"><a href="#MSRCP" class="headerlink" title="MSRCP"></a>MSRCP</h4><p>MSRCP：色彩恢复多尺度 Retinex 算法，相当于把亮的地方压缩（变黑），而把黑的地方升高变亮。</p><h4 id="MSRCR"><a href="#MSRCR" class="headerlink" title="MSRCR"></a>MSRCR</h4><p>MSRCR（Multi-Scale Retinex with Color Restoration）：色彩恢复多尺度 Retinex 算法，在 MSRCP 的基础上会改变颜色，让颜色均衡，通常会导致画面变暗，但对于一些图像，可以避免 MSRCP 导致的色差（画面颜色过暖）问题。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;

&lt;p&gt;Retinex系列算法如下。&lt;/p&gt;
&lt;h4 id=&quot;SSR&quot;&gt;&lt;a href=&quot;#SSR&quot; class=&quot;headerlink&quot; title=&quot;SSR&quot;&gt;&lt;/a&gt;SSR&lt;/h4&gt;&lt;p&gt;SSR（Single-Scale Retinex）
      
    
    </summary>
    
    
      <category term="图像处理" scheme="http://yoursite.com/categories/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    
    
  </entry>
  
  <entry>
    <title>边缘检测</title>
    <link href="http://yoursite.com/2020/04/27/edgemasks/"/>
    <id>http://yoursite.com/2020/04/27/edgemasks/</id>
    <published>2020-04-26T19:00:48.000Z</published>
    <updated>2020-04-30T14:34:01.413Z</updated>
    
    <content type="html"><![CDATA[<p>本文翻译自 <a href="https://blog.kageru.moe/legacy/edgemasks.html" target="_blank" rel="noopener">Edge Masks</a>，原作者：<a href="https://github.com/kageru" target="_blank" rel="noopener">kageru</a>。</p><p><em>译者：“mask”的中文译名应该是“蒙版”，不太习惯这个词，于是把标题写成了边缘检测，文内还是直接用英文“mask”。</em></p><a id="more"></a><h3 id="理论、实例和解释"><a href="#理论、实例和解释" class="headerlink" title="理论、实例和解释"></a>理论、实例和解释</h3><p><em>译者：本节篇幅较长，译者添加了小标题。</em></p><p>大多数流行的算法通过卷积来衡量像素邻域变化，以确定亮度变化。卷积计算的时间复杂度为 O(n^2)，其中 n 为卷积核半径，因此卷积核在保存适当精度的前提下越小越好。卷积核半径越低，越容易受到噪声（noise）和瑕疵（artifacts）的影响。</p><p>多数算法采用 3x3 卷积核，在速度和准确性间提供了最佳平衡。例子便是 Prewitt、Sobel、Scharr 和 Kirsch 提出的算子。对于无噪声的干净信号源，也可使用 2x2 卷积（<a href="http://homepages.inf.ed.ac.uk/rbf/HIPR2/roberts.htm" target="_blank" rel="noopener">文献</a>），但目前的硬件已经能够实时处理 3x3 卷积。</p><h4 id="Sobel-算子"><a href="#Sobel-算子" class="headerlink" title="Sobel 算子"></a>Sobel 算子</h4><p>以 Sobel 算子为例，x 方向和 y 方向分别进行卷积。</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">---------------   --------------<br>|<span class="hljs-string"> -1 </span>|<span class="hljs-string"> 2 </span>|<span class="hljs-string"> -1 </span>|<span class="hljs-string">   </span>|<span class="hljs-string"> -1 </span>|<span class="hljs-string"> 0 </span>|<span class="hljs-string"> 1 </span>|<br>|<span class="hljs-string">  0 </span>|<span class="hljs-string"> 0 </span>|<span class="hljs-string">  0 </span>|<span class="hljs-string">   </span>|<span class="hljs-string">  2 </span>|<span class="hljs-string"> 0 </span>|<span class="hljs-string"> 2 </span>|<span class="hljs-string"> </span><br>|<span class="hljs-string">  1 </span>|<span class="hljs-string"> 2 </span>|<span class="hljs-string">  1 </span>|<span class="hljs-string">   </span>|<span class="hljs-string"> -1 </span>|<span class="hljs-string"> 0 </span>|<span class="hljs-string"> 1 </span>|<br>---------------   --------------<br></code></pre></td></tr></table></figure><p>用 VapourSynth 简单实现如下。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">Sobel</span><span class="hljs-params">(src)</span>:</span><br>    sx = src.std.Convolution(matrix=[<span class="hljs-number">-1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>,  <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>], saturate=<span class="hljs-literal">False</span>)<br>    sy = src.std.Convolution(matrix=[<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>,  <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>], saturate=<span class="hljs-literal">False</span>)<br>    <span class="hljs-keyword">return</span> core.std.Expr([sx, sy], <span class="hljs-string">'x y max'</span>)<br></code></pre></td></tr></table></figure><p>甚至，VapourSynth 内置了<code>core.std.Sobel</code>函数，我们不必自己写代码。</p><p>对于边缘模糊的图像，Sobel 算子的效果并不是很好。提高检测精度的一种方法是使用 8 邻域而非 4 邻域，即在邻域的 8 个方向上，或者说在 3x3 卷积核的对角线上，都将被计算。</p><h4 id="Kirsch-算子"><a href="#Kirsch-算子" class="headerlink" title="Kirsch 算子"></a>Kirsch 算子</h4><p>Russel A. Kirsch 在 1970 年提出了 Kirsch 算子（<a href="https://ddl.kageru.moe/konOJ.pdf" target="_blank" rel="noopener">文献</a>）。</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">-----------------<br>|<span class="hljs-string">  5 </span>|<span class="hljs-string">  5  </span>|<span class="hljs-string">  5 </span>|<br>|<span class="hljs-string"> -3 </span>|<span class="hljs-string">  0  </span>|<span class="hljs-string"> -3 </span>|<br>|<span class="hljs-string"> -3 </span>|<span class="hljs-string"> -3  </span>|<span class="hljs-string"> -3 </span>|<br>-----------------<br></code></pre></td></tr></table></figure><p>该卷积核会旋转 45° 以回到其原始位置。</p><p>在 VapourSynth 中并未内置 Kirsch 算子，尝试通过 VapourSynth 内置的卷积方法实现。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">kirsch</span><span class="hljs-params">(src)</span>:</span><br>    kirsch1 = src.std.Convolution(matrix=[<span class="hljs-number">5</span>,   <span class="hljs-number">5</span>,  <span class="hljs-number">5</span>, <span class="hljs-number">-3</span>,  <span class="hljs-number">0</span>, <span class="hljs-number">-3</span>, <span class="hljs-number">-3</span>, <span class="hljs-number">-3</span>, <span class="hljs-number">-3</span>])<br>    kirsch2 = src.std.Convolution(matrix=[<span class="hljs-number">-3</span>,  <span class="hljs-number">5</span>,  <span class="hljs-number">5</span>,  <span class="hljs-number">5</span>,  <span class="hljs-number">0</span>, <span class="hljs-number">-3</span>, <span class="hljs-number">-3</span>, <span class="hljs-number">-3</span>, <span class="hljs-number">-3</span>])<br>    kirsch3 = src.std.Convolution(matrix=[<span class="hljs-number">-3</span>, <span class="hljs-number">-3</span>,  <span class="hljs-number">5</span>,  <span class="hljs-number">5</span>,  <span class="hljs-number">0</span>,  <span class="hljs-number">5</span>, <span class="hljs-number">-3</span>, <span class="hljs-number">-3</span>, <span class="hljs-number">-3</span>])<br>    kirsch4 = src.std.Convolution(matrix=[<span class="hljs-number">-3</span>, <span class="hljs-number">-3</span>, <span class="hljs-number">-3</span>,  <span class="hljs-number">5</span>,  <span class="hljs-number">0</span>,  <span class="hljs-number">5</span>,  <span class="hljs-number">5</span>, <span class="hljs-number">-3</span>, <span class="hljs-number">-3</span>])<br>    kirsch5 = src.std.Convolution(matrix=[<span class="hljs-number">-3</span>, <span class="hljs-number">-3</span>, <span class="hljs-number">-3</span>, <span class="hljs-number">-3</span>,  <span class="hljs-number">0</span>,  <span class="hljs-number">5</span>,  <span class="hljs-number">5</span>,  <span class="hljs-number">5</span>, <span class="hljs-number">-3</span>])<br>    kirsch6 = src.std.Convolution(matrix=[<span class="hljs-number">-3</span>, <span class="hljs-number">-3</span>, <span class="hljs-number">-3</span>, <span class="hljs-number">-3</span>,  <span class="hljs-number">0</span>, <span class="hljs-number">-3</span>,  <span class="hljs-number">5</span>,  <span class="hljs-number">5</span>,  <span class="hljs-number">5</span>])<br>    kirsch7 = src.std.Convolution(matrix=[ <span class="hljs-number">5</span>, <span class="hljs-number">-3</span>, <span class="hljs-number">-3</span>, <span class="hljs-number">-3</span>,  <span class="hljs-number">0</span>, <span class="hljs-number">-3</span>, <span class="hljs-number">-3</span>,  <span class="hljs-number">5</span>,  <span class="hljs-number">5</span>])<br>    kirsch8 = src.std.Convolution(matrix=[ <span class="hljs-number">5</span>,  <span class="hljs-number">5</span>, <span class="hljs-number">-3</span>, <span class="hljs-number">-3</span>,  <span class="hljs-number">0</span>, <span class="hljs-number">-3</span>, <span class="hljs-number">-3</span>,  <span class="hljs-number">5</span>, <span class="hljs-number">-3</span>])<br>    <span class="hljs-keyword">return</span> core.std.Expr([kirsch1, kirsch2, kirsch3, kirsch4, kirsch5, kirsch6, kirsch7, kirsch8],<br>                         <span class="hljs-string">'x y max z max a max b max c max d max e max'</span>)<br></code></pre></td></tr></table></figure><p>显然，简单的复制粘贴并不是一个好主意。当然，代码可以运行。但我不是数学家，而只有数学家才能去编写优雅的代码解决这一问题。换一种思路。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">kirsch</span><span class="hljs-params">(src: vs.VideoNode)</span> -&gt; vs.VideoNode:</span><br>    w = [<span class="hljs-number">5</span>]*<span class="hljs-number">3</span> + [<span class="hljs-number">-3</span>]*<span class="hljs-number">5</span><br>    weights = [w[-i:] + w[:-i] <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">4</span>)]<br>    c = [core.std.Convolution(src, (w[:<span class="hljs-number">4</span>] + [<span class="hljs-number">0</span>] + w[<span class="hljs-number">4</span>:]), saturate=<span class="hljs-literal">False</span>) <span class="hljs-keyword">for</span> w <span class="hljs-keyword">in</span> weights]<br>    <span class="hljs-keyword">return</span> core.std.Expr(c, <span class="hljs-string">'x y max z max a max'</span>)<br></code></pre></td></tr></table></figure><p>已经好多了，先不去管可读性更强的代码。</p><p>将 Sobel mask 与 Kirsch mask 比较，后者的准确性有了明显提升。</p><p>边缘检测的精度越高，就越容易将噪点识别为边缘，可以通过事先降噪来克服上述问题。</p><p>提升精度对速度的影响可以忽略不计，对于 8bit 1080p 输入源，单纯 Sobel 算子（非 VapourSynth 内置的 Sobel 函数，因为它还包括了高通/低通滤波与缩放功能，速度更慢）速度约为 215fps，Kirsch 算子速度为 175fps。诚然，Sobel 算子也检出了许多边缘，但有些边缘不明显，需要使用<code>std.Binarize</code>增强才能达到 Kirsch 算子的效果。</p><h4 id="Canny-算法"><a href="#Canny-算法" class="headerlink" title="Canny 算法"></a>Canny 算法</h4><p>一种更复杂的边缘检测方法是 Canny 算法（译者注：<a href="http://web.archive.org/web/20130218131253/http://bengal.missouri.edu/~kes25c/" target="_blank" rel="noopener">tritical</a> 在 AviSynth 框架下实现了 Canny 算法，被称为 TCanny 滤镜），这种算法使用类似的方法检测边缘，并将边缘的宽度缩小至 1 个像素。理想情况下，这些线条代表边缘的中部，且没有边缘被重复标记。此外，算法会进行高斯模糊，以降低噪声干扰（译者注：高斯模糊是前处理，在施加边缘检测算子之前）。一个例子如下。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">core.tcanny.TCanny(op=<span class="hljs-number">1</span>, mode=<span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><p>其中，<code>op=1</code>表示使用一种改进的算子，具有更好的信噪比。</p><p>下面是使用 5x5 卷积核的例子。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">src.std.Convolution(matrix=[<span class="hljs-number">1</span>,  <span class="hljs-number">2</span>,  <span class="hljs-number">4</span>,  <span class="hljs-number">2</span>, <span class="hljs-number">1</span>,<br>                            <span class="hljs-number">2</span>, <span class="hljs-number">-3</span>, <span class="hljs-number">-6</span>, <span class="hljs-number">-3</span>, <span class="hljs-number">2</span>,<br>                            <span class="hljs-number">4</span>, <span class="hljs-number">-6</span>,  <span class="hljs-number">0</span>, <span class="hljs-number">-6</span>, <span class="hljs-number">4</span>,<br>                            <span class="hljs-number">2</span>, <span class="hljs-number">-3</span>, <span class="hljs-number">-6</span>, <span class="hljs-number">-3</span>, <span class="hljs-number">2</span>,<br>                            <span class="hljs-number">1</span>,  <span class="hljs-number">2</span>,  <span class="hljs-number">4</span>,  <span class="hljs-number">2</span>, <span class="hljs-number">1</span>], saturate=<span class="hljs-literal">False</span>)<br></code></pre></td></tr></table></figure><p>这是尝试通过边缘检测创建边缘 mask。进过一些后处理，可以用于去取 halo 或者清理线条（尽管可以使用其他方法配合常规 mask（或许更好），比如<code>std.Maximum</code>或者<code>std.Expr</code>）。</p><h3 id="边缘-mask-的使用"><a href="#边缘-mask-的使用" class="headerlink" title="边缘 mask 的使用"></a>边缘 mask 的使用</h3><p>我们已经了解了基础知识，来看一下实际应用。目前大多数视频仍为 8bit，几乎不可避免地会产生色带（banding）。正如我在之前提到的，恢复（restoration）滤镜会引入新的瑕疵。在去色带时，细节也随之损失。进一步地，加大去色带力度，则会导致图像模糊。边缘 mask 用于修补上述副作用，实际过程为先让去色带滤镜进行去色带操作，然后使用边缘 mask 识别边缘与细节，并通过<code>std.MaskedMerge</code>恢复。</p><p>GradFun3 滤镜会在内部生成 mask，完成上述操作。另一个流行的去色带滤镜 f3kdb 则没有内置 mask 功能。</p><p>举个例子，单纯地进行去色带会破坏纹理（details，在这一语境下译为纹理比细节更合适），特别是暗场纹理。在这种情况下使用 Sobel 算子进行边缘检测，效果不好。</p><p>为了更好地识别暗场区域，使用 Retinex 算法进行局部对比度增强。</p><p>借助 Retinex 算法降低对比度，低对比度下我们能在暗场看到更丰富的内容。也许有人认为这些原本看不到的暗场细节没有意义，但随着 HDR 显示器的推广，普通观众也能看到这些细节。同时暗场细节不会占用过多码率，所以我认为保留它们没有什么坏处。</p><p>利用这些新知识，一些测试和一点点魔法，我们得到的 mask 准确性之高出乎意料。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">retinex_edgemask</span><span class="hljs-params">(luma, sigma=<span class="hljs-number">1</span>)</span>:</span><br>    ret = core.retinex.MSRCP(luma, sigma=[<span class="hljs-number">50</span>, <span class="hljs-number">200</span>, <span class="hljs-number">350</span>], upper_thr=<span class="hljs-number">0.005</span>)<br>    <span class="hljs-keyword">return</span> core.std.Expr([kirsch(luma), ret.tcanny.TCanny(mode=<span class="hljs-number">1</span>, sigma=sigma).std.Minimum(coordinates=[<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>])], <span class="hljs-string">'x y +'</span>)<br></code></pre></td></tr></table></figure><p>进一步地，借助<code>std.Binarize</code>（或类似的高通/低通函数），以及<code>std.Maximum</code>、<code>std.Inflate</code>的单独/组合调用。我们可以把这一 mask 变成适用性更强的 mask，以应用于去色带或者其他需要精确 mask 的场合。</p><h3 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h3><p>绝大部分边缘检测算法均为简单的卷积运算，在 HD 源上使用也能达到 100fps 以上的速度，像 Retinex 这样复杂的算法当然不能与之相比。虽然使用 Sobel 算子进行简单的边缘检测，速度能超过 200fps，但组合 Retinex 算法后仅为 25 fps。速度瓶颈在 Retinex 算法上，单独使用 Retinex 算法速度约为 36.6fps。一种类似但低精度的暗场增强方法为调整亮度曲线，以暴露低对比度的边缘。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">bright = core.std.Expr(src, <span class="hljs-string">'x 65535 / sqrt 65535 *'</span>)<br></code></pre></td></tr></table></figure><p>理论上，可以通过调整亮度来改善暗场区域的边缘检测效果。</p><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>数十年来，边缘检测一直是图像处理的强大工具，可以缩减图像处理的范围，助推图像分析。在视频处理中同样有重要作用，可以最大限度地降低的副作用与瑕疵。通过卷积可以快速而准确地建立边缘 mask，并且可以通过调整内核参数来自定义卷积，以用于不同目的。此外，还可以通过局部对比度增强来提高检测精度，虽然速度会慢得多。</p><p>文中提到的代码可以在<a href="https://github.com/Irrational-Encoding-Wizardry/kagefunc/blob/master/kagefunc.py" target="_blank" rel="noopener">这里</a>找到。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文翻译自 &lt;a href=&quot;https://blog.kageru.moe/legacy/edgemasks.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Edge Masks&lt;/a&gt;，原作者：&lt;a href=&quot;https://github.com/kageru&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;kageru&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;译者：“mask”的中文译名应该是“蒙版”，不太习惯这个词，于是把标题写成了边缘检测，文内还是直接用英文“mask”。&lt;/em&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="图像处理" scheme="http://yoursite.com/categories/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    
    
      <category term="VapourSynth" scheme="http://yoursite.com/tags/VapourSynth/"/>
    
  </entry>
  
  <entry>
    <title>解释 RemoveGrain</title>
    <link href="http://yoursite.com/2020/04/27/explaining-removegrain/"/>
    <id>http://yoursite.com/2020/04/27/explaining-removegrain/</id>
    <published>2020-04-26T17:22:04.000Z</published>
    <updated>2020-04-26T17:23:47.633Z</updated>
    
    <content type="html"><![CDATA[<p>本文翻译自 <a href="https://blog.kageru.moe/legacy/removegrain.html" target="_blank" rel="noopener">Actually Explaining RemoveGrain</a>，原作者：<a href="https://github.com/kageru" target="_blank" rel="noopener">kageru</a>。</p><a id="more"></a><h3 id="Mode-11-与-12"><a href="#Mode-11-与-12" class="headerlink" title="Mode 11 与 12"></a>Mode 11 与 12</h3><p>Mode 11 与 12 等价于</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">std.Convolution(matrix=[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>])<br></code></pre></td></tr></table></figure><p>Mode 11 和 Mode 12 没有区别，从代码上看是复制过来的，下面的测试也证明了这一点。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">&gt;&gt;&gt; d = core.std.<span class="hljs-constructor">Expr([<span class="hljs-params">clip</span>.<span class="hljs-params">rgvs</span>.RemoveGrain(<span class="hljs-params">mode</span>=11)</span>,<br>clip.rgvs.<span class="hljs-constructor">RemoveGrain(<span class="hljs-params">mode</span>=12)</span>], 'x y - abs')<br>&gt;&gt;&gt; d = d.std.<span class="hljs-constructor">PlaneStats()</span><br>&gt;&gt;&gt; d.get<span class="hljs-constructor">_frame(0)</span>.props.PlaneStatsAverage<br><span class="hljs-number">0.0</span><br></code></pre></td></tr></table></figure><p>但这两种模式与对应的卷积操作存在细微差别。</p><p><strong>Edit</strong>：这也可能是 VapourSynth-R36 中已修复的 PlaneStats bug 导致的，因为 0.05 的误差确实太大了。</p><p>（译者注：应该是 bug 导致的，在 VapourSynth-R49 中测试没有差别，下述结果为译者测试结果）</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs stylus">&gt;&gt;&gt; d = core<span class="hljs-selector-class">.std</span><span class="hljs-selector-class">.Expr</span>([src<span class="hljs-selector-class">.rgvs</span><span class="hljs-selector-class">.RemoveGrain</span>(mode=<span class="hljs-number">12</span>),<br>src<span class="hljs-selector-class">.std</span><span class="hljs-selector-class">.Convolution</span>(matrix=[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>])], <span class="hljs-string">'x y - abs'</span>)<br>&gt;&gt;&gt; d = d<span class="hljs-selector-class">.std</span><span class="hljs-selector-class">.PlaneStats</span>()<br>&gt;&gt;&gt; d.get_frame(<span class="hljs-number">0</span>)<span class="hljs-selector-class">.props</span><span class="hljs-selector-class">.PlaneStatsAverage</span><br><span class="hljs-number">0.0</span><br></code></pre></td></tr></table></figure><p>VapourSynth 内置的卷积滤镜通过插值处理边缘，而 RemoveGrain 则不处理边缘。</p><h3 id="Mode-13-16"><a href="#Mode-13-16" class="headerlink" title="Mode 13 - 16"></a>Mode 13 - 16</h3><p>这些模式为场内插值，速度非常快，但也非常不精确，类似粗制滥造的 EEDI。没有必要使用这些模式（EEDI2 于2005年发布，无论是这些模式还是 EEDI 都没必要使用）。</p><h3 id="Mode-17"><a href="#Mode-17" class="headerlink" title="Mode 17"></a>Mode 17</h3><blockquote><p>Clips the pixel with the minimum and maximum of respectively the maximum and minimum of each pair of opposite neighbour pixels.</p></blockquote><p>听上去可能有些困惑，但描述得很准确。这一模式会创建一个数组，包含极小值（lower）和极大值（upper），然后将中心像素限制在极大值的最小数和极小值的最大数之间。</p><h3 id="Mode-21-与-22"><a href="#Mode-21-与-22" class="headerlink" title="Mode 21 与 22"></a>Mode 21 与 22</h3><h4 id="Mode-21"><a href="#Mode-21" class="headerlink" title="Mode 21"></a>Mode 21</h4><p>中心像素替换为周围四对数字的最大值与最小值的均值。</p><h4 id="Mode-22"><a href="#Mode-22" class="headerlink" title="Mode 22"></a>Mode 22</h4><p>与 Mode 21 类似，但近似方式不同，比 Mode 21 更快。</p><h3 id="Mode-23-与-24"><a href="#Mode-23-与-24" class="headerlink" title="Mode 23 与 24"></a>Mode 23 与 24</h3><p>我难以解释这两个模式，也不知道这两个模式有什么用，如果想了解建议阅读代码。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文翻译自 &lt;a href=&quot;https://blog.kageru.moe/legacy/removegrain.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Actually Explaining RemoveGrain&lt;/a&gt;，原作者：&lt;a href=&quot;https://github.com/kageru&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;kageru&lt;/a&gt;。&lt;/p&gt;
    
    </summary>
    
    
      <category term="图像处理" scheme="http://yoursite.com/categories/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    
    
      <category term="VapourSynth" scheme="http://yoursite.com/tags/VapourSynth/"/>
    
      <category term="Avisynth" scheme="http://yoursite.com/tags/Avisynth/"/>
    
  </entry>
  
  <entry>
    <title>Grain 与 Noise</title>
    <link href="http://yoursite.com/2020/04/26/grain-and-noise/"/>
    <id>http://yoursite.com/2020/04/26/grain-and-noise/</id>
    <published>2020-04-26T12:16:10.000Z</published>
    <updated>2020-04-26T12:25:28.848Z</updated>
    
    <content type="html"><![CDATA[<p>本文翻译自 <a href="https://blog.kageru.moe/legacy/grain.html" target="_blank" rel="noopener">Grain and Noise</a>，原作者：<a href="https://github.com/kageru" target="_blank" rel="noopener">kageru</a>。</p><h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>在数字图像处理中存在多种噪声（noise）和瑕疵（artifacts），同时也有多种降噪算法。在本文中，有时将 grain 与 noise 作为同义词使用；通常而言，noise 是一种不符合预期的瑕疵，而 grain 则是为了实现某种特效——如回忆特效、模仿胶片电影颗粒感而添加，或为掩盖色带（banding）而添加。</p><p>Grain 增加了画面混乱程度，是熵增的过程，在视频编码时会导致比特率增加，特别是对于用来掩盖色带的噪点。这种比特率的增加并不能提升编码质量（梯度除外，这个问题我们会在后续讨论）。</p><p>Grain 并非都是坏的，对于消除或减弱色带而言甚至是必要的，但工业化制作时通常会使用动态 grain，这会极大地占用比特率。与此形成对比的是，采用 10bit 编码时，色带的问题并不明显，而且诸如静态 grain （如 f3kdb 的 grain）同样能实现良好的去色带效果。</p><p>有些人为获得干净的画面，喜欢降噪处理（denoise / degrain），仁者见仁智者见智。</p><a id="more"></a><h3 id="不同类型的-grain-与-noise"><a href="#不同类型的-grain-与-noise" class="headerlink" title="不同类型的 grain 与 noise"></a>不同类型的 grain 与 noise</h3><h4 id="1-回忆特效（Flashbacks）"><a href="#1-回忆特效（Flashbacks）" class="headerlink" title="1.回忆特效（Flashbacks）"></a>1.回忆特效（Flashbacks）</h4><h4 id="2-静态胶片颗粒（Constant-film-grain）"><a href="#2-静态胶片颗粒（Constant-film-grain）" class="headerlink" title="2.静态胶片颗粒（Constant film grain）"></a>2.静态胶片颗粒（Constant film grain）</h4><h4 id="3-背景噪点（Background-grain）"><a href="#3-背景噪点（Background-grain）" class="headerlink" title="3.背景噪点（Background grain）"></a>3.背景噪点（Background grain）</h4><h4 id="4-TV-横纹（TV-grain）"><a href="#4-TV-横纹（TV-grain）" class="headerlink" title="4.TV 横纹（TV grain）"></a>4.TV 横纹（TV grain）</h4><h4 id="5-其他特效噪点（Exceptional-grain）"><a href="#5-其他特效噪点（Exceptional-grain）" class="headerlink" title="5.其他特效噪点（Exceptional grain）"></a>5.其他特效噪点（Exceptional grain）</h4><h3 id="不同的降噪方法"><a href="#不同的降噪方法" class="headerlink" title="不同的降噪方法"></a>不同的降噪方法</h3><h4 id="1-基于傅里叶变换的频域降噪（如-dfttest、FFT3D）"><a href="#1-基于傅里叶变换的频域降噪（如-dfttest、FFT3D）" class="headerlink" title="1.基于傅里叶变换的频域降噪（如 dfttest、FFT3D）"></a>1.基于傅里叶变换的频域降噪（如 dfttest、FFT3D）</h4><p>dfftest 是一个较旧的滤镜，自 2007 年起开始开发，是一个很有效的滤镜，具有良好的细节保留能力，但会大幅降低速度，特别是在缺乏多线程支持的 AviSynth 下。VapourSynth 接口的 dfftest 速度更快，且有相同的效果。</p><p>FFT3DGPU 具有硬件加速功能，同样使用了频域降噪算法，速度更快，但细节保留方面精度较低，同时可能更容易导致模糊，可以通过反差补偿锐化来修补。该滤镜提供了 AviSynth 和 VapourSynth 接口，二者没有太大区别。</p><p>关键参数为<code>sigma</code>。</p><h4 id="2-非局部均值降噪（如-KNLmeans、TNLmeans）"><a href="#2-非局部均值降噪（如-KNLmeans、TNLmeans）" class="headerlink" title="2.非局部均值降噪（如 KNLmeans、TNLmeans）"></a>2.非局部均值降噪（如 KNLmeans、TNLmeans）</h4><p>非局部均值（non-local means）降噪由一系列 solid 降噪方法组成。KNLmeans 降噪滤镜基于 OpenCL 对 GPU 运算进行了高度优化，对整体图像处理速度无显著影响，这一点非常吸引人。在较旧的 AviSynth 视频处理框架下，与FFT3DGPU类似，使用GPU版 KNLmeans 还可以绕开 AviSynth 的单线程限制。因此除非无 GPU 设备，否则没有理由使用 CPU 版本（译者注：由于 KNLmeans 基于 OpenCL 进行 GPU 优化，所以在 NVIDIA、AMD、Intel 三家平台通用，很难遇上无 GPU 可用的情况，但在某些 GPU 设备上 KNLmeans 可能因 Bug 而无法使用，这时候才需要考虑 CPU 版本的 TNLmeans）。</p><p>KNLmeans 可以消除相当一部分（a lot of） noise，同时保留很多（a lot of）细节（尽管少于 dft 或 BM3D）。对于历史较久远的动画，推荐使用这一滤镜，因为这些动画往往存在很多 grain（通常是在蓝光重制时添加），但细节并不丰富。这种情况下，适合使用具有硬件加速且降噪力度大的滤镜，比起 FFT3D，KNLmeans 更加合适 。</p><p>需要注意这一滤镜的时-空混合模式（Spatio-Temporal mode），在默认设置下，AviSynth 和 VapourSynth 版本的 KNLmeans 均不使用时间参考帧，当参数<code>d</code>大于 0 时，在降噪中启用时间参考帧，开启时间参考帧可以改善质量。对于 YUV444 采样格式的视频，请将<code>cmode</code>参数设置为<code>True</code>，以开启色度平面降噪，因为在默认设置下仅对亮度平面进行处理。</p><p>上述两个参数的设置均会降低速度，但除非使用古老的 GPU 或者同时使用多个 GPU 优化的滤镜，否则不会对编码速度产生明显影响，控速步仍为 CPU 的编码过程。KNLmeans 的文档在<a href="https://github.com/Khanattila/KNLMeansCL/wiki" target="_blank" rel="noopener">这里</a>。</p><h4 id="3-三维块匹配算法（BM3D）"><a href="#3-三维块匹配算法（BM3D）" class="headerlink" title="3.三维块匹配算法（BM3D）"></a>3.三维块匹配算法（BM3D）</h4><p>BM3D 很有价值，也很慢，仅有 VapourSynth 接口。在 AviSynth 上运行可能会导致崩溃，除非大幅优化内存占用，否则很难实现 AviSynth 接口。</p><p>BM3D可以并行化并在 GPU 上运行（可参考此处的<a href="https://books.google.com/books?id=xqfNBQAAQBAJ&pg=PA380&lpg=PA380&dq=bm3d+GPU+parallel&source=bl&ots=MS9-Kzi-8u&sig=fMcblGOrD-wCUrZzijmAdQF2Tj8&hl=en&sa=X&ei=wljeVI-LKcqAywPVyILgDQ&ved=0CDQQ6AEwBA#v=onepage&q=bm3d%20GPU%20parallel&f=false" target="_blank" rel="noopener">文献</a>，译者注：BM3D 已经有诸多 GPU 版本，可以在 Github 等地方搜索到），但 AviSynth 或 VapourSynth 尚无 GPU 实现（译者注：在<a href="http://vsdb.top/plugins/bm3dgpu" target="_blank" rel="noopener">这里</a>提到了一份 VapourSynth 接口的 BM3D-GPU 实现，但原始代码库已无法获取）。</p><p>BM3D 实现了模糊程度与体积的最佳平衡（因此也导致了细节损失），但在基于 CPU 的降噪滤镜中，BM3D 是速度最慢的。</p><p>值得注意的是，BM3D 滤镜有一个<code>ref</code>参数，用以设定降噪时的参考视频，可以将<code>ref</code>设定为其他降噪滤镜的处理结果，从而实现 BM3D 与其他降噪滤镜的协同处理。在 BM3D <a href="https://github.com/HomeOfVapourSynthEvolution/VapourSynth-BM3D" target="_blank" rel="noopener">文档</a>中有如下举例：</p><blockquote><p>使用自定义降噪滤镜作为基础降噪结果，并使用V-BM3D的最终降噪函数做精细化处理</p><p>这样做可以在两种降噪滤镜间取长补短。在下面的例子中，SMDegrain滤镜在时空平滑上很有效，但可能导致鬼影（blending）和细节损失，V-BM3D可以很好地保留细节，但对于大的噪声pattern（例如粗颗粒）效果不好</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">src = core.bm3d.RGB2OPP(src)<br>ref = haf.SMDegrain(src)<br>flt = core.bm3d.VFinal(src, ref, radius=<span class="hljs-number">1</span>, matrix=<span class="hljs-number">100</span>).bm3d.VAggregate(radius=<span class="hljs-number">1</span>)<br>flt = core.bm3d.OPP2RGB(flt)<br></code></pre></td></tr></table></figure></blockquote><p>最关键的参数为<code>sigam</code>，可以为不同平面设定不同的数值。</p><h4 id="4-SMDegrain"><a href="#4-SMDegrain" class="headerlink" title="4.SMDegrain"></a>4.SMDegrain</h4><p>SMDegrain 似乎是很多人降噪的首选，因为它不会导致过多的模糊，而且降噪效果似乎弱到对图像没有明显影响，不会明显改变文件体积。</p><p>较弱的降噪效果也能使（因降噪而暴露的）色带更少，这在希望保留细节而不太考虑比特率的情况下很有用。</p><p>与此同时，即使不在降噪后进行反差补偿锐化，SMDegrain 似乎也可以对某些边缘起到收线/细化线条的效果。</p><p>需要注意的是，SMDegrain 在处理色度平面时可能会带来副作用，AviSynth Wiki 描述如下：</p><blockquote><p>注意在<code>plane=1-4</code>时色度平面可能会产生色度鬼影，这种情况下建议在空域中处理色度平面。</p></blockquote><p>事实上，这可以通过将多个帧模糊为单个帧进行修补。</p><h4 id="5-基于卷积神经网络的-Waifu2x"><a href="#5-基于卷积神经网络的-Waifu2x" class="headerlink" title="5.基于卷积神经网络的 Waifu2x"></a>5.基于卷积神经网络的 Waifu2x</h4><p>Waifu2x 使用深度卷积神经网络进行超分辨率与降噪，听上去很棒但需要大量算力。在图形处理器上使用 Waifu2x 对 720p 视频进行降噪，其速度可能低于 1fps（译者注：Waifu2x 进行了更新，见下文的<strong>Edit</strong>）。降噪有三种级别可供选择，2 级和 3 级降噪难以保留细节，无法使用，1 级降噪可以恰当地去除 grain，但细节的保留程度可能与输入源关系很大，且无法调节。因此在使用中，要么接受 Waifu2x 单一模式的降噪结果（而且这还可能是最慢的算法），要么换用其他降噪滤镜（译者注：Waifu2x 进行了更新，见下文的<strong>Edit</strong>）。</p><p>基于深度神经网络的算法还有很多（如<a href="https://www.researchgate.net/publication/300688682_Deep_Gaussian_Conditional_Random_Field_Network_A_Model-Based_Deep_Network_for_Discriminative_Denoising" target="_blank" rel="noopener">文献</a>），但多数未公开算法。</p><p>对于动画风格的图像使用 Waifu2x 进行降噪没有问题，但对于真实图像，其纹理可能被识别为噪点，进而被破坏。</p><p><strong>Edit</strong>：在写完本节后，Waifu2x 进行了重大升级，速度进一步提升，并且在降噪功能上提供了更多选项。</p><h4 id="6-去色带（Debanding）"><a href="#6-去色带（Debanding）" class="headerlink" title="6.去色带（Debanding）"></a>6.去色带（Debanding）</h4><h3 id="Grain-编码"><a href="#Grain-编码" class="headerlink" title="Grain 编码"></a>Grain 编码</h3>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文翻译自 &lt;a href=&quot;https://blog.kageru.moe/legacy/grain.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Grain and Noise&lt;/a&gt;，原作者：&lt;a href=&quot;https://github.com/kageru&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;kageru&lt;/a&gt;。&lt;/p&gt;
&lt;h3 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h3&gt;&lt;p&gt;在数字图像处理中存在多种噪声（noise）和瑕疵（artifacts），同时也有多种降噪算法。在本文中，有时将 grain 与 noise 作为同义词使用；通常而言，noise 是一种不符合预期的瑕疵，而 grain 则是为了实现某种特效——如回忆特效、模仿胶片电影颗粒感而添加，或为掩盖色带（banding）而添加。&lt;/p&gt;
&lt;p&gt;Grain 增加了画面混乱程度，是熵增的过程，在视频编码时会导致比特率增加，特别是对于用来掩盖色带的噪点。这种比特率的增加并不能提升编码质量（梯度除外，这个问题我们会在后续讨论）。&lt;/p&gt;
&lt;p&gt;Grain 并非都是坏的，对于消除或减弱色带而言甚至是必要的，但工业化制作时通常会使用动态 grain，这会极大地占用比特率。与此形成对比的是，采用 10bit 编码时，色带的问题并不明显，而且诸如静态 grain （如 f3kdb 的 grain）同样能实现良好的去色带效果。&lt;/p&gt;
&lt;p&gt;有些人为获得干净的画面，喜欢降噪处理（denoise / degrain），仁者见仁智者见智。&lt;/p&gt;
    
    </summary>
    
    
      <category term="图像处理" scheme="http://yoursite.com/categories/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    
    
      <category term="VapourSynth" scheme="http://yoursite.com/tags/VapourSynth/"/>
    
      <category term="Avisynth" scheme="http://yoursite.com/tags/Avisynth/"/>
    
  </entry>
  
  <entry>
    <title>gcc 10尝鲜及后续</title>
    <link href="http://yoursite.com/2020/04/08/gcc-use-2/"/>
    <id>http://yoursite.com/2020/04/08/gcc-use-2/</id>
    <published>2020-04-08T09:30:49.000Z</published>
    <updated>2020-04-09T05:14:35.988Z</updated>
    
    <content type="html"><![CDATA[<p>在<a href="https://github.com/sekrit-twc/zimg" target="_blank" rel="noopener">zimg项目</a>的Issue中看到这样一个问题，使用gcc 10编译出现了编译器把<code>size_t</code>错认成<code>std::size_t</code>，从而导致编译出错。看到这个问题有点惊讶，gcc居然都出到10了，支持了C++20的一些新特性，便想尝试一下。</p><p>看了gcc官网，10版本还没发布编译好的版本，想了一下，比起自己编译，还是装个新版的Fedora系统更省事一点。</p><a id="more"></a><h3 id="收集各种Linux发行版"><a href="#收集各种Linux发行版" class="headerlink" title="收集各种Linux发行版"></a>收集各种Linux发行版</h3><p>说起来我也是用过复数个Linux发行版的人了，不再像一年前那样懵懂，能够比较从容地折腾这些发行版了。</p><p>Fedora也是用yum管理依赖包，这才让我想起“我眼中的各Linux发行部用户”那张图。</p><p><img src="https://i.loli.net/2020/04/08/wRYn7JoMeLNOsbq.jpg" srcset="/img/loading.gif" lazyload alt=""><br><img src="https://i.loli.net/2020/04/09/7GU1I5z9oOJX3rL.jpg" srcset="/img/loading.gif" lazyload alt=""></p><blockquote><p>fedora：红帽子家养的小白鼠无误，有什么新想(nao)法(dong)都先往fedora上招呼<br>Archlinux：战斗机，很厉害，B格很高<br>ubuntu：吉祥物，用自己的种种行为卖傻卖萌，负责Linux桌面推广，人民群众喜闻乐见，实际上没有卵用<br>redhat：我是负责服务器的工程师<br>CentOS：我是楼上那个工程师的影分身<br>gentoo linux：相比Arch这个战斗机，我已然冲出大气层<br>openSUSE：YAST就是你的专职妹抖，用♂过都说好<br>Slackware：祖宗之法大于天（任何用户都应该自己解决包依赖）<br>debian：看过动画《轻音少女》的都知道，姐姐没有妹妹来照料起居，基本就活不下去……<br>Mint：ヨーロッパ是欧洲的意思，这表示Mint是Ubuntu偷渡欧洲了？</p></blockquote><p>以上转自<a href="https://www.zhihu.com/question/22605825/answer/76171890" target="_blank" rel="noopener">Kan Kikou@知乎</a></p><h4 id="Fedora"><a href="#Fedora" class="headerlink" title="Fedora"></a>Fedora</h4><p>我对Fedora的感觉</p><ul><li>用和ArchLinux一样的GNOME桌面</li><li>用和CentOS/RedHat一样的yum包管理</li><li>工具都是最新的</li></ul><p>不过这倒是挺符合我的胃口，毕竟我就是从CentOS转到ArchLinux的。</p><p>回到Fedora本身，一开始用workstation版本，感觉对新手异常友好。但Fedora 31还没问题，Fedora 32一进入安装界面就出现诡异的花屏。然而Fedora 31也没有gcc 10啊，遂转用network install版本。</p><p>倒是挺顺利，只是忘了装桌面…嘛，反正也用不上，而且Fedora的命令行界面比ArchLinux要好多了，有彩色文字，还能占满整个屏幕，不像ArchLinux无法自适应分辨率，只有屏幕中央800x600的一小块。</p><h4 id="Linux-Mint"><a href="#Linux-Mint" class="headerlink" title="Linux Mint"></a>Linux Mint</h4><p>上面那组图真是万能，这Mint完全就是Ubuntu套个壳Windows UI的壳…更神奇的时，命令行工具长得和cmder好像…</p><p>安装过程比Fedora还傻瓜，但这也不好，没法选择基础工具的安装，比如后文中我就遇到了缺少<code>python3-dev</code>的问题。</p><h3 id="基础设施"><a href="#基础设施" class="headerlink" title="基础设施"></a>基础设施</h3><p>一开始用的Fedora桌面版，很多东西都没装；之后用命令行版，倒是因为勾选齐全，可以开箱即用。</p><p>重点记一下Fedora桌面版在使用gcc编译前的一些工作。</p><p>编译zimg的流程如下，和编译VapourSynth一样。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">./autogen.sh<br>./configure<br>make<br>make install<br></code></pre></td></tr></table></figure><p>在此之前，需要安装</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-built_in">auto</span>conf<br><span class="hljs-built_in">auto</span>make<br>make<br>libtool<br>gcc-c++<br></code></pre></td></tr></table></figure><p>逐个说一下</p><ul><li>无autoconf，<code>autogen.sh</code>脚本无法运行</li><li>无automake，运行<code>autogen.sh</code>报错缺少<code>aclocal</code>。</li><li>无make，呃…这个你懂的</li><li>无libtool，在执行<code>make</code>命令时，报错<figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs subunit"><span class="hljs-keyword">error: </span>Libtool library used but 'LIBTOOL' is undefined<br></code></pre></td></tr></table></figure></li><li>无gcc-c++，在执行<code>make</code>命令时，报错<figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs subunit"><span class="hljs-keyword">error: </span>A compiler with support for C+<span class="hljs-string">+11</span> language features is required.<br></code></pre></td></tr></table></figure></li></ul><h3 id="基础设施Plus"><a href="#基础设施Plus" class="headerlink" title="基础设施Plus"></a>基础设施Plus</h3><h4 id="构建与编译工具"><a href="#构建与编译工具" class="headerlink" title="构建与编译工具"></a>构建与编译工具</h4><p>回看之前的<a href="https://kiyamou.github.io/2020/03/11/build-vapoursynth/" target="_blank" rel="noopener">编译VapourSynth的博文</a>，才记起之前接触过autoconf、automake、libtool。这才意识到，autoconf和automake是用于构建的通用工具，而libtool则是编译依赖。</p><p><code>gcc-c++</code>是红帽家（CentOS、RedHat、Fedora）yum包管理器中的名字，在Ubuntu、Mint系的apt-get下叫<code>g++</code>。</p><p>在Linux Mint下编译VapourSynth，报错</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-function"><span class="hljs-title">checking</span></span> <span class="hljs-keyword">for</span> PYTHON3... <span class="hljs-keyword">no</span><br><span class="hljs-function"><span class="hljs-title">checking</span></span> <span class="hljs-keyword">for</span> PYTHON3... <span class="hljs-keyword">no</span><br>configure: error: Package requirements (python<span class="hljs-number">-3.6</span>) were <span class="hljs-keyword">not</span> met:<br><span class="hljs-keyword">No</span> package <span class="hljs-string">'python-3.6'</span> found<br></code></pre></td></tr></table></figure><p>这是因为缺少<code>python3-dev</code>，在红帽家的yum系中叫<code>python3-devel</code>。</p><h4 id="关于zimg"><a href="#关于zimg" class="headerlink" title="关于zimg"></a>关于zimg</h4><p>在ArchLinux下，居然能用pacman安装zimg，我记得我在ArchLinux编译VapourSynth没有编译zimg的过程，就是通过pacman安装的。</p><p>顺带，这里有必要区分下zimg。我自己所提到的zimg，包括这篇博文与之前编译VapourSynth时用的，都是指<a href="https://github.com/sekrit-twc/zimg" target="_blank" rel="noopener">sekrit-twc/zimg</a>项目，这是图像处理库，提供了位深转换、色彩空间转换、缩放功能，ArchLinux的pacman包管理器提供的zimg，也是指这个；而在另一些语境下，zimg则是指<a href="https://github.com/buaazp/zimg" target="_blank" rel="noopener">buaazp/zimg</a>，这是图像存储与处理系统。</p><h3 id="回到size-t"><a href="#回到size-t" class="headerlink" title="回到size_t"></a>回到<code>size_t</code></h3><p>这次的折腾缘起于上面Issue中gcc 10对<code>size_t</code>报错，但我尝试之后，没有报错…</p><p>于是搜了一下类似的报错（自定义了类型<code>size_t</code>，却被编译器认为是<code>std::size_t</code>忘了写<code>std</code>），原来由来已久，我还以为的gcc 10支持了什么新特性，导致代码冲突呢…</p><p>搜了下，也是一笔糊涂账，可能是编译环境中有什么问题导致的，先不管了…</p><p>写完才发现跑题了…那我也溜了吧…Orz</p><h3 id="Makefile相关"><a href="#Makefile相关" class="headerlink" title="Makefile相关"></a>Makefile相关</h3><p>既然跑题了，再塞点东西。</p><p>根据这篇博文<a href="https://blog.csdn.net/fzy0201/article/details/17427761" target="_blank" rel="noopener">Makefile/Makefile.am/Makefile.in三者关系</a>，可以梳理一下使用make构建和编译的流程。</p><ol><li><p>创建工作目录</p></li><li><p>写代码</p></li><li><p>生成<code>configure</code></p><ul><li>在zimg中借助脚本，也就是这样一行命令<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">autoreconf --verbose --install --force<br></code></pre></td></tr></table></figure></li><li>手动的话要借助<code>aclocal</code>和<code>autoconf</code>命令，分别会产生<code>aclocal.m4</code>及<code>configure</code></li></ul></li><li><p>写<code>Makefile.am</code></p></li><li><p>使用automake生成<code>Makefile.in</code></p></li><li><p>执行<code>configure</code>生成<code>Makefile</code></p></li><li><p>执行<code>make</code>编译</p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在&lt;a href=&quot;https://github.com/sekrit-twc/zimg&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;zimg项目&lt;/a&gt;的Issue中看到这样一个问题，使用gcc 10编译出现了编译器把&lt;code&gt;size_t&lt;/code&gt;错认成&lt;code&gt;std::size_t&lt;/code&gt;，从而导致编译出错。看到这个问题有点惊讶，gcc居然都出到10了，支持了C++20的一些新特性，便想尝试一下。&lt;/p&gt;
&lt;p&gt;看了gcc官网，10版本还没发布编译好的版本，想了一下，比起自己编译，还是装个新版的Fedora系统更省事一点。&lt;/p&gt;
    
    </summary>
    
    
      <category term="工具使用" scheme="http://yoursite.com/categories/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"/>
    
    
      <category term="构建与编译" scheme="http://yoursite.com/tags/%E6%9E%84%E5%BB%BA%E4%B8%8E%E7%BC%96%E8%AF%91/"/>
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>JincResize 代码重构（3）</title>
    <link href="http://yoursite.com/2020/03/23/rebuild-JincResize-3/"/>
    <id>http://yoursite.com/2020/03/23/rebuild-JincResize-3/</id>
    <published>2020-03-23T05:08:38.000Z</published>
    <updated>2020-05-01T15:05:26.529Z</updated>
    
    <content type="html"><![CDATA[<p>JincResize avs版迁移工作告一段落了，速度比之前快了5-6倍，在这个过程中学到了C/C++结构、C++类和对象（特别是通过调用构造函数、公有函数实现抽象）、C++内存对齐与回收的知识，对堆栈有了初步的概念，同时对程序整体设计有了大致的概念。</p><p>当修改好readme，发布了JincResize-r7-RC1，再来回看commit历史，有些感动。在这一周的时间中，有些印象很深的改动，都忘记了是早期的几天就完成的；而同时在最初的几天，以现在的视角看，更多的是四处尝试，像在黑暗中一样，但最终是看到了光亮。</p><a id="more"></a><p>如果说早期的coding是崎岖但知道方向；那么中期之后，在我得到一份能看到结果、但带有问题的代码时，再往前走，就有些戏剧性了。虽然通过Debug找到一些改正的线索，但还不够，真要靠一些运气才走下去的。当时主要是为了在实际代码中应用一下类，其实不用类完全也可以实现当时预想的目的。在这个过程中学到基础知识且不提，在把计算Lut（Look up table）的过程放到Lut类后，我突然意识到，把整个计算好的Lut表传给函数，（占用了过多内存），可能是导致编译好dll调用一次就崩溃的原因。这时我才明白avs版代码为什么要封装一个函数，Lut表中的数据随用随调。虽然是仿写，但我自己能独立想到原因，这也是值得欣喜的。之后又经历了一两天的折腾，才明白怎么去正确地初始化变量。终于不崩溃了。</p><p>虽然还有一个bug未解决，但这两三天也为此花了不少时间，该放下就放下，先告一段落吧，这一周的工作已经收获很多了。</p><p>要学会发现和留住成就感，这是增加自信的一种方式。</p><h3 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h3><p><code>_aligned_malloc()</code>、<code>_aligned_free()</code>是微软提出的动态申请、释放内存对齐函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">void</span>* _aligned_malloc(<span class="hljs-keyword">size_t</span> size, <span class="hljs-keyword">size_t</span> alignment);<br><span class="hljs-keyword">void</span>* _aligned_free(<span class="hljs-keyword">void</span>* memblock);<br></code></pre></td></tr></table></figure><p>Examples：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">_aligned_malloc(array_size * <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">float</span>), <span class="hljs-number">64</span>);<br>_aligned_free(<span class="hljs-built_in">array</span>);<br></code></pre></td></tr></table></figure><p>Windows下的gcc编译器也可以接受上述函数，但Linux下的gcc编译器就不行了。</p><p>Linux下的通用替代方法且不提，在VapourSynth下有专门的替代函数<code>vs_aligned_malloc()</code>、<code>vs_aligned_free()</code>，用法和前面的原始函数一样（虽然就是给Linux下的相应函数起个别名，但毕竟方便很多）。</p><h3 id="从结构到类"><a href="#从结构到类" class="headerlink" title="从结构到类"></a>从结构到类</h3><p>这次迁移了AviSynth版JincResize中的EWA（椭圆加权平均）重采样方法，关于算法本身的疑问先放一下（因为我还是觉得，AviSynth版用的重采样也是通过圆划定范围、进行计算，而非椭圆——虽然直观时上觉得，干脆用椭圆的长轴长为半径画圆不是更精确吗？或许椭圆本身能减少不太必要的计算？），在实现算法时，设计了两个类，一个（辅助的）类用来存放重采样/反向映射用的圆/椭圆半径、指针移动相关的数据，另一个类用来存放传递过来的核心Lut表及其他辅助数据（包括前一个类）。</p><p>以上这些都是常规设计，但计算时的函数调用，让我感觉把结构改成类，或许看上去更C++一点。</p><p>如果就是单独存一些数据，那似乎是没必要把结构写成类，但类似构造函数的初始化、计算，类似析构函数的内存释放都出来了，而且就单独写一个函数放在头文件里，可能写成类和成员函数看上去更舒服一点。</p><p>带着这种想法，我打算先把主cpp中计算Lut表的过程单独拿出来写成类（至于上面提到的EWA重采样过程，既然结构已经完善，先这样放着吧）。具体的过程，写几个私有变量、构造函数、Lut计算函数、空的析构函数，再写一个销毁数组释放内存的函数，大概就OK了。</p><p>调用，用new方法新建一个Lut对象（实际操作为创建一个数组），将Lut计算函数作用于该对象（由于数组用new方法创建，所以用指针运算符<code>-&gt;</code>访问成员函数），将lut数组定义为Lut类的公有变量，在主cpp里调用lut数组，传递给后续函数（commit <a href="https://github.com/Kiyamou/VapourSynth-JincResize/commit/8fbcfdc1797f7209997eaee3aea8c898ef755f28" target="_blank" rel="noopener"><code>8fbcfdc</code></a>）。</p><h3 id="不要一次都塞进来"><a href="#不要一次都塞进来" class="headerlink" title="不要一次都塞进来"></a>不要一次都塞进来</h3><p>在当时，代码存在一个问题，虽然能正常运行，但只能运行一次，每次关闭vsedit的预览窗口，再打开，就会崩溃。</p><p>我想到，现在把计算Lut表的过程封装/抽象成类，但本质上和之前没有区别，还是把整个lut数组传递给函数，这可能导致内存泄漏，可能是导致崩溃的原因。</p><p>同时，我发现我在写构造函数、创建lut数组时，没有确定数组长度，像下面这样。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">int</span> lut_size;<br>    <span class="hljs-keyword">double</span> radius;<br>    <span class="hljs-keyword">double</span> blur;<br>&#125;;<br><br>Lut::Lut()<br>&#123;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> defined(_MSC_VER)</span><br>    lut = <span class="hljs-keyword">new</span> <span class="hljs-keyword">double</span>[lut_size];<br><span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span><br>    lut = (<span class="hljs-keyword">double</span>*)_mm_malloc(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">double</span>) * lut_size, <span class="hljs-number">64</span>);<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br>&#125;<br></code></pre></td></tr></table></figure><p>于是从两个方向入手解决。</p><ul><li><p>增加获取Lut数组的函数，这样改后应该是一次传递一个，而不是把每次都把整个数组传递过去（commit <a href="https://github.com/Kiyamou/VapourSynth-JincResize/commit/70100f24e645f5a08e912451425be0365110c934" target="_blank" rel="noopener"><code>70100f</code></a>）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">float</span> Lut::GetFactor(<span class="hljs-keyword">int</span> index)<br>&#123;<br>  <span class="hljs-keyword">return</span> (<span class="hljs-keyword">float</span>)lut[index];<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>给<code>lut_size</code>手动设定初始值（commit <a href="https://github.com/Kiyamou/VapourSynth-JincResize/commit/5fcf58470c157c1329214aaea6f7a507872c6c64" target="_blank" rel="noopener"><code>5fcf58</code></a>），虽然代码不好看，但毕竟解决问题了</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">int</span> lut_size = <span class="hljs-number">1024</span>;<br>&#125;;<br></code></pre></td></tr></table></figure></li></ul><h3 id="Debug"><a href="#Debug" class="headerlink" title="Debug"></a>Debug</h3><h4 id="基于vsedit自带的信息"><a href="#基于vsedit自带的信息" class="headerlink" title="基于vsedit自带的信息"></a>基于vsedit自带的信息</h4><p>最开始写好初版代码，编译好后，vsedit居然打不开了。于是先打开vsedit再把dll丢进去，终于看到报错信息，原来是我把python接口的<code>float</code>写成了<code>foat</code>…orz…在编译时肯定看不出来问题，在调用时肯定出问题…</p><h4 id="VS-Debug"><a href="#VS-Debug" class="headerlink" title="VS Debug"></a>VS Debug</h4><h5 id="调试方法"><a href="#调试方法" class="headerlink" title="调试方法"></a>调试方法</h5><p>在“调试”-“命令”里把vsedit的路径写进去，就可以用VS调试了。</p><p>一开始我傻傻地把gcc编译好dll丢进去，让VS调试…呃，肯定是加载不了啊。</p><h5 id="崩溃问题"><a href="#崩溃问题" class="headerlink" title="崩溃问题"></a>崩溃问题</h5><p>前面提到的<code>lut_size</code>没有初始化，就是借助VS Debug发现的。</p><h5 id="文字的Bug"><a href="#文字的Bug" class="headerlink" title="文字的Bug"></a>文字的Bug</h5><p>虽然用断点查看具体计算过程有些有趣，但对解决文字Bug没有实质性的帮助。这个问题先放一放吧。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;JincResize avs版迁移工作告一段落了，速度比之前快了5-6倍，在这个过程中学到了C/C++结构、C++类和对象（特别是通过调用构造函数、公有函数实现抽象）、C++内存对齐与回收的知识，对堆栈有了初步的概念，同时对程序整体设计有了大致的概念。&lt;/p&gt;
&lt;p&gt;当修改好readme，发布了JincResize-r7-RC1，再来回看commit历史，有些感动。在这一周的时间中，有些印象很深的改动，都忘记了是早期的几天就完成的；而同时在最初的几天，以现在的视角看，更多的是四处尝试，像在黑暗中一样，但最终是看到了光亮。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Code" scheme="http://yoursite.com/categories/Code/"/>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>Travis CI持续集成与各编译器对C++新特性的支持</title>
    <link href="http://yoursite.com/2020/03/12/CI-and-compiler/"/>
    <id>http://yoursite.com/2020/03/12/CI-and-compiler/</id>
    <published>2020-03-11T17:36:45.000Z</published>
    <updated>2020-03-11T18:13:10.896Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Travis-CI的部署"><a href="#Travis-CI的部署" class="headerlink" title="Travis CI的部署"></a>Travis CI的部署</h3><p>很早就有体验Travis CI持续集成的想法，于是拿<a href="https://github.com/Kiyamou/VapourSynth-JincResize" target="_blank" rel="noopener">VapourSynth-JincResize</a>项目试一试。</p><h4 id="依赖问题"><a href="#依赖问题" class="headerlink" title="依赖问题"></a>依赖问题</h4><p>昨天给JincResize项目照猫画虎写了<code>.travis.yml</code>脚本。一开始打算沿用我在Linux下编译的模式，基于meson+ninja构建。为此还专门去搜了Github Issues，从Issues上面抄了使用meson的<code>.travis.yml</code>脚本。</p><p>但等我上传了脚本、部署完成之后才想起，JincResize项目使用pkg-config解决依赖的问题，而配置pkg-config需要先编译VapourSynth…在服务器上编译也不是不行，但这样也太脱裤子放屁了…于是我便想不借助构建工具了，直接用gcc编译，反正我的项目结构简单。</p><a id="more"></a><p>直接用gcc编译也需要解决VapourSynth头文件的依赖，绞尽脑汁想了个略显蛋疼的办法，从VapourSynth的官方仓库中下载头文件到服务器，再移到相应位置。之所以这么折腾，而不是把需要的头文件传到JincResize项目的仓库中，是因为<del>很多其他VapourSynth的Plugin项目都不传这类通用头文件</del>不同版本VapourSynth头文件对应不同版本的VapourSynth API，API版本不同，编译出来的动态链接库没法被VapourSynth主程序调用。如果我自己向仓库传了某一版本的头文件，反而可能误导其他人。</p><p>然而VapourSynth毕竟不是一个小项目，起初想试一下git 2.25.0新增的部分克隆功能，只克隆我需要的两个头文件，但我太笨了…不会用。遂用wget下载Release中打包好的源码（体积毕竟比整个仓库小），然后再解压我想要的文件、移动。</p><h4 id="编译器版本问题"><a href="#编译器版本问题" class="headerlink" title="编译器版本问题"></a>编译器版本问题</h4><p>Travis CI服务器用的是ubuntu 16 + gcc 5，由于JincResize项目使用了C++17的特殊数学函数（<code>cyl_bessel_j()</code>），需要gcc 7及以上版本。好办，直接给服务器装gcc 7呗。</p><p>话是这么说，而且也部署成功并编译通过了，但我总觉得安装gcc 7时要把系统依赖都升级一遍（<code>sudo apt-get upgrade</code>）有点不太环保（<del>虽然Travis CI的服务器性能强劲</del>）。于是改了一下代码，当gcc版本小于7时，用传统的<code>ji()</code>函数，不涉及C++17。</p><p>总算环保地在服务器上编译通过了。</p><h3 id="各编译器对C-新特性的支持"><a href="#各编译器对C-新特性的支持" class="headerlink" title="各编译器对C++新特性的支持"></a>各编译器对C++新特性的支持</h3>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Travis-CI的部署&quot;&gt;&lt;a href=&quot;#Travis-CI的部署&quot; class=&quot;headerlink&quot; title=&quot;Travis CI的部署&quot;&gt;&lt;/a&gt;Travis CI的部署&lt;/h3&gt;&lt;p&gt;很早就有体验Travis CI持续集成的想法，于是拿&lt;a href=&quot;https://github.com/Kiyamou/VapourSynth-JincResize&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;VapourSynth-JincResize&lt;/a&gt;项目试一试。&lt;/p&gt;
&lt;h4 id=&quot;依赖问题&quot;&gt;&lt;a href=&quot;#依赖问题&quot; class=&quot;headerlink&quot; title=&quot;依赖问题&quot;&gt;&lt;/a&gt;依赖问题&lt;/h4&gt;&lt;p&gt;昨天给JincResize项目照猫画虎写了&lt;code&gt;.travis.yml&lt;/code&gt;脚本。一开始打算沿用我在Linux下编译的模式，基于meson+ninja构建。为此还专门去搜了Github Issues，从Issues上面抄了使用meson的&lt;code&gt;.travis.yml&lt;/code&gt;脚本。&lt;/p&gt;
&lt;p&gt;但等我上传了脚本、部署完成之后才想起，JincResize项目使用pkg-config解决依赖的问题，而配置pkg-config需要先编译VapourSynth…在服务器上编译也不是不行，但这样也太脱裤子放屁了…于是我便想不借助构建工具了，直接用gcc编译，反正我的项目结构简单。&lt;/p&gt;
    
    </summary>
    
    
      <category term="工具使用" scheme="http://yoursite.com/categories/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"/>
    
    
      <category term="构建与编译" scheme="http://yoursite.com/tags/%E6%9E%84%E5%BB%BA%E4%B8%8E%E7%BC%96%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title>ArchLinux下VapourSynth和VapourSynth-editor的编译与配置</title>
    <link href="http://yoursite.com/2020/03/11/build-vapoursynth/"/>
    <id>http://yoursite.com/2020/03/11/build-vapoursynth/</id>
    <published>2020-03-10T16:49:15.000Z</published>
    <updated>2020-03-10T17:52:46.523Z</updated>
    
    <content type="html"><![CDATA[<h3 id="ArchLinux安装桌面"><a href="#ArchLinux安装桌面" class="headerlink" title="ArchLinux安装桌面"></a>ArchLinux安装桌面</h3><p>参考<a href="https://www.viseator.com/2017/05/17/arch_install/" target="_blank" rel="noopener">以官方Wiki的方式安装ArchLinux</a>安装ArchLinux的基本系统。</p><p>参考<a href="https://starrycat.me/archlinux-install-gnome-desktop.html" target="_blank" rel="noopener">ArchLinux安装GNOME图形桌面环境</a>和<a href="https://www.viseator.com/2017/05/19/arch_setup/" target="_blank" rel="noopener">ArchLinux安装后的必须配置与图形界面安装教程</a>安装图形界面。</p><p>顺带提一下我的经验，若是在VMware虚拟机中安装，不要在VM下拉伸桌面，不然重启系统后黑屏…</p><h3 id="编译VapourSynth"><a href="#编译VapourSynth" class="headerlink" title="编译VapourSynth"></a>编译VapourSynth</h3><p>在之前的<a href="https://kiyamou.github.io/2020/02/07/arch-and-meson/" target="_blank" rel="noopener">一篇博文</a>中，提到了编译VapourSynth。但我不知道为什么，可能是升级了ArchLinux系统（<code>pacman -Syu</code>），导致之前编译好的用不了，只能重新编译一次。</p><a id="more"></a><h4 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h4><p>VapourSynth的必要依赖包括：</p><ul><li>构建与编译依赖<ul><li>Autoconf、Automake、Libtool</li><li>pkg-config</li><li>GCC 4.8及以上版本 或 Clang</li></ul></li><li>功能依赖<ul><li>zimg <a href="https://github.com/sekrit-twc/zimg/tree/v2.9" target="_blank" rel="noopener">v2.9分支</a> （由于新版R49增加了<code>spline64</code>，这是zimg 2.9.3新增的内容，所以要用新版）</li></ul></li><li>Python环境<ul><li>Python 3 （Python 3即可，不需要指定3.x，只有Windows下安装编译好的二进制文件时，才需要限定小版本）</li><li>Cython 0.28及以上版本</li></ul></li></ul><p>此外，还有四个可选的依赖</p><ul><li>构建文档：Sphinx</li><li>编译字幕滤镜：iconv、libass、ffmpeg</li><li>编译读写图片的Imwri滤镜：ImageMagick 7</li><li>编译OCR滤镜：Tesseract 3</li></ul><p>我感兴趣的是Imwri，而ImageMagick 7作为ArchLinux默认安装的包已经装好了。</p><p>在ArchLinux下，安装必要依赖的命令如下。</p><p>（gcc和Python 3应该是装好系统就自带了，没写。（在ArchLinux的pacman语境下，gcc指最新版的gcc（目前是9.2.1），这个应该是系统默认就安装了的，gcc8指gcc 8.x的稳定版，应该需要自己安装。））</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">pacman -S autoconf automake libtool<br>pacman -S pkg-config<br>pacman -S zimg<br><br>pip install cython<br></code></pre></td></tr></table></figure><h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><p>下载VapourSynth源码。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">git clone https://github.com/vapoursynth/vapoursynth.git<br>cd vapoursynth<br></code></pre></td></tr></table></figure><p>若担心开发中的版本不稳定，可下载打包发布的版本。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">wget https://github.com/vapoursynth/vapoursynth/archive/R49-RC1.tar.gz<br>tar -xzvf R49-RC1.tar.gz<br>cd vapoursynth-R49-RC1<br></code></pre></td></tr></table></figure><p>进行构建和编译。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">./autogen.sh<br>./configure<br>make<br>make install<br></code></pre></td></tr></table></figure><p>在这里提一下我编译时遇到的问题。我用的源码是R49-RC1版本，自带的<code>resize</code>函数新增了<code>spline64</code>，然而我在编译中报错说<code>ZIMG_RESIZE_SPLINE64</code>未声明。于是把两行相关代码注释掉（位于<code>src/core/vsresize.cpp</code>），编译通过。可能和zimg版本问题有关？我猜的。</p><p>补记：猜的没错，新版R49增加了<code>spline64</code>，这是zimg 2.9.3新增的内容。</p><p>顺带试了一下R48，因为这个版本还没有添加<code>spline64</code>，结果出现了一个通用的报错，没有去深究，放弃了。</p><h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><p>编译好后，配置搜索路径和Python环境。</p><p>编译完成，会在<code>/usr/local/lib</code>（或其他类似的文件中）得到相关<code>.so</code>库文件，包括<code>libvaoursynth.so</code>、<code>libvapoursynth-script.so.0.0.0</code>，把这些库文件链接到<code>/usr/lib</code>中，完成搜索路径的配置。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">ln -s /usr/local/lib/libvapoursynth.so /usr/lib/libvapoursynth.so<br>ln -s /usr/local/lib/libvapoursynht-script.so.0.0.0 /usr/lib/libvapoursynth-script.so<br></code></pre></td></tr></table></figure><p>配置好搜索路径，在Python中安装VapourSynth。这听上去有点怪，但根据VapourSynth的设计思路，需要先完成上面的编译和配置，才能用pip安装。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">pip install vapoursynth<br></code></pre></td></tr></table></figure><p>完成上述配置后，vsedit就能搜索到VapourSynth。</p><h3 id="编译vsedit"><a href="#编译vsedit" class="headerlink" title="编译vsedit"></a>编译vsedit</h3><h4 id="安装依赖-1"><a href="#安装依赖-1" class="headerlink" title="安装依赖"></a>安装依赖</h4><p>vsedit是基于qt的图形界面程序，需要qt5相关的依赖包。</p><p>下面列出的这个包是我个人在编译vsedit中需要的。根据官方的编译指南，需要<code>build-essential</code>、<code>qtbase5-dev</code>。但在ArchLinux下似乎不叫这两个名字，没有去深究。强行编译，发现缺少下面这个包。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">pacman -S qt5-websockets<br></code></pre></td></tr></table></figure><h4 id="配置头文件"><a href="#配置头文件" class="headerlink" title="配置头文件"></a>配置头文件</h4><p>编译时需要VapourSynth的头文件，也就是<code>vapoursynth/include</code>文件下的三个<code>.h</code>文件。在<code>/usr/include</code>中新建一个<code>vapoursynth</code>文件夹，把这三个文件复制过去即可。</p><h4 id="编译-1"><a href="#编译-1" class="headerlink" title="编译"></a>编译</h4><p>下载源码。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">git clone https://bitbucket.org/mystery_keeper/vapoursynth-editor.git<br>cd vapoursynth-editor/pro<br></code></pre></td></tr></table></figure><p>进行构建和编译。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">qmake -norecursive pro.pro CONFIG+=release<br>make<br></code></pre></td></tr></table></figure><p>在<code>vapoursynth-editor/build/release-64bit-gcc</code>或类似的地方，得到vsedit等二进制文件，可以用<code>ln</code>命令做一个链接，方便平时使用。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ln -s $Home/vapoursynth-editor/build/release-64bit-gcc/vsedit ~/Desktop/vsedit<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd ~/Desktop<br>./vsedit<br></code></pre></td></tr></table></figure><p>运行vsedit，即可弹出图形界面。</p><h3 id="关于滤镜"><a href="#关于滤镜" class="headerlink" title="关于滤镜"></a>关于滤镜</h3><p>滤镜应该放在<code>/usr/local/lib/vapoursynth</code>下。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;ArchLinux安装桌面&quot;&gt;&lt;a href=&quot;#ArchLinux安装桌面&quot; class=&quot;headerlink&quot; title=&quot;ArchLinux安装桌面&quot;&gt;&lt;/a&gt;ArchLinux安装桌面&lt;/h3&gt;&lt;p&gt;参考&lt;a href=&quot;https://www.viseator.com/2017/05/17/arch_install/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;以官方Wiki的方式安装ArchLinux&lt;/a&gt;安装ArchLinux的基本系统。&lt;/p&gt;
&lt;p&gt;参考&lt;a href=&quot;https://starrycat.me/archlinux-install-gnome-desktop.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;ArchLinux安装GNOME图形桌面环境&lt;/a&gt;和&lt;a href=&quot;https://www.viseator.com/2017/05/19/arch_setup/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;ArchLinux安装后的必须配置与图形界面安装教程&lt;/a&gt;安装图形界面。&lt;/p&gt;
&lt;p&gt;顺带提一下我的经验，若是在VMware虚拟机中安装，不要在VM下拉伸桌面，不然重启系统后黑屏…&lt;/p&gt;
&lt;h3 id=&quot;编译VapourSynth&quot;&gt;&lt;a href=&quot;#编译VapourSynth&quot; class=&quot;headerlink&quot; title=&quot;编译VapourSynth&quot;&gt;&lt;/a&gt;编译VapourSynth&lt;/h3&gt;&lt;p&gt;在之前的&lt;a href=&quot;https://kiyamou.github.io/2020/02/07/arch-and-meson/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;一篇博文&lt;/a&gt;中，提到了编译VapourSynth。但我不知道为什么，可能是升级了ArchLinux系统（&lt;code&gt;pacman -Syu&lt;/code&gt;），导致之前编译好的用不了，只能重新编译一次。&lt;/p&gt;
    
    </summary>
    
    
      <category term="工具使用" scheme="http://yoursite.com/categories/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"/>
    
    
      <category term="构建与编译" scheme="http://yoursite.com/tags/%E6%9E%84%E5%BB%BA%E4%B8%8E%E7%BC%96%E8%AF%91/"/>
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
      <category term="VapourSynth" scheme="http://yoursite.com/tags/VapourSynth/"/>
    
  </entry>
  
  <entry>
    <title>周记 2020.03.02-03.08</title>
    <link href="http://yoursite.com/2020/03/08/week-202003-1/"/>
    <id>http://yoursite.com/2020/03/08/week-202003-1/</id>
    <published>2020-03-08T08:47:39.000Z</published>
    <updated>2020-03-08T09:36:31.019Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-逐项完成ISP算法"><a href="#1-逐项完成ISP算法" class="headerlink" title="1.逐项完成ISP算法"></a>1.逐项完成ISP算法</h3><p>感慨到还是Python方便啊，在涉及矩阵运算的时候。另外，还是觉得先要解决一下数据结构的问题，不然现在写起来太蛋疼了。</p><p>重新梳理了一遍ISP的流程，重点看了Tone Mapping和Gamma校正。</p><a id="more"></a><h3 id="2-C-科学计算"><a href="#2-C-科学计算" class="headerlink" title="2.C++科学计算"></a>2.C++科学计算</h3><p>Eigen库是一个C++科学计算库，主要是各种矩阵运算。</p><h3 id="3-为什么没好好学数学"><a href="#3-为什么没好好学数学" class="headerlink" title="3.为什么没好好学数学"></a>3.为什么没好好学数学</h3><p>本不该倒垃圾，但这几年的学，从数学能力的角度，真是越上越回去了（所以这也是我的专业症结所在）。矩阵论稀里糊涂上完了…在看现在需要用的SVD、范数计算…数学跟不上了…</p><h3 id="4-VSGAN与升级VS版本"><a href="#4-VSGAN与升级VS版本" class="headerlink" title="4.VSGAN与升级VS版本"></a>4.VSGAN与升级VS版本</h3><p>（先吐槽一句，为什么我电脑上装了3.6、3.7、3.8三个版本的Python…而且更蛋疼的是Python 3.7装在了Visual Studio里面…）</p><p>干脆把电脑有Python全卸了，重装上了Python 3.8，VapourSynth也升级到了最新的R49预览版。由于这次把Python装在<code>C:\Program Files</code>里面，经常需要管理员权限，有点蛋疼…</p><p>弄好环境后，尝试了VSGAN，想试一下<code>waifuGAN</code>和<code>1xESRGAN</code>两个模型，然而电脑没有显卡，用CPU实在太慢了，先放弃了…</p><p>看了一下VSGAN的代码（还是Python看着简洁），基于Pytorch调用.pth模型，实现基于ESRGAN网络的超分辨率或其他操作。模型可以在<a href="https://upscale.wiki/wiki/Model_Database" target="_blank" rel="noopener">这里</a>找到。</p><p>说起来两个星期前还在感叹技术太渣，连ESRGAN模型调用都调不了…现在也算是（借助别人的工具）弥补上了。</p><h3 id="5-原生分辨率"><a href="#5-原生分辨率" class="headerlink" title="5.原生分辨率"></a>5.原生分辨率</h3><p>这个东西也算是我的心结之一了。<code>getnative.py</code>搞定，测试了一下，感觉鲁棒性还挺好，而对于我自己缩到720p再升到1080p的例子，也能认出是720p（但是信号特征不如原始图片855p那么明显）。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-逐项完成ISP算法&quot;&gt;&lt;a href=&quot;#1-逐项完成ISP算法&quot; class=&quot;headerlink&quot; title=&quot;1.逐项完成ISP算法&quot;&gt;&lt;/a&gt;1.逐项完成ISP算法&lt;/h3&gt;&lt;p&gt;感慨到还是Python方便啊，在涉及矩阵运算的时候。另外，还是觉得先要解决一下数据结构的问题，不然现在写起来太蛋疼了。&lt;/p&gt;
&lt;p&gt;重新梳理了一遍ISP的流程，重点看了Tone Mapping和Gamma校正。&lt;/p&gt;
    
    </summary>
    
    
      <category term="笔记" scheme="http://yoursite.com/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
      <category term="VapourSynth" scheme="http://yoursite.com/tags/VapourSynth/"/>
    
  </entry>
  
  <entry>
    <title>周记 2020.02.24-03.01</title>
    <link href="http://yoursite.com/2020/03/05/week-202002-4/"/>
    <id>http://yoursite.com/2020/03/05/week-202002-4/</id>
    <published>2020-03-05T14:44:28.000Z</published>
    <updated>2020-03-08T08:43:17.049Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-C-互斥锁"><a href="#1-C-互斥锁" class="headerlink" title="1.C++互斥锁"></a>1.C++互斥锁</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;mutex&gt;</span></span><br><br><span class="hljs-built_in">std</span>::mutex<br></code></pre></td></tr></table></figure><a id="more"></a><h3 id="2-解决VapourSynth版本问题？"><a href="#2-解决VapourSynth版本问题？" class="headerlink" title="2.解决VapourSynth版本问题？"></a>2.解决VapourSynth版本问题？</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> VAPOURSYNTH_API_VERSION &lt; 0x30002</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> FMTC_RESAMPLE_OLD_FIELDBASED_BEHAVIOUR</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br></code></pre></td></tr></table></figure><p>（来自KNLmeansCL？）</p><h3 id="3-OpenCL"><a href="#3-OpenCL" class="headerlink" title="3.OpenCL"></a>3.OpenCL</h3><p>看了《OpenCL异构计算》的两个例子，借助OpenCL加速图像直方图处理和卷积计算。</p><h3 id="4-OpenCL设计思路的理解"><a href="#4-OpenCL设计思路的理解" class="headerlink" title="4.OpenCL设计思路的理解"></a>4.OpenCL设计思路的理解</h3><p>我能理解到的几点…</p><ul><li>OpenCL中存在主机与设备共享内存？（定义了通用的内存模型，以实现跨平台）</li><li>类似cuda，OpenCL的计算模式大概也是“先传输数据到设备，计算后再传回主机”？（OpenCL通过上下文（Context）在主机与设备间通信）</li><li>OpenCL主要使用 SIMD（数据并行）和 MIMD（任务并行）</li><li>CPU 线程 = OpenCL 工作项（Work Item）</li></ul><h3 id="5-OpenCL与C"><a href="#5-OpenCL与C" class="headerlink" title="5.OpenCL与C++"></a>5.OpenCL与C++</h3><p>在C++中使用OpenCL，可以直接调用OpenCL库，也可以借助Boost库的compute库调用。</p><p>可以不写的<code>.cl</code>文件的说。</p><h3 id="6-C-STL库"><a href="#6-C-STL库" class="headerlink" title="6.C++ STL库"></a>6.C++ STL库</h3><p>C++标准模板库，（抛开<code>string</code>）可以分为两条线路，容器与方法。元素的插入、删除和访问方法不同，构成了不同容器的差别，而方法可以理解成一个函数，或者说一种操作。</p><p>例如容器<code>vector</code>、<code>queue</code>，方法<code>at</code>、<code>emplace</code>。</p><p>感觉现在，我已经把21天学通C++这本书从总体上做了概览。</p><h3 id="7-Mkdocs：写自己的图书"><a href="#7-Mkdocs：写自己的图书" class="headerlink" title="7.Mkdocs：写自己的图书"></a>7.Mkdocs：写自己的图书</h3><p>去搜算法导论的课后题，偶然发现了Mkdocs，感觉比gitbooks自由度更高。也知道了原来github pages不仅可以用来搭博客，还可以做一般项目的展示页。github展示页配合Mkdocs就可以实现自己的图书。</p><h3 id="8-交流"><a href="#8-交流" class="headerlink" title="8.交流"></a>8.交流</h3><p>在D9上帖出了AreaResize，通过交流我才意识到，之前我修改的JincResize，以及其他常用的Resize方法，都可以视为卷积操作（所以这也带来了OpenCL加速或指令集优化的可能）。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-C-互斥锁&quot;&gt;&lt;a href=&quot;#1-C-互斥锁&quot; class=&quot;headerlink&quot; title=&quot;1.C++互斥锁&quot;&gt;&lt;/a&gt;1.C++互斥锁&lt;/h3&gt;&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;code class=&quot;hljs c++&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;hljs-meta-string&quot;&gt;&amp;lt;mutex&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;br&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;std&lt;/span&gt;::mutex&lt;br&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="笔记" scheme="http://yoursite.com/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
      <category term="OpenCL" scheme="http://yoursite.com/tags/OpenCL/"/>
    
  </entry>
  
</feed>
