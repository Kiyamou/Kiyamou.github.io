<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 记一次从AviSynth到VapourSynth的迁移（2）：感受不同的API 下 · 308实验室</title><meta name="description" content="记一次从AviSynth到VapourSynth的迁移（2）：感受不同的API 下 - Kiyamou"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://yoursite.com/atom.xml" title="308实验室"><meta name="generator" content="Hexo 4.2.1"><link rel="alternate" href="/atom.xml" title="308实验室" type="application/atom+xml">
</head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/circle.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/Kiyamou" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/about" target="_self" class="nav-list-link">ABOUT</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">记一次从AviSynth到VapourSynth的迁移（2）：感受不同的API 下</h1><div class="post-info">Jan 1, 2020</div><div class="post-content"><p>距离写上一篇博文已经过去几天了（事实上那篇博文在更早的几天就写了草稿）。这几天学到了不少东西，硬塞到上一篇博文中好像不太合适；而且上一篇博文就是在思路不太清时写，有点混乱。总之，干脆新写一篇。</p>
<p>为了加强理解、尽量全面，可能会有些重复的话。</p>
<h3 id="srcp、dstp的理解"><a href="#srcp、dstp的理解" class="headerlink" title="srcp、dstp的理解"></a><code>srcp</code>、<code>dstp</code>的理解</h3><p>约定俗成的变量命名，<code>src</code>已经习惯，是输入，而<code>dsp</code>则是结果。</p>
<p>关于<code>srcp</code>和<code>dstp</code>，通常这样定义</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> T* srcp = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> T*&gt;(vsapi-&gt;getReadPtr(src, plane));</span><br><span class="line">T* VS_RESTRICT dstp = <span class="keyword">reinterpret_cast</span>&lt;T*&gt;(vsapi-&gt;getWritePtr(dst, plane));</span><br></pre></td></tr></table></figure>

<ol>
<li><code>getReadPtr()</code>和<code>getWritePte()</code>均是<code>uint8_t *</code>型，为满足不同位深的输入输出，也就是能够给不同类型的变量赋值，用<code>reinterpret_cast</code>做类型转换，转换为模版中的<code>T</code>。</li>
<li>需要注意到，<code>srcp</code>和<code>dstp</code>已经包含了平面信息，或者说代表了特定平面，在滤镜核心处理函数中，用for循环遍历各个平面，for循环内就会基于<code>srcp</code>和<code>dstp</code>，对单个平面做处理。</li>
<li>注意<code>srcp</code>、<code>dstp</code>是指针，这个在稍后会继续说。</li>
</ol>
<a id="more"></a>

<h3 id="stride的理解"><a href="#stride的理解" class="headerlink" title="stride的理解"></a><code>stride</code>的理解</h3><p>avs api和vs api的一大区别，就是隐藏在习惯变量名不同（<code>pitch</code>与<code>stride</code>）之下的单位问题。</p>
<p>从Doc上看，avs api获取的<code>pitch</code>和vs api获取的<code>stride</code>都是以字节为单位。在使用中，vs框架下要除以变量所占的字节，即</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> dst_stride = vsapi-&gt;getStride(dst, plane) / <span class="keyword">sizeof</span>(T);</span><br></pre></td></tr></table></figure>

<p>但我读过的几份avs滤镜代码，都是直接用的，没有除<code>sizeof</code>。</p>
<p>突然明白，我忘了一个事情，<strong><code>sizeof(uint8_t)</code> = 1啊</strong>，所以不需要除<code>sizeof</code>，是不是以字节为单位，都是一样的啊。</p>
<h5 id="疑问的解释"><a href="#疑问的解释" class="headerlink" title="疑问的解释"></a>疑问的解释</h5><p>我一直在纠结下面的avs与vs代码会不会有区别。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// avs</span></span><br><span class="line">srcp += src_pitch;</span><br><span class="line">dstp += target_width;</span><br><span class="line"><span class="comment">// vs</span></span><br><span class="line">srcp += src_stride;</span><br><span class="line">dstp += target_width; <span class="comment">// dstp += dst_stride;</span></span><br></pre></td></tr></table></figure>

<p>但其实这个问题是不存在的。对于avs，基于全程8bit的假设，<code>sizeof</code> = 1，虽然<code>src_pitch</code>是以字节为单位，但数值上与<code>target_width</code>是同级的；对于vs，<code>src_stride</code>是除过<code>sizof</code>的，与<code>target_width</code>单位一致。</p>
<p>所以无论vs怎么写，与avs都是一致的，且<code>srcp</code>与<code>dstp</code>数值都是同级的。</p>
<h3 id="stride与dstp的共同作用"><a href="#stride与dstp的共同作用" class="headerlink" title="stride与dstp的共同作用"></a><code>stride</code>与<code>dstp</code>的共同作用</h3><p>类似<code>dstp += dst_stride;</code>这样的语句，实现了指针的移动，<del>让继续处理下一帧？</del>是处理同列中个下个像素。</p>
<p><del>而<code>dstp[y + x * dst_stride]</code>应该是二维平面上的指针移动。</del>这话也没有错，但有种误导的感觉，其实和上面是一个意思，只不过上面单独处理列，这个是行和列同时处理。</p>
<p>详情在<a href="https://kiyamou.github.io/2019/12/18/image-process-code-1/" target="_blank" rel="noopener">另一篇博文</a>里写了。</p>
<h3 id="VapourSynth数据结构的猜测"><a href="#VapourSynth数据结构的猜测" class="headerlink" title="VapourSynth数据结构的猜测"></a>VapourSynth数据结构的猜测</h3><p>（有人说编程是算法+数据结构，现在终于能理解到这句话了）</p>
<p>简单地说，是像一维数组那样横着排的？对<code>dstp</code>加上一个<code>width</code>就到下一帧？</p>
<p>但这样想，上面那样的<code>dstp[y + x * dst_stride]</code>又说不通了。</p>
<h3 id="void函数做了什么"><a href="#void函数做了什么" class="headerlink" title="void函数做了什么"></a><code>void</code>函数做了什么</h3><p>这个问题看上去很蠢，但也许是我上半年写Python留下的后遗症。总以为函数后要<code>return</code>个什么东西，仿佛把封装好的函数当成一个计算黑箱。这样理解也谈不上错吧，但却让我在一开始读vs滤镜代码时一头雾水。</p>
<p>经过了一个<code>void</code>函数，函数内的全局变量（或者是生存期大过该函数的变量）已经被改变。简单地说，就是“酒肉穿肠过，该变的都变了”的意思。</p>
<h3 id="vsapi的理解"><a href="#vsapi的理解" class="headerlink" title="vsapi的理解"></a><code>vsapi</code>的理解</h3><p>可以将滤镜分为两类：一类是resize型滤镜，输入输出的尺寸不一致；一类是非resize型滤镜，输入输出的尺寸一致。</p>
<p>对于后者，在初始化函数<code>FilterInit()</code>中，只需原样写下<code>vi</code>即可</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> VS_CC <span class="title">FilterInit</span><span class="params">(VSMap* in, VSMap* out, <span class="keyword">void</span>** instanceData, VSNode* node, VSCore* core, <span class="keyword">const</span> VSAPI* vsapi)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FilterData* d = <span class="keyword">static_cast</span>&lt;FilterData*&gt;(*instanceData);</span><br><span class="line">    vsapi-&gt;setVideoInfo(d-&gt;vi, <span class="number">1</span>, node);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于前者，要在初始化中将尺寸改写为输出尺寸</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> VS_CC <span class="title">FilterInit</span><span class="params">(VSMap* in, VSMap* out, <span class="keyword">void</span>** instanceData, VSNode* node, VSCore* core, <span class="keyword">const</span> VSAPI* vsapi)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FilterData* d = <span class="keyword">static_cast</span>&lt;FilterData*&gt;(*intanceData);</span><br><span class="line">    VSVideoInfo dst_vi = (VSVideoInfo)* d-&gt;vi;</span><br><span class="line">    dst_vi.width = d-&gt;output_width;</span><br><span class="line">    dst_vi.height = d-&gt;output_height;</span><br><span class="line">    vsapi-&gt;setVideoInfo(&amp;dst_vi, <span class="number">1</span>, node); <span class="comment">// 注意d-&gt;vi是指针，这里要取地址</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样就保证了输出的<code>dst</code>是resize后的尺寸，否则照上面那样写，（与输入源不一样的尺寸）会报错。</p>
<p>写法不是唯一的，也可以在<code>FilterCreate()</code>函数里写，只是我还不太会…</p>
<h3 id="遇事不决用double"><a href="#遇事不决用double" class="headerlink" title="遇事不决用double"></a>遇事不决用double</h3><p>emmm困扰了我一整天的颜色问题，把函数内部处理全变成double，直到输出时再改成所需的类型，颜色终于正常了。</p>
<p>现在毕竟还在起步阶段，先把能正常运行的程序写出来，再考虑提升性能的事情。</p>
<h3 id="关于编译与调用"><a href="#关于编译与调用" class="headerlink" title="关于编译与调用"></a>关于编译与调用</h3><p>要保持编译时用的头文件与VapourSynth SDK文件夹中的头文件一致，否则无法调用。</p>
<p>（所以在配置编译文件时需要动点脑子）</p>
<h3 id="C-的基础"><a href="#C-的基础" class="headerlink" title="C++的基础"></a>C++的基础</h3><h4 id="进一步理解C-的类型转换"><a href="#进一步理解C-的类型转换" class="headerlink" title="进一步理解C++的类型转换"></a>进一步理解C++的类型转换</h4><h4 id="编译相关"><a href="#编译相关" class="headerlink" title="编译相关"></a>编译相关</h4><p>两次编译的结果，hash不会一样的，但二进制文件大小一样。</p>
<h4 id="零散的知识点"><a href="#零散的知识点" class="headerlink" title="零散的知识点"></a>零散的知识点</h4><p>递归函数（调用了自身的函数）没法内联。</p>
<p>静态函数（用<code>static</code>关键字声明）不可在文件外被调用。</p>
</div></article></div></main><footer><div class="paginator"><a href="/2020/01/15/Thanks-Letter-OpenSource/" class="prev">PREV</a><a href="/2019/12/28/ported-to-vs/" class="next">NEXT</a></div><div class="copyright"><p>© 2019 - 2020 <a href="http://yoursite.com">Kiyamou</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>