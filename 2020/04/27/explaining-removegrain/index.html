<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 解释 RemoveGrain · 308实验室</title><meta name="description" content="解释 RemoveGrain - Kiyamou"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://yoursite.com/atom.xml" title="308实验室"><meta name="generator" content="Hexo 4.2.1"><link rel="alternate" href="/atom.xml" title="308实验室" type="application/atom+xml">
</head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/circle.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/Kiyamou" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/about" target="_self" class="nav-list-link">ABOUT</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">解释 RemoveGrain</h1><div class="post-info">Apr 27, 2020</div><div class="post-content"><p>本文翻译自 <a href="https://blog.kageru.moe/legacy/removegrain.html" target="_blank" rel="noopener">Actually Explaining RemoveGrain</a>，原作者：<a href="https://github.com/kageru" target="_blank" rel="noopener">kageru</a>。</p>
<a id="more"></a>

<h3 id="Mode-11-与-12"><a href="#Mode-11-与-12" class="headerlink" title="Mode 11 与 12"></a>Mode 11 与 12</h3><p>Mode 11 与 12 等价于</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std.Convolution(matrix=[<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>])</span><br></pre></td></tr></table></figure>

<p>Mode 11 和 Mode 12 没有区别，从代码上看是复制过来的，下面的测试也证明了这一点。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; d &#x3D; core.std.Expr([clip.rgvs.RemoveGrain(mode&#x3D;11),</span><br><span class="line">clip.rgvs.RemoveGrain(mode&#x3D;12)], &#39;x y - abs&#39;)</span><br><span class="line">&gt;&gt;&gt; d &#x3D; d.std.PlaneStats()</span><br><span class="line">&gt;&gt;&gt; d.get_frame(0).props.PlaneStatsAverage</span><br><span class="line">0.0</span><br></pre></td></tr></table></figure>

<p>但这两种模式与对应的卷积操作存在细微差别。</p>
<p><strong>Edit</strong>：这也可能是 VapourSynth-R36 中已修复的 PlaneStats bug 导致的，因为 0.05 的误差确实太大了。</p>
<p>（译者注：应该是 bug 导致的，在 VapourSynth-R49 中测试没有差别，下述结果为译者测试结果）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; d &#x3D; core.std.Expr([src.rgvs.RemoveGrain(mode&#x3D;12),</span><br><span class="line">src.std.Convolution(matrix&#x3D;[1, 2, 1, 2, 4, 2, 1, 2, 1])], &#39;x y - abs&#39;)</span><br><span class="line">&gt;&gt;&gt; d &#x3D; d.std.PlaneStats()</span><br><span class="line">&gt;&gt;&gt; d.get_frame(0).props.PlaneStatsAverage</span><br><span class="line">0.0</span><br></pre></td></tr></table></figure>

<p>VapourSynth 内置的卷积滤镜通过插值处理边缘，而 RemoveGrain 则不处理边缘。</p>
<h3 id="Mode-13-16"><a href="#Mode-13-16" class="headerlink" title="Mode 13 - 16"></a>Mode 13 - 16</h3><p>这些模式为场内插值，速度非常快，但也非常不精确，类似粗制滥造的 EEDI。没有必要使用这些模式（EEDI2 于2005年发布，无论是这些模式还是 EEDI 都没必要使用）。</p>
<h3 id="Mode-17"><a href="#Mode-17" class="headerlink" title="Mode 17"></a>Mode 17</h3><blockquote>
<p>Clips the pixel with the minimum and maximum of respectively the maximum and minimum of each pair of opposite neighbour pixels.</p>
</blockquote>
<p>听上去可能有些困惑，但描述得很准确。这一模式会创建一个数组，包含极小值（lower）和极大值（upper），然后将中心像素限制在极大值的最小数和极小值的最大数之间。</p>
<h3 id="Mode-21-与-22"><a href="#Mode-21-与-22" class="headerlink" title="Mode 21 与 22"></a>Mode 21 与 22</h3><h4 id="Mode-21"><a href="#Mode-21" class="headerlink" title="Mode 21"></a>Mode 21</h4><p>中心像素替换为周围四对数字的最大值与最小值的均值。</p>
<h4 id="Mode-22"><a href="#Mode-22" class="headerlink" title="Mode 22"></a>Mode 22</h4><p>与 Mode 21 类似，但近似方式不同，比 Mode 21 更快。</p>
<h3 id="Mode-23-与-24"><a href="#Mode-23-与-24" class="headerlink" title="Mode 23 与 24"></a>Mode 23 与 24</h3><p>我难以解释这两个模式，也不知道这两个模式有什么用，如果想了解建议阅读代码。</p>
</div></article></div></main><footer><div class="paginator"><a href="/2020/04/27/edgemasks/" class="prev">PREV</a><a href="/2020/04/26/grain-and-noise/" class="next">NEXT</a></div><div class="copyright"><p>© 2019 - 2020 <a href="http://yoursite.com">Kiyamou</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>