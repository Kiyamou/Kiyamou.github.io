<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> DehazingCE：基于对比度增强的去雾算法及 VapourSynth 迁移 · 308实验室</title><meta name="description" content="DehazingCE：基于对比度增强的去雾算法及 VapourSynth 迁移 - Kiyamou"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://yoursite.com/atom.xml" title="308实验室"><meta name="generator" content="Hexo 4.2.1"><link rel="alternate" href="/atom.xml" title="308实验室" type="application/atom+xml">
</head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/circle.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/Kiyamou" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/about" target="_self" class="nav-list-link">ABOUT</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">DehazingCE：基于对比度增强的去雾算法及 VapourSynth 迁移</h1><div class="post-info">Jun 26, 2020</div><div class="post-content"><p>这一去雾算法在2013年提出，论文见 <a href="http://mcl.korea.ac.kr/projects/dehazing/#userconsent#" target="_blank" rel="noopener">Optimized contrast enhancement for real-time image and video dehazing</a>，我们称其为 DehazingCE （CE = contrast enhancement）。</p>
<h3 id="算法概述"><a href="#算法概述" class="headerlink" title="算法概述"></a>算法概述</h3><p>DehazingCE 基于大气散射模型，分别估计大气光强度和透射率，得到去雾结果。</p>
<a id="more"></a>

<p>大气光估计通过图像分块、寻找像素差异最小的子块，以该子块最亮的点作为大气光的估计值。但这里存在一个问题，不知道是我理解有问题，还是我代码迁移有问题，或者算法本身就有问题。如果图像整体偏暗，那寻找到的子块就会很暗，最后以一个像素值很小的点作为大气光估计值，用这个值继续计算，最终结果就是全黑。我对迁移到 VapourSynth 的代码进行测试，确实发现了这一问题。</p>
<p>透射率估计分为粗算和细化两步。粗算是基于大气散射模型进行次数不多的迭代，并自定义像素损失值（大气散射模型的直接计算结果可能会超过 [0, peak]，导致像素越界）以决定是否继续迭代。细化通过导向滤波实现。</p>
<p>后处理包括 Gamma 亮度调整和类似均值滤波的均值化计算。前者是避免去雾后图像过暗，后者是避免透射率过低时导致的块效应。在我迁移的代码中，Gamma 亮度调整表现不错，但均值化计算可能是我的代码还有问题，测试结果是不如不做，做了反而凭空多了瑕疵。</p>
<h3 id="代码迁移"><a href="#代码迁移" class="headerlink" title="代码迁移"></a>代码迁移</h3><p>代码迁移着实花了很久，满打满算从 4 月份开始读原始代码，到 6 月份完成初版的迁移，几乎花了两个月…原始代码风格很古典，着实有点费力。</p>
<h4 id="从-OpenCV-2-到-OpenCV-3"><a href="#从-OpenCV-2-到-OpenCV-3" class="headerlink" title="从 OpenCV 2 到 OpenCV 3"></a>从 OpenCV 2 到 OpenCV 3</h4><p>在最开始，我觉得一下子迁移到 VapourSynth 有点费力，便想尝试着把原始代码先跑起来。原始代码基于 OpenCV 2，存储图像还是用的 IplImage 指针而非 Mat 类。这一部分工作在<a href="https://kiyamou.github.io/2020/04/28/dehazing/" target="_blank" rel="noopener">前面的博文</a>有提到。但折腾好久，也没把原始代码跑起来，最后放弃了，直接迁移。</p>
<h4 id="YUV-还是-RGB"><a href="#YUV-还是-RGB" class="headerlink" title="YUV 还是 RGB"></a>YUV 还是 RGB</h4><p>在着手迁移之初，是先支持 YUV 还是先支持 RGB 纠结了好久。其中一部分原因是我还没完全搞懂原始代码的处理流程，从大气光估计部分看，原始代码用的是 RGB 格式，从透射率估计看，原始代码既有只算灰度的（这像是面向 YUV），又有 RGB 三个通道都计算的。最后决定先支持 RGB（因为我先读明白了原始代码的大气光估计部分，沿用了这一部分的 RGB 格式）。</p>
<h4 id="数据结构的转换与基础操作的迁移"><a href="#数据结构的转换与基础操作的迁移" class="headerlink" title="数据结构的转换与基础操作的迁移"></a>数据结构的转换与基础操作的迁移</h4><p>确定 RGB 后便开始转换图像数据结构，为减少工作量，尽量不去动原始代码的函数输入输出模式，把 VapourSynth 接口传递过来的图像指针转化为普通指针，送给核心计算函数。在这个过程中，我越来越感觉到 VapourSynth 接口的概念，或者什么叫接口。我渐渐懂得把核心处理剥离开，不再依赖 VapourSynth API 提供的数据类型，而是使用普通指针和数组完成核心计算，在把结果送给 VapourSynth API。</p>
<p>在计算过程中需要进行图像分块、计算图像像素值均值和标准差。在原始代码中，这些操作都是使用的 OpenCV 函数。对于这些并不复杂的操作，我自然不能接受调用第三方库来实现。图像分块最开始是用两层 for 循环赋值，后来才想到用<code>memcpy()</code>函数直接拷贝。计算均值和标准差直接 copy 了一份代码。</p>
<p>完成上述操作后，迁移过程就没什么困难的了，写个集成函数去调用各步计算即可。</p>
<h4 id="VapourSynth-API-的一些事情"><a href="#VapourSynth-API-的一些事情" class="headerlink" title="VapourSynth API 的一些事情"></a>VapourSynth API 的一些事情</h4><p>虽说已经没有大的困难，但具体细节上还是要花时间的。我之前没有写过 ref 参考片段，之前也不知道 VapourSynth 接口没有提供 bool 类型。好在有前辈们写成的其他滤镜，有很多可以参考（copy）的代码。</p>
<h3 id="Debug"><a href="#Debug" class="headerlink" title="Debug"></a>Debug</h3><h4 id="指针读取冲突"><a href="#指针读取冲突" class="headerlink" title="指针读取冲突"></a>指针读取冲突</h4><p> 读取位置 … 时发生访问冲突。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">srcInterleaved[pos] = srcpB[x];</span><br><span class="line">srcInterleaved[pos + <span class="number">1</span>] = srcpG[x];</span><br></pre></td></tr></table></figure>

<p>这里就出问题是我没有想到的，因为这部分代码之前在AreaResize中已经用过了，没有问题。</p>
<p>回到报错本身，“发生访问冲突”表明指针访问内存时出问题了，指针指向了不属于自己的内存地址，是一个基础的问题。</p>
<p>发现在vs接口部分忘记释放ref，释放之后同样报访问冲突，但这次的报错位置是大气光估计函数的图像分块位置，这才是意料之中（这部分代码最开始写的时候就迷迷糊糊的）。</p>
<p>但另一个引发该错误的原因就很蠢了，假如读入的不是 RGB 格式，而是 YUV 格式，也会引发该错误。这是自然的，YUV 的第二、三个通道的宽高分别是第一个通道的一半，自然会越界。</p>
<h3 id="构建与C-语法"><a href="#构建与C-语法" class="headerlink" title="构建与C++语法"></a>构建与C++语法</h3><p>从这次开始我使用了 cmake 进行构建，一开始都是一些技术问题，直到部署 CI 的时候，才通过 cmake 意识到一些 C++ 语法的问题，一些我在很早的时候就看到过但没有读懂的问题。</p>
<h4 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h4><p>智能指针是 C++11 引入的，但<code>std::make_unique</code>被忘记写入标准了，直到 C++14 才被引入…</p>
<h4 id="noexcept"><a href="#noexcept" class="headerlink" title="noexcept"></a>noexcept</h4><p><code>noexcept</code>在 C++11 引入。</p>
<p>不搞清这些标准问题，在 travis-ci 的编译器上会报错…</p>
<h3 id="高位深支持"><a href="#高位深支持" class="headerlink" title="高位深支持"></a>高位深支持</h3><p>高位深支持需要解决两个方面的问题，一是算法本身计算过程的修改，这一部分我改到现在还是有问题…图像暗场处理后会直接变黑…另一是C++语法的问题，带有模板的成员函数怎么写。</p>
<h4 id="语法层面的问题"><a href="#语法层面的问题" class="headerlink" title="语法层面的问题"></a>语法层面的问题</h4><p>我之前用模板，借用做饭的话说就是现用现做，而成员函数的声明和定义分开写在两个文件中，这时候再用模板就会出现链接器错误。但把声明和定义写在一起我不太愿意这么搞，于是折中的办法是在 main.cpp 同时 include 含有声明的 .h 和定义的 .cpp 文件。</p>
<h4 id="算法层面的问题"><a href="#算法层面的问题" class="headerlink" title="算法层面的问题"></a>算法层面的问题</h4><p>按照惯例，至少对于从 8bit 到 16bit 的扩充，把类似含有 255 的地方改成 peak 就可以了，但这次遇到了不少问题。</p>
</div></article></div></main><footer><div class="paginator"><a href="/2020/07/28/2020-mid-books/" class="prev">PREV</a><a href="/2020/05/30/Dont-starve/" class="next">NEXT</a></div><div class="copyright"><p>© 2019 - 2021 <a href="http://yoursite.com">Kiyamou</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>