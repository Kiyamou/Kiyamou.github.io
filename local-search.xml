<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>2021 年中书单/影评：只我是那个荒唐</title>
    <link href="/2021/07/11/2021-mid-books/"/>
    <url>/2021/07/11/2021-mid-books/</url>
    
    <content type="html"><![CDATA[<blockquote><p>风微凉 夜微茫 醉在了梦乡</p><p>那时候 谁都讲</p><p>世界偌大少年荒唐</p><p>而如今 闭眼想 只我是那个荒唐</p><p>——《今日重到苏澜桥》</p></blockquote><p>照例，记录 2020 年下半年和 2021 年上半年看过的书、剧等。</p><a id="more"></a><h3 id="学术类书籍"><a href="#学术类书籍" class="headerlink" title="学术类书籍"></a>学术类书籍</h3><h4 id="《三角级数》"><a href="#《三角级数》" class="headerlink" title="《三角级数》"></a>《三角级数》</h4><p>书名不止这四个字，记不清全名了…学院清理旧书时捡起来翻了翻。书的最后一章讲了一些比较…比较古典的求和计算之类的东西。很想拿走看看，但不知道这些旧书要怎么处理，就作罢了。</p><h3 id="泛学术类书籍"><a href="#泛学术类书籍" class="headerlink" title="泛学术类书籍"></a>泛学术类书籍</h3><h4 id="1-《高山仰止——唐敖庆和他的弟子们》"><a href="#1-《高山仰止——唐敖庆和他的弟子们》" class="headerlink" title="1.《高山仰止——唐敖庆和他的弟子们》"></a>1.《高山仰止——唐敖庆和他的弟子们》</h4><p>Sob 几年前写了一个推荐帖推荐这本书，买来读了之后确实如 Sob 所说，不是那种简单歌功颂德的书，里面的内容很具体很翔实。虽然表达方式有些模板化，但对于细节的描述和专业概念的表达是很不错的，化学专业出身的人读起来也不会觉得违和，能够从相对质朴平实的语言中感受到老一辈科研人员的努力认真。</p><h4 id="2-《线性代数的几何意义》"><a href="#2-《线性代数的几何意义》" class="headerlink" title="2.《线性代数的几何意义》"></a>2.《线性代数的几何意义》</h4><p>这本书还只是大概翻了翻，虽然当年线代老师讲得挺好的，坐标变换与旋转等涉及几何的内容也讲过，但看到这本书还是觉得很有价值。</p><h3 id="技术类书籍"><a href="#技术类书籍" class="headerlink" title="技术类书籍"></a>技术类书籍</h3><p>因为要离开学校了，所以抓紧最后的时间去图书馆转了转。</p><h4 id="1-《短线波段战法》"><a href="#1-《短线波段战法》" class="headerlink" title="1.《短线波段战法》"></a>1.《短线波段战法》</h4><p>主要是学到了一些基本的技术指标的概念，再深入的东西看是看了，但没怎么记住Orz…</p><h4 id="2-《原画梦-30天学会日系插画》"><a href="#2-《原画梦-30天学会日系插画》" class="headerlink" title="2.《原画梦 30天学会日系插画》"></a>2.《原画梦 30天学会日系插画》</h4><p>内容比较全面的一本书，适合新手吧。书本身是值得推荐的，但如果不是在图书馆一堆颇具历史感的书籍中鹤立鸡群，单看这个震惊变体的标题，我大概率是拒绝的。所以，这种夸张且令人不太舒服的标题，真的要屈从吗？</p><p>回到书本身，这本书大概真的是循序渐进，从基本的技法，到完整的人体框架，再细化各个部分。如果不讲人体框架，直接分解讲局部，我..可能是读不下去的。</p><h4 id="3-《路米斯经典美术课：人体素描》"><a href="#3-《路米斯经典美术课：人体素描》" class="headerlink" title="3.《路米斯经典美术课：人体素描》"></a>3.《路米斯经典美术课：人体素描》</h4><p>主要看了（静态）人体结构，还大致翻了一下动态人体。这两部分内容都可以和上面的插画教程对照着看。</p><p>静态人体自然是这本书讲得更全面，骨骼肌肉的种种类型、正视图侧视图等等很细致。动态人体部分各有千秋吧，虽然这本书很专业，但似乎上面的插画教程某些方面的干货更多一些。</p><h4 id="4-画法几何与阴影透视的相关书籍"><a href="#4-画法几何与阴影透视的相关书籍" class="headerlink" title="4. 画法几何与阴影透视的相关书籍"></a>4. 画法几何与阴影透视的相关书籍</h4><p>画法几何就是工程制图的plus版，虽然难度明显增大了，但内容还是相对熟悉的。阴影和透视这部分看了基础的透视概念。</p><h4 id="5-建筑素描的相关书籍"><a href="#5-建筑素描的相关书籍" class="headerlink" title="5. 建筑素描的相关书籍"></a>5. 建筑素描的相关书籍</h4><p>关于国内民居白描和英国建筑素描的两本书看的较多，还有一两本偏教材风格的素描画集也印象比较深。主要想看技术上的东西，特别是透视相关。但民居白描那本书意境上的东西更吸引人，倒不是那么展示教科书式的透视，大概白描和传统中国画还是很有关系的吧，书里还特别强调了故意把线画得歪一些，显得生动之类的。而经典素描的部分，不少作品的技法确实让我觉得震撼，透视和阴影的表现很到位。</p><h4 id="6-建筑设计的相关书籍"><a href="#6-建筑设计的相关书籍" class="headerlink" title="6. 建筑设计的相关书籍"></a>6. 建筑设计的相关书籍</h4><p>印象比较深的是一本医院建筑设计的图书，副标题大概是“带着脚镣跳舞”，也就是医院建筑的设计要在符合医疗需求的基础上进行。书中讲了一些偏医疗的东西，比如医疗技术的进步，由此带来了医院布局的几代发展。另外印象较深的书就是一本课程设计纪录，讲了一门建筑设计课上几个小组实际搭建建筑模型的事情。从配图上看，都是比较..前卫的设计吧。啊，我也不知道用什么词好。总之让我看到了四四方方房子之外的东西，特别是第一个小组的框架结构，很震撼，也比较漂亮。此外还有印象的就是一本讲欧洲历史建筑的书吧，讲了一些比较原始的建筑，其中的几幅插图还是很有意境的。</p><h3 id="音乐"><a href="#音乐" class="headerlink" title="音乐"></a>音乐</h3><h4 id="从-Hebe-到田馥甄"><a href="#从-Hebe-到田馥甄" class="headerlink" title="从 Hebe 到田馥甄"></a>从 Hebe 到田馥甄</h4><p>听了 2014 年一场原版配乐的《Super Star》，能明显看出田馥甄舞台表情和 00 年代时的区别。我一面听着不想长大、Super Star 在回忆，另一面在听着 2016 或 2017 年前后常听的田馥甄的歌，有种恍如隔世的感觉。不论是从 Hebe 到田馥甄的变化，还是听歌的我的变化。</p><p>我也不是明星，没有影像的记录。就算我会写日记，但很多经历和记忆、感受都随风飘散。所以去翻田馥甄的视频，不仅让我认识了曾经的 Hebe，也让我想起了当年的自己。这大概就是透过他人望出了外面的世界。</p><p>我模糊得记得在初中或者高中时期，大概是 2010 - 2013 年那段时间，看到过一篇关于田馥甄的报道，大概是那个时候才知道 Hebe 是田馥甄。我甚至朦胧得记得旧电脑里还存着一张当时报道的照片。但也只是看了报道而已，没有去听歌。</p><p>我有时候会有些许的感叹，为什么没有那个时候去听一听田馥甄的歌。</p><p>我自己心里也清楚，我的感叹，很大程度上是对我自己的旧时光的怀念。虽然我总是告诫自己不要这么留恋旧日时光，但年少的美好认真，是无法被磨灭的啊。</p><p>大概只有认真做自己，才能让未来的我去怀念现在的时光。只有认真做现在的事情，认真完善实行头脑中的想法，才能做到知行合一。所以，要有自己的生活，完全地做自己。</p><p>我自己给“知行合一”重新发明了一个含义，就是心里想的事情和实际做的事情一致，别心不在焉地做事。“风微凉 夜微茫 醉在了梦乡 / 那时候 谁都讲 / 世界偌大少年荒唐 / 而如今 闭眼想 只我是那个荒唐”。某种程度上，“只我是那个荒唐”。或者具体点说，某一个时期无谓怀念心不在焉的我是那个荒唐。只我是那个荒唐，一种比较尖锐的批评就是，我自以为与世独立，却没有做好该做的事，我自认为在掩盖尴尬的事情，却把事情弄得更尴尬。高中有，大学更明显。所以，表里如一地做事，大方地生活，不要最后变得荒唐。</p><p>有点沉重了，“荒唐”这个词在 Hebe 开车时也常常出现，这里能插张图就会开心多了。</p><h3 id="影视"><a href="#影视" class="headerlink" title="影视"></a>影视</h3><h4 id="1-《我的青春恋爱物语果然有问题。完》"><a href="#1-《我的青春恋爱物语果然有问题。完》" class="headerlink" title="1.《我的青春恋爱物语果然有问题。完》"></a>1.《我的青春恋爱物语果然有问题。完》</h4><p>我几乎都要忘了这是 2020 年 7 月的番剧了，从 4 月跳票到 7 月…我现在印象已经模糊了…说实话，这部番大抵就是大老师和雪乃的发糖，大老师你还记得你在第一部开篇的现充爆炸论吗Orz…</p><h4 id="2-《路人女主的养成方法-Fine》"><a href="#2-《路人女主的养成方法-Fine》" class="headerlink" title="2.《路人女主的养成方法 Fine》"></a>2.《路人女主的养成方法 Fine》</h4><p>同上面提到的春物第三季，去年暑期看的，内容的记忆已经模糊了。尽管也是发糖，但还是没忘记创业番的主题，比起春物第三季要点个赞。</p><h4 id="3-《HELLO-WORLD》"><a href="#3-《HELLO-WORLD》" class="headerlink" title="3.《HELLO WORLD》"></a>3.《HELLO WORLD》</h4><p>去影院看了 Hello World，怎么说呢，毕竟从咬文嚼字的角度来说，是电影而不是剧场版；而我对电影中的艺术表现手法向来是不怎么关心的，所以就安静地看完了一个故事，也不知道做什么评价，不置可否。话说我现在像是一个刚学会用成语的小学生，不管合适不合适就想用个成语Orz…</p><h4 id="4-《工作细胞！！》"><a href="#4-《工作细胞！！》" class="headerlink" title="4.《工作细胞！！》"></a>4.《工作细胞！！》</h4><p>印象比较深的是有益菌那两集，有弹幕说是“小蝌蚪找妈妈”。工作细胞第二部只有大概 8 集，这应该是很明智的决定了。作为卖萌向的番剧，太长了可能会腻的，还不如像这样利落地结尾。</p><h4 id="5-《剃须。然后捡到女高中生。》"><a href="#5-《剃须。然后捡到女高中生。》" class="headerlink" title="5.《剃须。然后捡到女高中生。》"></a>5.《剃须。然后捡到女高中生。》</h4><p>追到一半暂时弃了，一开始觉得剧情设计不错，台词也是直来直去的不矫情。但几集过后就开始展现熟悉的剧情和套路。从批评地角度说，给人感觉是套了个新鲜外衣的常规故事。</p><h4 id="6-《名侦探柯南》"><a href="#6-《名侦探柯南》" class="headerlink" title="6.《名侦探柯南》"></a>6.《名侦探柯南》</h4><p>很久没看柯南了，去看了安室和厨师同场的那个篇章。我总觉得柯南是作画质量下降而非单纯的画风变化，特别怀念领妹和深夜动画那个时期的作画。当然日常剧情本身还是很欢乐的。</p><h4 id="7-《逃避虽可耻但有用》SP"><a href="#7-《逃避虽可耻但有用》SP" class="headerlink" title="7. 《逃避虽可耻但有用》SP"></a>7. 《逃避虽可耻但有用》SP</h4><p>结合了疫情的剧情，总体看上去是很温馨的。只是看到百合姐和风见分手有点惊讶，但确实如剧里所说，心理年龄的差距是绕不开的问题，一个人已经开始盘算退休之后的事情，另一个人却觉得人生才刚开始。</p><h4 id="8-《昨晚过得很愉快吧》"><a href="#8-《昨晚过得很愉快吧》" class="headerlink" title="8.《昨晚过得很愉快吧》"></a>8.《昨晚过得很愉快吧》</h4><p>很早之前就知道这个剧，冲着妹子的颜值去看的。妹子好看就完事了，剧情也是如童话一般。</p><h4 id="9-《真命天女》"><a href="#9-《真命天女》" class="headerlink" title="9.《真命天女》"></a>9.《真命天女》</h4><p>S.H.E 当年主演的偶像剧，当然现在已经不会为偶像剧的剧情着迷了，但令我惊讶的是，其中很多词语用法好熟悉。</p><h3 id="游戏"><a href="#游戏" class="headerlink" title="游戏"></a>游戏</h3><h4 id="1-《他人世界末》"><a href="#1-《他人世界末》" class="headerlink" title="1.《他人世界末》"></a>1.《他人世界末》</h4><p>《他人世界末》是去年看了月夜桥的推荐去玩的，一开始因为画风的问题暂时放弃，后来继续玩才感觉到，几个主要人物的立绘是不是出自不同的画师，画风差距略明显…</p><p>打通了沈岩线和木竹樱线两条线，还把关键剧情录了下来。在我玩过的 Gal 中，《他人世界末》是《高考恋爱 100 天》之外最让我感动和印象深刻的了，特别是沈岩线的 Happy Ending。夸张点说，这条线是对 Gal 剧本的一个创新。不管是单论 Gal，还是扩大到其他文艺作品，通常剧情发展到一个看似圆满的结局就结束了，即使有后日谈也是类似演唱会安可一样给粉丝的额外赠品。但沈岩线的 Happy Ending 花了相当的篇幅描写毕业之后的事情，也就是花了相当的篇幅写一般意义结局之后的事情；而作者想表达的思想，有一部分是在这个篇章中才体现的。这样的设计使剧本显得丰富完整，同时也更能引人思考。</p><p>剧本之外，在游戏的设计上，我还是想说，越玩 Gal 越觉得现实生活步履维艰…这个词或许有点太沉重，但我也想不出更贴切的词语。打出沈岩线的 Happy Ending 需要几个选项全部正确，包括早期一个看似无关紧要的选项。当然，客观地说，和《高考恋爱 100 天》比起来，《他人世界末》已经很讲武德了。在《高考恋爱 100 天》里想打出小涵线，需要在早期特定的某天去找小涵，这个不看攻略怕是不会有太多人能发现，特别是我没怎么玩过《高考恋爱 100 天》这种养成类的游戏，对这种选项更是不敏感。</p><h4 id="2-《爱人-Lover》"><a href="#2-《爱人-Lover》" class="headerlink" title="2.《爱人 Lover》"></a>2.《爱人 Lover》</h4><p>半年来也玩了不止一个游戏，印象好的有，印象不太好也有，但总觉得还在序章里打转，没 get 到作者的想法。想了想，除了《他人世界末》，能提笔写感受大概就是《爱人 Lover》了。也不是说这个游戏有多好，只是第一个篇章打完开头，就能感受到游戏的风格和立意。</p><p>这么多游戏玩下来，难免想吐槽一句，为什么主角都带有自闭画风啊。《爱人 Lover》的主角是女性，但几乎就可以说是经典 Gal 男性主角的翻版，羞于表达、隐藏情感、循规蹈矩。好吧，Gal 的目标群体真就只有宅男宅女了吗…</p>]]></content>
    
    
    <categories>
      
      <category>日记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>一篇小木虫里的旧帖</title>
    <link href="/2021/04/14/trans-computer/"/>
    <url>/2021/04/14/trans-computer/</url>
    
    <content type="html"><![CDATA[<blockquote><p>这是 @yuerongzho 2012年12月发在小木虫的帖子，现在小木虫网站上已经看不到了，但我还存着，时隔几年再看依然感动，所以冒昧转到了个人博客上。</p></blockquote><blockquote><p>这篇帖子发布于2012年，距离现在已经9年。这9年间时过境迁，彼时移动互联网还没有爆发，深度学习还在打比赛，而现在转计算机已经成了各路专业大热的趋势。转这篇帖子，我个人的想法并不是进一步渲染转计算机的氛围，而是感受如何找到一个人想要的东西、如何去实现一个人的想法。</p></blockquote><a id="more"></a><p><strong>小硕毕业一年 从材料转做计算机</strong></p><p>硕士毕业就快一年了，昨天写年终总结，看着1、2.的一长串完成项目，就好像马拉松的中途，回头看看已经走下的这一路，原来我已不再紧张。从材料物理与化学到计算机，到现在敲着代码，看着方程式，弄着神经网络，回想起刚出来时的坎坷、迷茫，更多的是紧张和不安，现在却并没如释重负的感觉，一切显得那么平静。有时候同事会问你以前做什么的，我说做材料的，她们总会惊讶，那你怎么搞计算机了。呵呵，工作有时候就像女孩，遇到了才会惊讶。我想会有很多很多的小硕或博士有同样的梦想，将此生献给学术，这个圣神的事业，梦想着能有爱因斯坦般光辉的成就，就像《美丽心灵》中有一天别人将尊敬的钢笔放在你的面前，梦想着能在这一领域举足轻重，能够在学术上游刃有余。直到实验一天重复着一天，日子看不到尽头，然后开始怀疑，开始迷茫，开始一遍一遍的为文章的格式耗尽心力。我想可能大多数硕博士都会遇到。</p><p>工作之后，依然有许多和我做同样课题的人来问我，有硕士，也有博士，有哈工大、西北大、江南大学、兰州大学、山东大学等等，每次我都知无不言，因为我会想着那时候一个人做着课题时候的迷茫和不知所措，一个人的无助和苦闷，所以我总是尽我最大的努力告诉他们，这个理论在哪有，现在国内谁做这一块的比较多，哪些英文著作可以先了解，理论部分看哪一本教材，因为是做材料模拟，所以大部分时间会给他们说软件怎么设置，模型怎么建立。我知道我并不是个什么厉害的人物，只是进课题早点而已，所以希望可以帮帮他们，就像我那时候非常希望有个人可以帮我一样。</p><p>刚进公司，老板给我一篇英文博士论文，让我把这个算法弄出来。初出茅庐，半点不敢懈怠，每天晚上十点而归。由于刚出学校，还不习惯中午不午休，所以下午特别困，困了也不敢睡，有时候只能在厕所小眯一会。终于半个多月后给领导讲解了博士论文的大致理论，一个月后调通了MATLAB代码。虽然累，可是我比较喜欢。不用再去弄那些抄菜一般的材料，我可以一心的弄理论。我可以去用理论解开疑惑，我喜欢这种感觉。</p><p>做课题那会我想好好疏通《固体物理》和《量子力学》，那样就不用做什么都像炒菜，增加一点看怎么样，不行再减少一点看怎么样。可是不行，导师总会催文章，美其名曰只要结果不问过程，我看着周围所有的导师都这样，所以没有半点兴趣读博，我也不相信我会找到一个和我有一致想法的导师。从考研起，我就知道为什么要读这个硕士，所以当不再像我希望那样时，我走了出来，我相信一个人的天空依然可以灿烂。</p><p>后来公司领导让我弄小波去噪，替换现有软件中的ＦＦＴ（快速傅里叶变换）算法（因为ＦＦＴ会有边际效应和滤波后的正弦波效应），我从不知道什么是小波，更别提写小波程序。两个月后完成了MATLAB和Ｃ＋＋的小波去噪程序，随便用小波做了个压缩程序，压缩比可以达到只有原来数据的２５％，甚至更高，这对于单片机向计算机发数据是很有用的。期间学会了Ｃ＋＋的入门，ＶＳ、ＱＴ的基本使用。从最开始的老大说你Ｃ＋＋基础太差了，确实差，因为我没学过，到后来自己完成Ｃ＋＋ＧＵＩ界面调试程序和类的编写，还有理论的理解。总共应该差不多三个月的时间，看过的ｐｄｆ专业书籍能列出来的应该不少于十本。每天差不多晚上十点下班，不过我周末很少加班，我不喜欢工作狂。努力只是一种姿态，不能成为全部。</p><p>空闲的时候会来逛逛小木虫，会看到各种各样的苦闷，有和自己相同的，有些不同的，但我想生活方式多种多样，也不定说哪种一定好，但我始终坚信，应该有一条属于自己最佳的，就像费曼的最小作用原理一样。我很怕自己写的东西最后像那种说教式的，本科的时候我不断的要求自己去看书，各种各样的，没有别的目的，只是想着我可以多看看别人的路，然后去想、去选择一条我最合适，或者说自己最喜欢的路。也出于这种目的，我想给那些和我有相同经历的人看看我这样的一条路，路不一定是最好的，有点启发就好。</p>]]></content>
    
    
    <categories>
      
      <category>梦里的棉花糖</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>2020 年终总结：只一眼，梵音也渐远</title>
    <link href="/2021/01/12/2020-summary/"/>
    <url>/2021/01/12/2020-summary/</url>
    
    <content type="html"><![CDATA[<blockquote><p>若非那年 总角放纸鸢</p><p>风中断线 恣意翩跹</p><p>空旷禅院 独落你脚边</p><p>只一眼 梵音也渐远</p><p>——《青溪渡雪》</p></blockquote><p>因为疫情，回望2020年，显得尤为短暂。仿佛前两天还是2020年寒假前坐在屏幕前敲代码的时光，现在却是另一番光景。</p><a id="more"></a><h3 id="工作与学习"><a href="#工作与学习" class="headerlink" title="工作与学习"></a>工作与学习</h3><p>10月底的时候，和P见了一面，把我暑假以及9月的经历和P简单说了一下。P说，“你胆子还真大”。也确实是这样，面试的时候没有太多感觉，但结束之后回想，些许有股不知天高地厚的样子。</p><p>由此前推，我在面试时说得最多的，或者说面试官最感兴趣的，还是我4月份之后以及6月回到学校期间做的东西。这也让我感受到一个朴素的道理，前行的路、积累的过程，并不是线性的。如果走到一半或者快到尽头时放弃，得到的往往不是50%或者85%，而很可能只有10%。</p><p>而回望这一年的学习和工作，最深的感受就是，心态和环境真的影响很大。新年刚过，起步阶段，状态很好；刚回家时，换了新环境，效率也很高；然后就开始了情绪波动，状态萎靡，不过幸好坚持做了去雾的项目，萎靡中的坚持同样重要，甚至更可贵，这才是告别”在感叹时光流失中让时光再次流失”的方法；回到学校，又是经历从高效到颓废的变化，后期有相当一段时间都在打游戏。好在最后能找回状态。</p><p>在2020的最后一天，和同组的老师同学畅谈了过去的经历，当我能平淡甚至面带笑容说出过去不愿回想的经历，我应该算是从过去走出了吧。在11月、12月的时候，我对我自己说，让自己得到救赎，大概就是如此。</p><h3 id="之前的路"><a href="#之前的路" class="headerlink" title="之前的路"></a>之前的路</h3><p>疫情期间，闷在家里，每天刷手机刷网络。先是在知乎上看到了一位当年吧友，之后便心血来潮翻过去的帖子，再后便是偶然搜到了龙崎和余哥的主页，得知了他们的近况。原来他们一直都没有离开，只是换了一种方式存在。那时候我受了很大的…心理波动吧，“感觉命运给我开了一个玩笑”。就像我在年末和同组同学说的那样，大家都当真了，只有我在开玩笑。能够为自己做选择，能够去追逐热爱的事情，这是一件多么好的事情啊。就像《四月》里说的那样，“喜欢和不讨厌之间，可是隔了数亿光年都不止的距离”。</p><p>疫情给我上网方式带来的另一个变化，是让我回归了传统的论坛和bbs的交流方式。时不时会在论坛上看到一些感叹个人生活的帖子，无论他们的年龄比我小还是大，大部分时候我都会感觉，我自己已经能够不再为类似的事情感慨了，这大概就是我长大了吧。</p><p>在Github上交流，这对我是一个全新的体验，感觉很愉快。而在现实中，或者是在带有现实的微信中，也尝试了和陌生人去交流，那种破冰的感觉，也很久不曾体验了。</p><h3 id="生活、做饭"><a href="#生活、做饭" class="headerlink" title="生活、做饭"></a>生活、做饭</h3><p>疫情的又一个影响，我开始做饭了。从煮挂面开始，到煮菜煮鸡胸肉，再到炒菜烩菜。看了那么多烹饪视频，终于有了行动，而小时候常常幻想的做饭场景也终于成为了现实。</p><p>开始真正的做饭，应该说正是疫情闷在家里快闷坏了的阶段。做一顿饭，确实是生活中很好的调剂。</p><p>到了5月，疫情渐渐消退，我也终于挪出了家门，经常性地出门走走。虽然通常只是买杯咖啡带回家，但也足够呼吸新鲜空气了。虽然家在县城，但比村里的学校还是方便多了，走不远就是肯德基和麦当劳。话说肯德基的大神卡买咖啡真的很划算，肯德基的咖啡也不比星巴克差，至少我喝不出来。</p><p>回到学校之后，尝试了多种咖啡，从速溶黑咖啡到手冲。第一次泡手冲，推开宿舍门，真是满屋的香气。后来了解了一些咖啡知识，知道了星巴克等咖啡馆，拿铁也是要加奶泡的，而奶泡是用商业级设备打出来的，家里面很难复现。所以我终于明白了，为什么自己兑的咖啡牛奶、肯德基的拿铁，和星巴克的味道总是不一样了。但回到主题，我用手冲泡出来的咖啡，和星巴克的美式，喝不出区别。原来3块钱也能做到30块钱的效果。</p><h3 id="结语以及之后"><a href="#结语以及之后" class="headerlink" title="结语以及之后"></a>结语以及之后</h3><p>有的时候会感觉，想努力却没有平台。所谓“比你优秀的比你还努力”，问题并不一定出在思想和自制力上，而是由于不知道怎么跳出无效的努力，或者找不到有效的平台。相反地，当我找到属于我的铁轨之后，并不是工作结束了，而是我能给我自己提供一个方向。所谓“成长的烦恼”、已经OK了为什么还要继续，可以批判地看待这些话，但不得不说反映了客观的道理。</p><p>大概这就是2020年了。写年终总结的时候，因为有些事情过去的比较久了，记不太清了，年终总结往往会变成季度总结+新一年的flag。但还是要尽量避免。我希望这一年能沉淀下一些东西，而不是把近期还未成熟的感受强化。</p>]]></content>
    
    
    <categories>
      
      <category>日记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>2020 年中书单/影评：在终止彷徨，在结束动荡</title>
    <link href="/2020/07/28/2020-mid-books/"/>
    <url>/2020/07/28/2020-mid-books/</url>
    
    <content type="html"><![CDATA[<blockquote><p>你在终止彷徨  你在结束动荡</p><p>你成为垂衣驭八荒的王</p><p>你低下头与我相望  将金色徽章戴在我肩膀</p><p>你眼中分明蛰藏  锁死我危险却迷人的欲望</p><p>——《国境四方》</p></blockquote><p>开了一个新系列，记载 2019 年下半年至 2020 年上半年读过的书和看过的视频。</p><a id="more"></a><h3 id="技术类书籍"><a href="#技术类书籍" class="headerlink" title="技术类书籍"></a>技术类书籍</h3><h4 id="1-《深入理解-C-指针》"><a href="#1-《深入理解-C-指针》" class="headerlink" title="1.《深入理解 C 指针》"></a>1.《深入理解 C 指针》</h4><p>推荐指数：★ ★ ★ ★ ★</p><p>这段时间以来看的书，首推这本《深入理解 C 指针》。这是一本超越了字典/百科全书式的各类 C/C++ 教程的专项书籍，是进阶的开端书籍。看这本书大概是在 2019 年 12 月，当时正在写 JincResize 和 AreaResize，刚接触图像处理中双重 for 循环遍历元素与指针移动的过程，看这本书让我迅速理解了上述内容。</p><h4 id="2-《现代-C-教程：高速上手-C-11-14-17-20》"><a href="#2-《现代-C-教程：高速上手-C-11-14-17-20》" class="headerlink" title="2.《现代 C++ 教程：高速上手 C++11/14/17/20》"></a>2.《现代 C++ 教程：高速上手 C++11/14/17/20》</h4><p>推荐指数：★ ★ ★ ★ ★</p><p>龙崎哥写的开源书籍， Github 仓库在<a href="https://github.com/changkun/modern-cpp-tutorial" target="_blank" rel="noopener">这里</a>。</p><p>龙崎哥是真的厉害，我只记得当年在数吧里看到他提了一下，说在学 C++。没想到写出了这么棒的书。</p><p>我主要是 2020 年 2 月 ~ 3 月在看这本书，没有太注意 C++ 20 的内容（毕竟在不断更新中）。如龙崎哥所言，这本书由于各章节独立，适合零碎的阅读、查阅。我主要看了智能指针部分，其次是一些相对零碎的新特性，而多线程部分虽然看了…但没看太懂。</p><p>会感慨固然人生路远，但能遇见的人就这么多，当年仰慕的人并没有消失，只是换了一种方式存在。题记中引用了一首歌，《国境四方》，我想表达的便是这个含义。</p><h4 id="3-《OpenCV-3-编程入门》"><a href="#3-《OpenCV-3-编程入门》" class="headerlink" title="3.《OpenCV 3 编程入门》"></a>3.《OpenCV 3 编程入门》</h4><p>推荐指数：★ ★ ★ ★ ★（新手视角）| ★ ★ ★ ★ ☆（一般视角）</p><p>适合新手阅读的一本书，书的内容包括如下几个部分：1.编程扫盲部分，讲了变量命名规则与习惯、C/C++ 的一些常识；2. OpenCV 3 入门部分，讲了 OpenCV 3 的一些设计思路和数据结构；3.逐条讲解主要函数，同时讲了一些图像处理的基础理论。在 2019 年 11月 ~ 2020 年 2 月看了这本书，不得不说让懵懂的我学了很多，但站在一般向的视角上，内容略显简单（当然，对于封装这么成熟的 OpenCV，把书写复杂可能既不容易也没必要）。</p><h4 id="4-《21-天学通-C-》"><a href="#4-《21-天学通-C-》" class="headerlink" title="4.《21 天学通 C++》"></a>4.《21 天学通 C++》</h4><p>推荐指数：★ ★ ★ ★ ☆</p><p>没什么好说的，这是我用来当手册/字典的书籍，大概可以分为三部分：C/C++ 通用语法、C++ 特性语法、STL 库。这本书我好像没有在博文中看到过有人推荐，接触这本书因为《21 天实战 Caffe》，后者的作者说他就是在《21 天学通 C++》启发下写了《21 天实战 Caffe》。</p><p>但有一说一，《21 天实战 Caffe》真的是分了 21 个章节，而《21 天学通 C++》…除了书名之外，好像没看到和 21 相关的东西 Orz…</p><h4 id="5-《C-C-常用算法手册》"><a href="#5-《C-C-常用算法手册》" class="headerlink" title="5.《C/C++ 常用算法手册》"></a>5.《C/C++ 常用算法手册》</h4><p>推荐指数：★ ★ ★ ☆</p><p>很基础的书籍，讲了常见的数据结构和基础的算法，适合新手，也是我在浮躁状态下难得读得进去的书。但平心而论，书的内容本身并谈不上有多好，代码风格陈旧且不说，前后代码重复让人感觉有点冗杂。</p><h3 id="文学类书籍"><a href="#文学类书籍" class="headerlink" title="文学类书籍"></a>文学类书籍</h3><h4 id="1-《文在寅自传：命运》"><a href="#1-《文在寅自传：命运》" class="headerlink" title="1.《文在寅自传：命运》"></a>1.《文在寅自传：命运》</h4><p>本来不想提到这本书的，因为避免谈政治。只是书的一句话印象太深刻了，“愿为江水，与君同行”。</p><h4 id="2-《透过机器人与你相恋》"><a href="#2-《透过机器人与你相恋》" class="headerlink" title="2.《透过机器人与你相恋》"></a>2.《透过机器人与你相恋》</h4><p>轻小说。接触这本书是因为插画师 loundraw。早前在 P 站看到 loundraw 的一幅画，还用来当了一段时间的台式机壁纸。没想到这幅画同样是《透过机器人与你相恋》的封面图，于是就把小说买来看了。目前只看了开头，还没有看到故事的核心。</p><h3 id="网课"><a href="#网课" class="headerlink" title="网课"></a>网课</h3><p>点开看过的网课有以下几个。</p><p><strong>1.某培训班的通用 C++ 网课</strong></p><p><strong>2.国防科大《编译原理》</strong></p><p><strong>3.郝斌《数据结构》</strong></p><p><strong>4.北理工 2020 冬季 ACM 培训</strong></p><p><strong>5.某编程算法教程</strong></p><p>这几个网课收获都不小。应该说第一个 C++ 网课没什么特色，但对于新手还是友好的。第二个编译原理网课虽然只是浅看，但很受启发，确实有种“学了编译原理你就明白了的感觉”。重点看的是第三、四个，数据结构的入门和 STL 库的讲解（众所周知，ACM 用的 C++ = C + STL）。最后一个是付费购买的，面向面试的教程，物有所值。</p><h3 id="影视"><a href="#影视" class="headerlink" title="影视"></a>影视</h3><h4 id="1-《樱花庄的宠物女孩》"><a href="#1-《樱花庄的宠物女孩》" class="headerlink" title="1.《樱花庄的宠物女孩》"></a>1.《樱花庄的宠物女孩》</h4><p>2019 年下半年开了三部番，《冰菓》、《境界的彼方》、《樱花庄》，前两者没有弃但到现在都没看完，《樱花庄的宠物女孩》是日常向，所以看得进度快。这三部番陪着我走过了 2019 年 9 月到 12 月，从轻松到迷茫再到找到方向。</p><p>《樱花庄》里的生活确实让人羡慕，但或许因为我不是天才吧，若客观地分析人物塑造，还是有些贴标签的感觉。剧中的人物塑造方式，对于龙哥这样的配角而言，没什么问题，感觉不到贴标签，简略描写增加的神秘感反而更适合龙哥。三鹰学长学姐倒也没什么问题，一开始贴上两个人都能力超群的标签，但进一步的剧情展开则说明，看似无所不能的学长，专业技能反倒逊色于嘻嘻哈哈的学姐，这提供了戏剧冲突，也让人物形象丰满了一些，对于配角也可以了。但说到主角真白，仍把塑造配角的方式拿来用，就感觉有些僵硬。</p><p>不过嘛，《樱花庄》毕竟是在日常基础上深入的，看的时候让人开心和感动就足够了。</p><h4 id="2-《狼与香辛料》第一季"><a href="#2-《狼与香辛料》第一季" class="headerlink" title="2.《狼与香辛料》第一季"></a>2.《狼与香辛料》第一季</h4><p>同样是在 2019 年下半年看的，没和上面三部番写到一起，是觉得风格不太一样。这部番被调侃为“夫妻行骗记”，但我更喜欢另一个评价，这部番是把女性作为独立个体的番剧。且不和一众后宫番比较，就是和非后宫普通番剧乃至没什么男性的百合番相比，能把女性独立人格塑造出来，除了《狼与香辛料》，我看过的番中只有柯南剧场版《战栗的乐谱》。</p><h4 id="3-《非自然死亡》"><a href="#3-《非自然死亡》" class="headerlink" title="3.《非自然死亡》"></a>3.《非自然死亡》</h4><p>好剧，不需要多说。特别是在新冠疫情的背景下，第一集甚至有了代入感。每一集的片尾曲《Lemon》都是神插入。看《境界的彼方》时，弹幕经常说 OP 神插入，但我倒没有明显感觉。片中时不时出现的名台词，可以当壁纸的石原里美的名场景，更让人印象深刻。而六郎对人生的思考，也让当时迷茫的我有了共鸣。</p><p>在主要剧情之外，看这部剧时不时会跳戏，且不说作为所长的<del>五郎</del>（欸，所长名字是啥来着？），光是里面的名字就让人跳戏，美琴、想见美琴的白井同学、神经大条的毛利警官。</p><p>喜欢 B 站的一条评论，看这部剧还能因为 cp 掐起来，应该把脑子泡在福尔马林里。</p><h4 id="4-《理科生坠入情网，故尝试证明。》"><a href="#4-《理科生坠入情网，故尝试证明。》" class="headerlink" title="4.《理科生坠入情网，故尝试证明。》"></a>4.《理科生坠入情网，故尝试证明。》</h4><p>应该是这一年追的唯一一部新番，也不能叫追，因为不知道是网飞还是亚马逊加持，一次性更完 12 集。虽然还是让人感觉有些夸张，就是这类番剧中常见的过分夸张数理知识的感觉。但一些细节还是有意思的，真的很佩服在 Ubuntu 下玩 galgame 的师弟，不知是创作者是真在 Linux 下玩过 galgame，还是只是单纯营造人设。</p><h4 id="5-《无法成为野兽的我们》"><a href="#5-《无法成为野兽的我们》" class="headerlink" title="5.《无法成为野兽的我们》"></a>5.《无法成为野兽的我们》</h4><p>冲着新垣结衣去看的，但可能是我还没有步入职场吧，感触一般。</p><h4 id="6-《轻音少女》第一季"><a href="#6-《轻音少女》第一季" class="headerlink" title="6.《轻音少女》第一季"></a>6.《轻音少女》第一季</h4><p>治愈的日常番。</p><h4 id="7-《Fate-stay-night-Heaven’s-Feel-II-lost-butterfly》"><a href="#7-《Fate-stay-night-Heaven’s-Feel-II-lost-butterfly》" class="headerlink" title="7.《Fate/stay night [Heaven’s Feel] II.lost butterfly》"></a>7.《Fate/stay night [Heaven’s Feel] II.lost butterfly》</h4><p>在 2019 年 7 月还是 8 月，和 G 和 H 去电影院看的。因为在七八月份，就写了进来，其实从心境上看，应该归到上半年。电影院里的感受自然和十几寸二十几寸的屏幕不一样，特别是对于 Fate 这种大制作的番剧。樱真的惹人喜欢。</p>]]></content>
    
    
    <categories>
      
      <category>日记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>DehazingCE：基于对比度增强的去雾算法及 VapourSynth 迁移</title>
    <link href="/2020/06/26/dehazingce-port/"/>
    <url>/2020/06/26/dehazingce-port/</url>
    
    <content type="html"><![CDATA[<p>这一去雾算法在2013年提出，论文见 <a href="http://mcl.korea.ac.kr/projects/dehazing/#userconsent#" target="_blank" rel="noopener">Optimized contrast enhancement for real-time image and video dehazing</a>，我们称其为 DehazingCE （CE = contrast enhancement）。</p><h3 id="算法概述"><a href="#算法概述" class="headerlink" title="算法概述"></a>算法概述</h3><p>DehazingCE 基于大气散射模型，分别估计大气光强度和透射率，得到去雾结果。</p><a id="more"></a><p>大气光估计通过图像分块、寻找像素差异最小的子块，以该子块最亮的点作为大气光的估计值。但这里存在一个问题，不知道是我理解有问题，还是我代码迁移有问题，或者算法本身就有问题。如果图像整体偏暗，那寻找到的子块就会很暗，最后以一个像素值很小的点作为大气光估计值，用这个值继续计算，最终结果就是全黑。我对迁移到 VapourSynth 的代码进行测试，确实发现了这一问题。</p><p>透射率估计分为粗算和细化两步。粗算是基于大气散射模型进行次数不多的迭代，并自定义像素损失值（大气散射模型的直接计算结果可能会超过 [0, peak]，导致像素越界）以决定是否继续迭代。细化通过导向滤波实现。</p><p>后处理包括 Gamma 亮度调整和类似均值滤波的均值化计算。前者是避免去雾后图像过暗，后者是避免透射率过低时导致的块效应。在我迁移的代码中，Gamma 亮度调整表现不错，但均值化计算可能是我的代码还有问题，测试结果是不如不做，做了反而凭空多了瑕疵。</p><h3 id="代码迁移"><a href="#代码迁移" class="headerlink" title="代码迁移"></a>代码迁移</h3><p>代码迁移着实花了很久，满打满算从 4 月份开始读原始代码，到 6 月份完成初版的迁移，几乎花了两个月…原始代码风格很古典，着实有点费力。</p><h4 id="从-OpenCV-2-到-OpenCV-3"><a href="#从-OpenCV-2-到-OpenCV-3" class="headerlink" title="从 OpenCV 2 到 OpenCV 3"></a>从 OpenCV 2 到 OpenCV 3</h4><p>在最开始，我觉得一下子迁移到 VapourSynth 有点费力，便想尝试着把原始代码先跑起来。原始代码基于 OpenCV 2，存储图像还是用的 IplImage 指针而非 Mat 类。这一部分工作在<a href="https://kiyamou.github.io/2020/04/28/dehazing/" target="_blank" rel="noopener">前面的博文</a>有提到。但折腾好久，也没把原始代码跑起来，最后放弃了，直接迁移。</p><h4 id="YUV-还是-RGB"><a href="#YUV-还是-RGB" class="headerlink" title="YUV 还是 RGB"></a>YUV 还是 RGB</h4><p>在着手迁移之初，是先支持 YUV 还是先支持 RGB 纠结了好久。其中一部分原因是我还没完全搞懂原始代码的处理流程，从大气光估计部分看，原始代码用的是 RGB 格式，从透射率估计看，原始代码既有只算灰度的（这像是面向 YUV），又有 RGB 三个通道都计算的。最后决定先支持 RGB（因为我先读明白了原始代码的大气光估计部分，沿用了这一部分的 RGB 格式）。</p><h4 id="数据结构的转换与基础操作的迁移"><a href="#数据结构的转换与基础操作的迁移" class="headerlink" title="数据结构的转换与基础操作的迁移"></a>数据结构的转换与基础操作的迁移</h4><p>确定 RGB 后便开始转换图像数据结构，为减少工作量，尽量不去动原始代码的函数输入输出模式，把 VapourSynth 接口传递过来的图像指针转化为普通指针，送给核心计算函数。在这个过程中，我越来越感觉到 VapourSynth 接口的概念，或者什么叫接口。我渐渐懂得把核心处理剥离开，不再依赖 VapourSynth API 提供的数据类型，而是使用普通指针和数组完成核心计算，在把结果送给 VapourSynth API。</p><p>在计算过程中需要进行图像分块、计算图像像素值均值和标准差。在原始代码中，这些操作都是使用的 OpenCV 函数。对于这些并不复杂的操作，我自然不能接受调用第三方库来实现。图像分块最开始是用两层 for 循环赋值，后来才想到用<code>memcpy()</code>函数直接拷贝。计算均值和标准差直接 copy 了一份代码。</p><p>完成上述操作后，迁移过程就没什么困难的了，写个集成函数去调用各步计算即可。</p><h4 id="VapourSynth-API-的一些事情"><a href="#VapourSynth-API-的一些事情" class="headerlink" title="VapourSynth API 的一些事情"></a>VapourSynth API 的一些事情</h4><p>虽说已经没有大的困难，但具体细节上还是要花时间的。我之前没有写过 ref 参考片段，之前也不知道 VapourSynth 接口没有提供 bool 类型。好在有前辈们写成的其他滤镜，有很多可以参考（copy）的代码。</p><h3 id="Debug"><a href="#Debug" class="headerlink" title="Debug"></a>Debug</h3><h4 id="指针读取冲突"><a href="#指针读取冲突" class="headerlink" title="指针读取冲突"></a>指针读取冲突</h4><p> 读取位置 … 时发生访问冲突。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">srcInterleaved[pos] = srcpB[x];<br>srcInterleaved[pos + <span class="hljs-number">1</span>] = srcpG[x];<br></code></pre></td></tr></table></figure><p>这里就出问题是我没有想到的，因为这部分代码之前在AreaResize中已经用过了，没有问题。</p><p>回到报错本身，“发生访问冲突”表明指针访问内存时出问题了，指针指向了不属于自己的内存地址，是一个基础的问题。</p><p>发现在vs接口部分忘记释放ref，释放之后同样报访问冲突，但这次的报错位置是大气光估计函数的图像分块位置，这才是意料之中（这部分代码最开始写的时候就迷迷糊糊的）。</p><p>但另一个引发该错误的原因就很蠢了，假如读入的不是 RGB 格式，而是 YUV 格式，也会引发该错误。这是自然的，YUV 的第二、三个通道的宽高分别是第一个通道的一半，自然会越界。</p><h3 id="构建与C-语法"><a href="#构建与C-语法" class="headerlink" title="构建与C++语法"></a>构建与C++语法</h3><p>从这次开始我使用了 cmake 进行构建，一开始都是一些技术问题，直到部署 CI 的时候，才通过 cmake 意识到一些 C++ 语法的问题，一些我在很早的时候就看到过但没有读懂的问题。</p><h4 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h4><p>智能指针是 C++11 引入的，但<code>std::make_unique</code>被忘记写入标准了，直到 C++14 才被引入…</p><h4 id="noexcept"><a href="#noexcept" class="headerlink" title="noexcept"></a>noexcept</h4><p><code>noexcept</code>在 C++11 引入。</p><p>不搞清这些标准问题，在 travis-ci 的编译器上会报错…</p><h3 id="高位深支持"><a href="#高位深支持" class="headerlink" title="高位深支持"></a>高位深支持</h3><p>高位深支持需要解决两个方面的问题，一是算法本身计算过程的修改，这一部分我改到现在还是有问题…图像暗场处理后会直接变黑…另一是C++语法的问题，带有模板的成员函数怎么写。</p><h4 id="语法层面的问题"><a href="#语法层面的问题" class="headerlink" title="语法层面的问题"></a>语法层面的问题</h4><p>我之前用模板，借用做饭的话说就是现用现做，而成员函数的声明和定义分开写在两个文件中，这时候再用模板就会出现链接器错误。但把声明和定义写在一起我不太愿意这么搞，于是折中的办法是在 main.cpp 同时 include 含有声明的 .h 和定义的 .cpp 文件。</p><h4 id="算法层面的问题"><a href="#算法层面的问题" class="headerlink" title="算法层面的问题"></a>算法层面的问题</h4><p>按照惯例，至少对于从 8bit 到 16bit 的扩充，把类似含有 255 的地方改成 peak 就可以了，但这次遇到了不少问题。</p>]]></content>
    
    
    <categories>
      
      <category>图像处理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>构建与编译</tag>
      
      <tag>C++</tag>
      
      <tag>VapourSynth</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《饥荒》食谱个人点评</title>
    <link href="/2020/05/30/Dont-starve/"/>
    <url>/2020/05/30/Dont-starve/</url>
    
    <content type="html"><![CDATA[<h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>这几天一直在玩《饥荒》，起因是想起大一和几个室友联机打游戏的场景；而且虽然我已经在 Steam 补票，但一直没怎么玩，于是重新开始，沉迷了几天。写一写这几天打游戏的感受，主要是点评食谱以及围绕食谱展开的生存模式。</p><a id="more"></a><p>内容比较基础，适合萌新观看。</p><p>额…再多说两句，我玩的是《饥荒》原始版，而大部分教程以及攻略都是基于《饥荒》巨人国DLC 展开的，在巨人王朝中添加了很多新内容，食谱也随之丰富，所以我的内容会比较少。</p><p><strong>Update</strong>：之后我买了巨人国DLC，又在夏日特卖时买了海滩DLC，所以对食谱做了少量更新，仍然是围绕基础版/巨人国展开，海滩的内容只加入了甘薯和咖啡豆（前者在兼容海滩的巨人国中也能种植获得，后者可以通过海滩穿越带到巨人国中）。</p><h3 id="我的食物风格"><a href="#我的食物风格" class="headerlink" title="我的食物风格"></a>我的食物风格</h3><p>我玩《饥荒》的风格可以概括为农场怪兽流，就是农场派+以怪兽肉为主要肉类，除了养一只鸟、一个蜂巢外，没有采取养猪、养兔子、捉火鸡等牧场派喜欢的模式。建猪舍只是因为之前没玩过，在开局早期倒是经常捉兔子，但之后就很少干了，而火鸡更是随缘。</p><h3 id="食物属性"><a href="#食物属性" class="headerlink" title="食物属性"></a>食物属性</h3><p>说食谱之前先整理一下食物属性，《饥荒》里将食物分为肉、蔬菜、水果、蛋、甜品等，并分别定义的了肉度、蔬菜度、果度、蛋度、甜品度（鱼还有鱼度，但基础版/巨人国中似乎用不上）。此外树枝、冰块在一定条件下也可以作为食谱填充物。</p><ul><li><strong>肉度</strong><ul><li>1.0 肉度：大肉、怪兽肉</li><li>0.5 肉度：小肉块、鱼、青蛙腿、鸡腿</li></ul></li><li><strong>蔬菜度</strong><ul><li>1.0 蔬菜度：各种蔬菜，包括夏季限定的仙人掌花</li><li>0.5 蔬菜度：红绿蓝三种颜色的蘑菇</li></ul></li><li><strong>果度</strong><ul><li>1.0 果度：各种水果</li><li>0.5 果度：浆果、咖啡豆（兼容海滩后从海滩穿越到巨人国可得）</li></ul></li><li><strong>蛋度</strong><ul><li>2.0 蛋度：高脚鸟蛋</li><li>1.0 蛋度：蛋（鸟蛋和企鹅蛋都是这同一个东西）</li></ul></li><li><strong>甜品度</strong><ul><li>蜂蜜和蜂巢，甜品度一样</li><li>非联机版无蜂王浆，不用考虑甜品度的问题</li></ul></li><li><strong>奶制品</strong><ul><li>羊奶、黄油</li><li>没有需要大于一个奶制品的食谱，所以奶制品不用考虑“度”的问题</li></ul></li><li><strong>鱼度</strong><ul><li>同样不甚了解，基础版与巨人国不用考虑，只有鱼和鳗鱼，鱼度一样</li></ul></li><li><strong>怪兽肉度</strong><ul><li>1.0 怪兽肉度：怪兽肉、榴莲（没有树枝的前提下，两个怪兽肉度会做出怪兽肉千层饼）</li></ul></li></ul><h3 id="我的食谱"><a href="#我的食谱" class="headerlink" title="我的食谱"></a>我的食谱</h3><p>正式开始说食谱，我个人将食谱分成如下几类。</p><p>在说食谱之前再啰嗦几句，由于肉丸是广为人知且较易得的饱食食谱，所以我的食谱主要侧重于回血与恢复精神。</p><p>对于回血，由蜘蛛腺体制作的治疗药膏可以回 20 血，以此为基准，大于 20 血的食谱都可以视为回血食谱。</p><p>对于恢复精神，大部分食物都只能加 5 精神，常见的恢复精神食谱包括蜂蜜类、冰类。</p><h4 id="喜欢且常做的食谱"><a href="#喜欢且常做的食谱" class="headerlink" title="喜欢且常做的食谱"></a>喜欢且常做的食谱</h4><ul><li><p><strong>波兰水饺</strong></p><p>波兰水饺是在我养鸟之后，最喜欢的食谱之一，有时候怪兽肉很多吃不完，做风干怪兽肉有点坑，把怪兽肉喂给鸟、变成蛋，就可以做波兰水饺了。</p><ul><li><strong>食谱属性</strong>：<strong>37.5 饱食、40 血、5 精神</strong>、20 秒烹饪、20 天保存</li><li><strong>通用食谱</strong>：1.0 蛋度 + 0.5 肉度 + 0.5 蔬菜度 + 其他（不能有树枝）</li><li><strong>我的食谱</strong>：一个蛋 + 一个怪兽肉 + 一个蔬菜或一个蘑菇 + 一个浆果或其他水果（注意不能有榴莲）</li><li><strong>额外说明</strong>：如前面所说，《饥荒》的食物属性中还有一个“怪兽肉度”，虽名为“肉度”，但并不限于肉，常见的怪兽肉、榴莲都是一个怪兽肉度。食谱中若包含两个怪兽肉度，则会做出不讨人喜欢的怪兽肉千层饼。所以一个怪兽肉加一个榴莲等效于两个怪兽肉，都会做出怪兽肉千层饼。</li></ul><p><strong>点评</strong>：回血神器、解决吃不完的怪兽肉、允许蘑菇给缺少蔬菜的冬季带来可能、保存时间也不错。</p></li><li><p><strong>火龙果派</strong></p><p>因为有农场，火龙果包括下面的南瓜都是比较容易获得的，所以很推荐又回血又饱腹制作简单粗暴的</p><ul><li><strong>食谱属性</strong>：<strong>75 饱食、40 血、5 精神</strong>、40 秒烹饪、15 天保存</li><li><strong>通用食谱</strong>：一个火龙果 + 其他（不能有肉）</li><li><strong>我的食谱</strong>：一个火龙果 + 三个树枝</li></ul><p><strong>点评</strong>：回血神器、饱食值也很高、能用三个树枝直接填满、保质期长，农场派的神器，特别是养鸟之后，可以得到火龙果种子。</p></li><li><p><strong>太妃糖、南瓜饼干</strong></p><p>这两个都是用来恢复精神的，而且主要依赖蜂蜜，所以放在了一起。</p><ul><li><p><strong>太妃糖</strong></p><ul><li><strong>食谱属性</strong>：<strong>25 饱食、-3 血、15 精神</strong>、40 秒烹饪、15 天保存</li><li><strong>通用食谱</strong>：三个蜂蜜或蜂巢 + 其他（不能有肉）</li><li><strong>我的食谱</strong>：三个蜂蜜 +一个树枝</li></ul></li><li><p><strong>南瓜饼干</strong></p><ul><li><strong>食谱属性</strong>：<strong>37.5 饱食、0 血、15 精神</strong>、40 秒烹饪、10 天保存</li><li><strong>通用食谱</strong>：一个南瓜 + 两个蜂蜜或蜂巢 + 其他（可以有肉，什么都可以）</li><li><strong>我的食谱</strong>：一个南瓜 + 两个蜂蜜 + 一个树枝</li></ul></li><li><p><strong>额外说明</strong> </p><ul><li>“三个蜂蜜或蜂巢 + 一个南瓜”做出上述两种食品的概率各为50%（当然也没理由这么做）</li><li>这两种食品优先度相当高，在其他大部分食谱中，都不能以曼德拉草为填充物（当然同样没理由把珍贵的曼德拉草来烹饪一般食物，所以上面没有提），但这两种食品都可以以曼德拉草为填充物，做出对应食品或曼德拉草汤的概率各为50%</li></ul></li></ul><p><strong>点评</strong>：回 san 食谱，虽然看上去需要很多蜂蜜，但其实养一个蜂巢就够了。由于生吃南瓜就可以得到 37.5 饱食和 3 点血，烤南瓜则提高到 8 点血，所以在蜂蜜充足的情况下，完全建议做太妃糖而不是南瓜饼，太妃糖扣的血量靠吃南瓜就可以弥补，还能增加更多的饱食度。</p><p>假如有三个蜂蜜 + 一个南瓜，两种组合方式及效果如下。</p><table><thead><tr><th align="center">食谱</th><th align="center">太妃糖 + 烤南瓜</th><th align="center">南瓜饼 + 蜂蜜</th></tr></thead><tbody><tr><td align="center">饱食</td><td align="center">25 + 37.5 = 62.5</td><td align="center">37.5 + 9.375 = 46.875</td></tr><tr><td align="center">血量</td><td align="center">-3 + 8 = 5</td><td align="center">0 + 3 = 3</td></tr><tr><td align="center">san 值</td><td align="center">15</td><td align="center">15</td></tr></tbody></table><p>“太妃糖 + 烤南瓜”的饱食度赶上一个肉丸了有木有？！</p></li><li><p><strong>西瓜冰</strong></p><ul><li><strong>食谱属性</strong>：<strong>12.5 饱食、3 血、20 精神</strong>、10 秒烹饪、3 天保存</li><li><strong>通用食谱</strong>：一个生西瓜 + 一个冰 + 一个树枝 + 填充物（不能是肉、蛋、蔬菜）</li><li><strong>我的食谱</strong>：一个生西瓜 + 一个冰 + 两个树枝</li></ul><p><strong>点评</strong>：<strong>西瓜为巨人国DLC增加</strong>，回 san 食谱，比太妃糖/南瓜饼回 san 更高，但西瓜毕竟是种出来的，而且保存期不是很长，不像太妃糖那样存着蜂蜜想做随时都有（其实单从回 san 角度，烤绿蘑菇是最简单粗暴的了，但毕竟还要趁着黄昏去桦树林或沼泽摘蘑菇，不像太妃糖那样宅在家里饭来张口。嗯…在游戏里我也喜欢宅 Orz…）。</p></li><li><p><strong>培根煎蛋</strong></p><ul><li><strong>食谱属性</strong>：<strong>75 饱食、20 血、5 精神</strong>、40 秒烹饪、20 天保存</li><li><strong>通用食谱</strong>：2.0 蛋度 + 至少 1.5 肉度</li><li><strong>我的食谱</strong>：两个蛋 + 一个怪兽肉 + 一个小肉</li></ul><p><strong>点评</strong>：保质期长的饱食回血食谱，可以视为增强版的肉丸。</p></li><li><p><strong>肉丸</strong></p><ul><li><strong>食谱属性</strong>：<strong>62.5 饱食、3 血、5 精神</strong>、15 秒烹饪、10 天保存</li><li><strong>通用食谱</strong>：肉度大于等于 0.5 小于等于 3.0 + 其他（不能是树枝、蜂蜜）</li><li><strong>我的食谱</strong>：一个怪兽肉/小肉 + 三个蔬菜/水果（避免怪兽肉 + 榴莲、鱼 + 玉米的组合）</li></ul><p><strong>点评</strong>：没什么好说的，增加饱食的易得利器，0.5 个肉度，也就是一个小肉即可，肉度大于 3.0 会做成肉汤。特别是条件不太好时，只为增加饱食又不太追求保质期，基本上没必要追求其他食谱。</p></li></ul><h4 id="比较喜欢的食谱"><a href="#比较喜欢的食谱" class="headerlink" title="比较喜欢的食谱"></a>比较喜欢的食谱</h4><ul><li><p><strong>青蛙腿三明治</strong></p><ul><li><strong>食谱属性</strong>：<strong>37.5 饱食、20 血、5 精神</strong>、10 秒烹饪、10 天保存</li><li><strong>通用食谱</strong>：一个青蛙腿 + 0.5 蔬菜度 + 其他</li><li><strong>我的食谱</strong>：一个青蛙腿  + 一个胡萝卜或一个蘑菇 + 两个树枝</li></ul><p><strong>点评</strong>：只需要 0.5 个蔬菜度、可以放两个树枝，如果有青蛙腿，则是一道很易得的回血食谱了。</p></li><li><p><strong>蜜汁火腿</strong></p><ul><li><strong>食谱属性</strong>：<strong>75 饱食、30 血、5 精神</strong>、40 秒烹饪、15 天保存</li><li><strong>通用食谱</strong>：2.0 肉度 + 一个蜂蜜（不能是蜂巢） + 其他（不能有树枝、蛋）</li><li><strong>我的食谱</strong>：一个大肉 + 一个怪兽肉 + 一个蜂蜜 + 一个蔬菜/水果（不能有榴莲）</li></ul><p><strong>点评</strong>：似乎很多人推荐蜜汁火腿，但由于需要两个肉度，至少也要一个大肉加一个怪兽肉，或者两个小肉加一个怪兽肉。<br>对农场派的我而言，大肉是难得的食材，有大肉我更倾向于直接做晾干成风干肉；而拿出两个小肉来做也是有点奢侈。蜜汁火腿的优势可能在于饱食+回血，但对于农场派有更好且更廉价的选择，就是火龙果派。</p></li></ul><h4 id="推荐的单品"><a href="#推荐的单品" class="headerlink" title="推荐的单品"></a>推荐的单品</h4><p><strong>肉干类</strong></p><ul><li><p>风干肉</p><ul><li><strong>食谱属性</strong>：<strong>25 饱食、20 血、15 精神</strong>、20 天保存</li></ul></li><li><p>小风干肉</p><ul><li><strong>食谱属性</strong>：<strong>12.5 饱食、8 血、10 精神</strong>、20 天保存</li></ul></li></ul><p><strong>回血果蔬</strong></p><ul><li><p>烤茄子</p><ul><li><strong>食谱属性</strong>：<strong>25 饱食、20 血、0 精神</strong>、6 天保存（生茄子 10 天保存）</li></ul><p><strong>点评</strong>：烤石榴（正式翻译是石榴切片）同样能回 20 血，但饱食度只有 12.5，而且只有 3 天保存（生石榴 6 天保存），相比之下就要比烤茄子逊色了。</p></li><li><p>蓝蘑菇</p><ul><li><strong>食谱属性</strong>：<strong>12.5 饱食、20 血、-15 精神</strong>、10 天保存</li></ul></li></ul><p><strong>回 san 蔬菜</strong></p><ul><li><p>烤绿蘑菇</p><ul><li><strong>食谱属性</strong>：<strong>0 饱食、-1 血、15 精神</strong>、10 天保存（绿蘑菇 10 天保存）</li></ul></li><li><p>烤仙人掌肉</p><ul><li><strong>食谱属性</strong>：<strong>12.5 饱食、1 血、15 精神</strong>、10 天保存（仙人掌肉 10 天保存）</li></ul><p><strong>点评</strong>：采摘仙人掌肉会损失 6 点血，夏天的时候会额外获得仙人掌花，仙人掌花回 8 点血，所以夏天采集仙人掌不会减血反而加血。</p></li><li><p>烤蓝蘑菇</p><ul><li><strong>食谱属性</strong>：<strong>0 饱食、-3 血、10 精神</strong>、10 天保存</li></ul></li></ul><p><strong>饱食蔬菜</strong></p><ul><li><p>烤南瓜</p><ul><li><strong>食谱属性</strong>：<strong>37.5 饱食、8 血、0 精神</strong>、6 天保存（生南瓜 10 天保存）</li></ul><p><strong>点评</strong>：饱食度比单块的肉还高，前面对南瓜饼与太妃糖的点评已经分析了烤南瓜作为单品食用的优势。</p></li></ul><h4 id="喜欢但不常做的食谱"><a href="#喜欢但不常做的食谱" class="headerlink" title="喜欢但不常做的食谱"></a>喜欢但不常做的食谱</h4><ul><li><p><strong>鱼排</strong></p><ul><li><strong>食谱属性</strong>：<strong>37.5 饱食、40 血、5 精神</strong>、40 秒烹饪、10 天保存</li><li><strong>通用食谱</strong>：一个鱼或鳗鱼 + 一个树枝 + 其他</li><li><strong>我的食谱</strong>：一个鱼  + 一个树枝 + 两个蔬菜/水果（玉米除外）</li><li><strong>额外说明</strong><ol><li>由于放了树枝，所以填充物可以时两个怪兽肉</li><li>“一个鱼 + 一个玉米”可能会做成炸鱼玉米饼（鱼塔可），37.5 饱食、20 血、5 精神、10 秒烹饪、6 天保存，虽然能放两个树枝，但明显浪费了食材</li></ol></li></ul><p><strong>点评</strong>：同样是回血神器，但我几乎不怎么钓鱼，只是偶尔靠被鱼人得到鱼，所以不怎么做。</p></li><li><p><strong>花瓣沙拉</strong></p><ul><li><strong>食谱属性</strong>：<strong>12.5 饱食、40 血、5 精神</strong>、10 秒烹饪、6 天保存</li><li><strong>通用食谱</strong>：一个仙人掌花 + 额外 1.5 蔬菜度 + 其他（不能有肉、蛋、水果、树枝、甜品，基本只能用冰）</li><li><strong>我的食谱</strong>：一个仙人掌花  + 三个蔬菜/蘑菇</li></ul><p><strong>点评</strong>：<strong>仙人掌为巨人国DLC增加</strong>，回血神器再 +1，但仙人掌花只有夏天跑到沙漠才能采，而且仙人掌花只有 3 天保存期，所以不经常做。只在初夏制作花衬衫的时候，顺便多采几个仙人掌来做。</p></li></ul><h4 id="不太喜欢的食谱"><a href="#不太喜欢的食谱" class="headerlink" title="不太喜欢的食谱"></a>不太喜欢的食谱</h4><ul><li><p><strong>蜜汁肉块</strong></p><ul><li><strong>食谱属性</strong>：<strong>37.5 饱食、20 血、5 精神</strong>、40 秒烹饪、15 天保存</li><li><strong>通用食谱</strong>：0.5 肉度 + 一个蜂蜜（不能是蜂巢） + 其他（不能有树枝、蛋）</li><li><strong>我的食谱</strong>：一个小肉  + 一个蜂蜜 + 两个蔬菜/水果</li></ul><p><strong>点评</strong>：蜜汁肉块的属性和青蛙腿三明治相当（除了保存时间多 5 天，烹饪时间多 30 秒）。</p></li></ul><h4 id="稀有食谱"><a href="#稀有食谱" class="headerlink" title="稀有食谱"></a>稀有食谱</h4><ul><li><p><strong>冰激凌</strong></p><ul><li><strong>食谱属性</strong>：<strong>25 饱食、0 血、50 精神</strong>、10 秒烹饪、3 天保存</li><li><strong>通用食谱</strong>：一个羊奶 + 一个蜂蜜/蜂巢 + 一个冰 + 其他（不能有肉、蛋、蔬菜、树枝）</li><li><strong>我的食谱</strong>：一个羊奶  + 一个蜂蜜 + 一个冰 + 一个浆果或冰</li></ul><p><strong>点评</strong>：<strong>羊奶为巨人国DLC增加</strong>，回 san 神器，回 san 最高的食谱。羊奶由被雷击的山羊掉落（100% 掉落）。让山羊被雷击有几种方式：自然状态下雨时被雷击、老奶奶读书、晨星锤攻击。通用而稳定的方法就是第三种，用晨星锤攻击。<br>晨星锤的制作需要羊角，羊角可由山羊或被雷击的山羊掉落，概率均为 25%。打山羊的时候通常是先用其他武器将山羊打到 100 血以下，再用晨星锤对山羊充电，最后杀死。</p></li></ul><h4 id="海滩穿越食谱"><a href="#海滩穿越食谱" class="headerlink" title="海滩穿越食谱"></a>海滩穿越食谱</h4><ul><li><p><strong>咖啡</strong></p><ul><li><strong>食谱属性</strong>：<strong>9.375 饱食、3 血、-5 精神</strong>、10 秒烹饪、10 天保存</li><li><strong>额外 Buff</strong>：增加 5 点移动速度，持续 4 分钟（半个游戏天）。普通角色移动速度为 6，相当于增加了 83% 的移动速度。</li><li><strong>通用食谱</strong>：三个烘焙咖啡豆 + 填充物（填充物只能为烘培咖啡豆、蜂蜜、羊奶）</li><li><strong>我的食谱</strong>：三个烘焙咖啡豆 + 一个蜂蜜</li></ul><p><strong>点评</strong>：颇费周折从海滩穿越过来，为的就是咖啡。跑在地图上飞快，配合手杖甚至夏天都可以到处乱跑。</p></li></ul><h3 id="我的食品生产模式"><a href="#我的食品生产模式" class="headerlink" title="我的食品生产模式"></a>我的食品生产模式</h3><p>在开头提到，我是农场怪兽流，所以农场 + 鸟是我的基本生产模式，此外还养了一个蜂巢，用于获取蜂蜜。前期靠鸟把怪兽肉变成蛋，后期食材较丰富后，开始喂给鸟火龙果、南瓜等重点果蔬，获得专门的火龙果种子和南瓜种子。</p><p>关于怪兽肉的获取，我把家建在了离池塘稍近的地方，靠青蛙与猎狗两方争斗获取怪兽肉，此外就是去刷蜘蛛（蜘蛛网也是捕鸟养鸟的前提，所以蜘蛛是农场派和怪兽肉的结合点）。没有把家建在猪舍旁，因为猪喜欢吃种子，对农场派而言有点烦。没有把家建在牛群旁，因为就算是农场派，需要肥料时再去找也就够了，不需要特别多。</p>]]></content>
    
    
    <categories>
      
      <category>二次元与游戏</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>nnedi3 相关代码学习</title>
    <link href="/2020/04/30/nnedi3/"/>
    <url>/2020/04/30/nnedi3/</url>
    
    <content type="html"><![CDATA[<h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>其实不知道有没有必要像这样，为并不是很复杂的源码煞有介事地写一份包含个人感想的阅读笔记。但不得不说，<a href="https://forum.doom9.org/showthread.php?t=147695" target="_blank" rel="noopener">nnedi3</a> 相关的内容，从我最开始接触图像处理，就一直萦绕在心头。一直觉得 nnedi3 很神奇，抗锯齿用它，重采样放大也用它，因为用了神经网络更显得高大上。另一方面，随着 Deep Learning 浪潮涌起，有些人开始质疑对 Deep Learning 的跟风。于是有种错觉，用传统神经网络的 nnedi3，既套上了光环，又躲过了质疑。</p><p>起初接触 nnedi3 是通过 <a href="https://www.nmm-hd.org/newbbs/viewtopic.php?f=7&t=1117" target="_blank" rel="noopener">nnedi3_resize16</a> 这个流传甚广的缩放脚本。之后在我学会 deband 与边缘检测后，很长时间没有继续学新东西，几乎过了一年，我才接触到 nnedi3 的抗锯齿用途。又跨过大半年，在我熟悉 Github 之后，到第二年的秋天，我又看到了优化版的 <a href="https://github.com/sekrit-twc/znedi3" target="_blank" rel="noopener">znedi3</a> 和 <a href="(https://github.com/HomeOfVapourSynthEvolution/VapourSynth-NNEDI3CL)">nnedi3cl</a>。某种角度上，nnedi3 贯穿了我到目前为止的图像处理学习过程。</p><a id="more"></a><p>我已经忘记之前是在哪里看到，说 nnedi3 没有开源。我也模糊得记得，找过 eedi 系列滤镜，没找到代码（事实上也是开源的）。于是交错的印象下，在我开始写 C++ 之前，没有再深入了解 nnedi3。即使是之后开始写 VapourSynth Plugin，也是模仿着 Deblock 和 nnedi2 的框架（话说这对初学者而言，和 nnedi3 比也没什么区别喂喂，只是我当时选择性地无视了）。</p><p>BTW，学习代码不是自己写代码，有时候需要不求甚解，明白意思即可，不然也只是浪费时间。</p><h3 id="代码概览"><a href="#代码概览" class="headerlink" title="代码概览"></a>代码概览</h3><h4 id="代码框架"><a href="#代码框架" class="headerlink" title="代码框架"></a>代码框架</h4><p><a href="https://github.com/HomeOfVapourSynthEvolution/VapourSynth-NNEDI3CL" target="_blank" rel="noopener">VapourSynth-NNEDI3CL</a> 是 VapourSynth 框架下进行了 OpenCL 优化的 nnedi3 实现，除了 OpenCL 配置文件外，只有一份 nnedi3cl.cpp，代码结构也不复杂，VapourSynth Plugin 框架的四个函数 + 一个 process() 性质的函数。</p><p>重新审视一下 VapourSynth Plugin 框架的四个函数，初始化函数 Init() 和 释放内存函数 Free() 不必多说，从计算内容的角度看，GetFrame() 函数是与图像内容相关的计算，会用到像素点的数据，而 Create() 函数（除获取参数外）则是无关像素点数值的计算，至多会用到视频格式的信息。从两个函数的名字上看也能看出这一点。</p><p>NNEDI3CL 因为涉及 OpenCL，且参数较多，Create() 函数中报错信息占了较长的篇幅。nnedi3 最原始的用途是隔行插值反交错，所以在 GetFrame() 函数中，比只处理逐行的滤镜，多了 field / 场信息的判断。</p><p>大致浏览完这些信息，核心处理从<code>nnedi3_weights.bin</code>文件入手。</p><h4 id="主要数据"><a href="#主要数据" class="headerlink" title="主要数据"></a>主要数据</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++">compute::command_queue <span class="hljs-built_in">queue</span>;<br>compute::kernel kernel;<br>compute::image2d src, dst, tmp;<br>compute::buffer weights0, weights1Buffer;<br>cl_mem weights1;<br></code></pre></td></tr></table></figure><p>其中<code>queue</code>、<code>kernel</code>用于 OpenCL 框架，三个<code>image2D</code>类型的变量<code>src</code>、<code>dst</code>、<code>tmp</code>用于储存图像，余下三个变量则是与神经网络权值相关。</p><p>在 Create() 函数内，<code>weights0</code>、<code>weights1</code>都是<code>float</code>指针。</p><p><code>cl_mem</code>类型用于在设备上分配内存，<code>cl_mem</code>类型是”Memory Object“的句柄，提供了一种内存抽象。</p><h3 id="神经网络"><a href="#神经网络" class="headerlink" title="神经网络"></a>神经网络</h3><h4 id="IO-部分"><a href="#IO-部分" class="headerlink" title="IO 部分"></a>IO 部分</h4><p>由于使用传统神经网络，需要读入权值文件<code>nnedi3_weights.bin</code>。IO 部分基于头文件<code>&lt;cstdio&gt;</code>。</p><p>除了常见的<code>std::fopen</code>、<code>std::fclose</code>外，还用到了下面这些函数。</p><p><code>std::fread</code>-<code>std::size_t fread(void* buffer, std::size_t size, std::size_t count, std::FILE* stream)</code>：从输入流读取至多 <code>count</code> 个对象到数组 <code>buffer</code> 中，返回成功读取的对象数。</p><p><code>std::rewind</code>-<code>void rewind(std::FILE* stream)</code>：移动文件位置指示器到给定文件流的起始。</p><p><code>std::ftell</code>-<code>long ftell(std::FILE* stream)</code>：返回文件流文件位置指示器的当前值。</p><p>读入的<strong>权值数据保存在<code>bdata</code>中</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">long</span> correctSize = <span class="hljs-number">13574928</span>; <span class="hljs-comment">// Version 0.9.4 of the Avisynth plugin</span><br><br><span class="hljs-keyword">float</span> * bdata = <span class="hljs-keyword">reinterpret_cast</span>&lt;<span class="hljs-keyword">float</span> *&gt;(<span class="hljs-built_in">malloc</span>(correctSize));<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">size_t</span> bytesRead = <span class="hljs-built_in">std</span>::fread(bdata, <span class="hljs-number">1</span>, correctSize, weightsFile);<br></code></pre></td></tr></table></figure><h4 id="权值计算的后续"><a href="#权值计算的后续" class="headerlink" title="权值计算的后续"></a>权值计算的后续</h4><p>Create() 部分的权值有点复杂，先看看 Create() 权值计算结果是怎么用到 GetFrame() 上的吧。</p><p>如后文的”OpenCL 变量“部分所说，三个权值变量被 GetFrame() 调用的只有两个，<code>weights0</code>和<code>weights1</code>，被调用的位置和次数一样，只是<code>weights1</code>在 Free() 函数中多了一步释放。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">clReleaseMemObject(d-&gt;weights1);<br></code></pre></td></tr></table></figure><p>两个变量在三个分支的<code>if-else</code>中同时出现了四次，伪代码如下。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta"># bool d-&gt;dw, d-&gt;dh;</span><br><br><span class="hljs-keyword">if</span> (d-&gt;dw &amp;&amp; d-&gt;dh)<br>&#123;<br>    kernel.set_args(src, tmp, d-&gt;weights0, d-&gt;weights1, size_h_w, field, <span class="hljs-number">-1</span>);<br>    kernel.set_args(tmp, dst, d-&gt;weights0, d-&gt;weights1, size_w_h, field,  <span class="hljs-number">0</span>);<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (d-&gt;dw)<br>&#123;<br>    kernel.set_args(src, dst, d-&gt;weights0, d-&gt;weights1, size_h_w, field, <span class="hljs-number">-1</span>);<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>    kernel.set_args(src, dst, d-&gt;weights0, d-&gt;weights1, size_w_h, field,  <span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>很明显，是从 x，y 两个方向分别处理。在这四次调用中，<code>weights0</code>和<code>weights1</code>发挥的作用是等价。</p><p>进而来整体看下 GetFrame() 函数及 process() 函数（在 NNEDI3CL 里写作 <code>filter()</code>），常规而且仅有骨架，上面的伪代码便是核心而唯一的操作，除此之前唯一陌生的地方就是增加了 field 信息的判断。</p><p>于是，可以转向 .cl 文件看核心计算了。</p><h3 id="OpenCL-核心计算"><a href="#OpenCL-核心计算" class="headerlink" title="OpenCL 核心计算"></a>OpenCL 核心计算</h3><p>这部分是 .cl 文件中的代码学习笔记。</p><p>命名空间（好像说法不太对..）<code>kernel</code>下的函数有两个重载，分别对应<code>float</code>类型和 uint 类型，看看其中一个。（删去了<code>&quot;\n&quot;</code>）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++">__kernel __attribute__((reqd_work_group_size(<span class="hljs-number">4</span>, <span class="hljs-number">16</span>, <span class="hljs-number">1</span>)))<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">filter_uint</span><span class="hljs-params">(__read_only <span class="hljs-keyword">image2d_t</span> src, __write_only <span class="hljs-keyword">image2d_t</span> dst,</span></span><br><span class="hljs-function"><span class="hljs-params">                 __constant <span class="hljs-keyword">float</span> * weights0, __read_only <span class="hljs-keyword">image1d_buffer_t</span> weights1,</span></span><br><span class="hljs-function"><span class="hljs-params">                 <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> srcWidth, <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> srcHeight, <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> dstWidth,</span></span><br><span class="hljs-function"><span class="hljs-params">                 <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> dstHeight, <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> field_n, <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> off, <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> swap)</span></span><br></code></pre></td></tr></table></figure><p>和前面<code>filter()</code>函数中的核心处理相对应。</p><p>追踪一下<code>weights0</code>的传递过程。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">float8 output = PRESCREEN((<span class="hljs-keyword">const</span> __local <span class="hljs-keyword">float</span> (*)[INPUT_WIDTH])&amp;input[YDIAD2M1 - <span class="hljs-number">1</span> + localY][XDIAD2M1 - PSCRN_OFFSET + <span class="hljs-number">8</span> * localX],<br>                          &amp;flag, weights0);<br></code></pre></td></tr></table></figure><p>（这个<code>PRESCREEN()</code>是啥…）</p><h3 id="OpenCL-接口部分"><a href="#OpenCL-接口部分" class="headerlink" title="OpenCL 接口部分"></a>OpenCL 接口部分</h3><p>这部分是 Create() 函数中出现的 OpenCL 相关内容。</p><h4 id="相关函数"><a href="#相关函数" class="headerlink" title="相关函数"></a>相关函数</h4><h5 id="clCreateImage"><a href="#clCreateImage" class="headerlink" title="clCreateImage"></a><code>clCreateImage</code></h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">cl_mem <span class="hljs-title">clCreateImage</span><span class="hljs-params">(cl_context              context,</span></span><br><span class="hljs-function"><span class="hljs-params">                     cl_mem_flags            flags,</span></span><br><span class="hljs-function"><span class="hljs-params">                     <span class="hljs-keyword">const</span> cl_image_format  *image_format,</span></span><br><span class="hljs-function"><span class="hljs-params">                     <span class="hljs-keyword">const</span> cl_image_desc    *image_desc,</span></span><br><span class="hljs-function"><span class="hljs-params">                     <span class="hljs-keyword">void</span>                   *host_ptr,</span></span><br><span class="hljs-function"><span class="hljs-params">                     cl_int                 *errcode_ret)</span></span><br></code></pre></td></tr></table></figure><p>Creates a 1D image, 1D image buffer, 1D image array, 2D image, 2D image array or 3D image object.</p><p>创建一维图像、一维图像 buffer、一维图像数组、二维图像、二维图像数组或者三维图像对象。</p><h4 id="OpenCL-变量"><a href="#OpenCL-变量" class="headerlink" title="OpenCL 变量"></a>OpenCL 变量</h4><h5 id="d-gt-weights1"><a href="#d-gt-weights1" class="headerlink" title="d-&gt;weights1"></a><code>d-&gt;weights1</code></h5><p>结构体内的<code>weights1</code>定义如下。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">cl_mem mem = clCreateImage(context, <span class="hljs-number">0</span>, &amp;format, &amp;desc, <span class="hljs-literal">nullptr</span>, &amp;error);<br>d-&gt;weights1 = mem;<br></code></pre></td></tr></table></figure><p>其中，<code>mem</code>的主要数据来自<code>desc</code>。</p><p><code>desc</code>的数据，除了一些格式上的常数，一是来自<code>dims1</code>，一是来自权值<code>weights1Buffer</code>，也就是三个结构体内的数据之一。</p><p><code>dims1</code>的定义如下，都是常数计算，没有额外的东西。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> dims1 = nnsTable[nns] * <span class="hljs-number">2</span> * (xdiaTable[nsize] * ydiaTable[nsize] + <span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure><p>所以综上所述，<code>weights1</code>与<code>weights1Buffer</code>有种套娃之感，核心数据是一样的。（看一下名字啊，<code>weights1Buffer</code>=<code>weights1</code>+<code>buffer</code>）</p><h5 id="d-gt-weights0与d-gt-weights1Buffer"><a href="#d-gt-weights0与d-gt-weights1Buffer" class="headerlink" title="d-&gt;weights0与d-&gt;weights1Buffer"></a><code>d-&gt;weights0</code>与<code>d-&gt;weights1Buffer</code></h5><p>结构体内的<code>weights0</code>与<code>weights1Buffer</code>定义如下。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++">d-&gt;weights0 = compute::buffer&#123; context, <span class="hljs-built_in">std</span>::max(dims0, dims0new) * <span class="hljs-keyword">sizeof</span>(cl_float),<br>    CL_MEM_READ_ONLY | CL_MEM_COPY_HOST_PTR | CL_MEM_HOST_NO_ACCESS, weights0 &#125;;<br><br>d-&gt;weights1Buffer = compute::buffer&#123; context, dims1 * <span class="hljs-number">2</span> * <span class="hljs-keyword">sizeof</span>(cl_float),<br>    CL_MEM_READ_ONLY | CL_MEM_COPY_HOST_PTR | CL_MEM_HOST_NO_ACCESS, weights1 &#125;;<br></code></pre></td></tr></table></figure><p>事实上，<code>weights1Buffer</code>的调用范围仅限于 Create()，并没有在 GetFrame() 中调用。</p><h5 id="Create-内的同名变量"><a href="#Create-内的同名变量" class="headerlink" title="Create() 内的同名变量"></a>Create() 内的同名变量</h5><p>在 Create() 函数内，有两个临时变量性质的同名变量，定义如下。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">float</span>* weights0 = <span class="hljs-keyword">new</span> <span class="hljs-keyword">float</span>[<span class="hljs-built_in">std</span>::max(dims0, dims0new)];<br><span class="hljs-keyword">float</span>* weights1 = <span class="hljs-keyword">new</span> <span class="hljs-keyword">float</span>[dims1 * <span class="hljs-number">2</span>];<br></code></pre></td></tr></table></figure><p>它们在定义了<code>d-&gt;weights0</code>与<code>d-&gt;weights1Buffer</code>后被释放。</p>]]></content>
    
    
    <categories>
      
      <category>图像处理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>VapourSynth</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一些较新的去雾（dehazing）算法</title>
    <link href="/2020/04/28/dehazing/"/>
    <url>/2020/04/28/dehazing/</url>
    
    <content type="html"><![CDATA[<p>提到去雾算法，首先想到的便是 2009 年的暗通道去雾算法，以及后续的导向滤波，搜索博客和 Github 发现了一些较新的去雾算法，也算是尝试跟上学术界的脚步。</p><a id="more"></a><ul><li><p>2013年基于对比度增强的去雾算法<br><a href="http://mcl.korea.ac.kr/projects/dehazing/#userconsent#" target="_blank" rel="noopener">http://mcl.korea.ac.kr/projects/dehazing/#userconsent#</a></p></li><li><p>2016年非局部均值去雾算法<br><a href="https://github.com/danaberman/non-local-dehazing" target="_blank" rel="noopener">https://github.com/danaberman/non-local-dehazing</a></p></li></ul><h3 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h3><p>基于对比度增强的去雾算法（以下简称 DehazingCE，CE =  Contrast enhancement）的作者给出了完整的 C++ 代码，只是是基于 OpenCV 2 的（而且代码风格也有些复古）。对我来说，从头完整地把代码迁移到 VapourSynth 上有点困难，所以先做原始代码从 OpenCV 2 到 OpenCV 3 的迁移。</p><h4 id="数据类型的变化"><a href="#数据类型的变化" class="headerlink" title="数据类型的变化"></a>数据类型的变化</h4><p>从 OpenCV 2 的 IplImage 到 OpenCV 3 的 Mat。</p><h4 id="函数名与类型名的变化"><a href="#函数名与类型名的变化" class="headerlink" title="函数名与类型名的变化"></a>函数名与类型名的变化</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">cvCopyImage → cvCopy<br>cvCvtPixToPlane → cvSplit<br>POINT → cv::Point           <span class="hljs-comment">// 这个像是手滑</span><br></code></pre></td></tr></table></figure><h4 id="数据类型的变化-1"><a href="#数据类型的变化-1" class="headerlink" title="数据类型的变化"></a>数据类型的变化</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">double</span> deMean[<span class="hljs-number">3</span>];<br>→<br>  <span class="hljs-keyword">double</span> deMean_value[<span class="hljs-number">3</span>];<br>  CvScalar dpMean = cvScalar(deMean_value[<span class="hljs-number">1</span>], deMean_value[<span class="hljs-number">2</span>], deMean_value[<span class="hljs-number">3</span>]);<br></code></pre></td></tr></table></figure><h4 id="添加头文件"><a href="#添加头文件" class="headerlink" title="添加头文件"></a>添加头文件</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;opencv2/videoio.hpp&gt;</span></span><br></code></pre></td></tr></table></figure><h4 id="补齐依赖项"><a href="#补齐依赖项" class="headerlink" title="补齐依赖项"></a>补齐依赖项</h4><p>缺少 OpenCV 2.4.3 的四个 .lib 静态库</p><p>缺少 MSVCP100D.dll、MSVCR100D.dll</p><h4 id="运行时遇到的问题"><a href="#运行时遇到的问题" class="headerlink" title="运行时遇到的问题"></a>运行时遇到的问题</h4><h5 id="问题1"><a href="#问题1" class="headerlink" title="问题1"></a>问题1</h5><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">引发了异常: 读取访问权限冲突。 **iminput** 是 <span class="hljs-literal">null</span>ptr。<br></code></pre></td></tr></table></figure><p>空指针，具体而言是没有定义输入图像…</p><h5 id="问题2"><a href="#问题2" class="headerlink" title="问题2"></a>问题2</h5><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">Run</span><span class="bash">-Time Check Failure <span class="hljs-comment">#2 - Stack around the variable 'deMean_value' was corrupted.</span></span><br></code></pre></td></tr></table></figure><p>指针越界了…</p>]]></content>
    
    
    <categories>
      
      <category>图像处理</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>周记 2020.03.16-03.22</title>
    <link href="/2020/04/28/week-202003-3/"/>
    <url>/2020/04/28/week-202003-3/</url>
    
    <content type="html"><![CDATA[<p>strncpy() -&gt; memcpy() 从内存中复制，gcc对后者兼容性更好？避免warning？</p><p>学习编程的三个方向<br>1.整体结构设计，特别以类和对象为基础的面向对象的构成<br>2.算法优化，同样一个算法，怎么运行更快，这是coder该想的事情，而非算法专家想的事情<br>3.Debug，找bug并更正的能力</p><a id="more"></a><p>再拖着不接触核心算法真不是事，先用vs框架实现算法吧</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">tmp_array.resize(tmp_array.size() + coeff_per_pixel, <span class="hljs-number">0.f</span>); <span class="hljs-comment">// 调整大小，填零</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>周记 2020.03.09-03.15</title>
    <link href="/2020/04/28/week-202003-2/"/>
    <url>/2020/04/28/week-202003-2/</url>
    
    <content type="html"><![CDATA[<h3 id="C-语法"><a href="#C-语法" class="headerlink" title="C++语法"></a>C++语法</h3><h4 id="explicit"><a href="#explicit" class="headerlink" title="explicit"></a><code>explicit</code></h4><p><code>explicit</code>用来修饰构造函数、转换函数（C++11）、推导指引（C++17），C++20可以在其后加表达式（详见：<a href="https://zh.cppreference.com/w/cpp/language/explicit）。" target="_blank" rel="noopener">https://zh.cppreference.com/w/cpp/language/explicit）。</a></p><p><strong>功能</strong></p><ul><li>被修饰的构造函数的类，不能进行隐式类型转换，只能进行显示类型转换</li><li>不能用于复制初始化</li></ul><p><strong>注意</strong></p><ul><li><code>explicit</code>只能用于构造函数的声明</li></ul><a id="more"></a><p><a href="https://www.cnblogs.com/this-543273659/archive/2011/08/02/2124596.html" target="_blank" rel="noopener">这篇博文</a>中的例子。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/* without explicit */</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">circle</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>    circle(<span class="hljs-keyword">double</span> r) : R(r) &#123;&#125;<br>    circle(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y = <span class="hljs-number">0</span>) : X(x), Y(y) &#123;&#125;<br>    circle(<span class="hljs-keyword">const</span> circle&amp; c) : R(c.R), X(c.X), Y(c.Y) &#123;&#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">double</span> R;<br>    <span class="hljs-keyword">int</span> X, Y;<br>&#125;;<br><br><span class="hljs-keyword">int</span> _tmain()<br>&#123;<br>    circle A = <span class="hljs-number">1.23</span>;<br>    circle B = <span class="hljs-number">123</span>;<br>    circle C = A;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/* with explicit */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">circle</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-keyword">public</span>:<br>    explicit circle(double r) : R(r) &#123;&#125;<br>    explicit circle(int x, int y = 0) : X(x), Y(y) &#123;&#125;<br>    explicit circle(const circle&amp; c) : R(c.R), X(c.X), Y(c.Y) &#123;&#125;<br>    <span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">double</span> R;<br>    <span class="hljs-keyword">int</span> X, Y;<br>&#125;;<br><br><span class="hljs-keyword">int</span> _tmain()<br>&#123;<br>    <span class="hljs-function">circle <span class="hljs-title">A</span><span class="hljs-params">(<span class="hljs-number">1.23</span>)</span></span>;<br>    <span class="hljs-function">circle <span class="hljs-title">B</span><span class="hljs-params">(<span class="hljs-number">123</span>)</span></span>;<br>    <span class="hljs-function">circle <span class="hljs-title">C</span><span class="hljs-params">(A)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在结构中也可以这么用。</p><h4 id="非常量引用的初始值必须是左值"><a href="#非常量引用的初始值必须是左值" class="headerlink" title="非常量引用的初始值必须是左值"></a>非常量引用的初始值必须是左值</h4><p>可能是存在不被允许的隐式类型转换。</p><h4 id="assert"><a href="#assert" class="headerlink" title="assert"></a><code>assert</code></h4><p><code>assert</code>是宏，不仅用来报错。</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>从 VapourSynth API 到 C++ 基础知识</title>
    <link href="/2020/04/28/from-vs-to-cpp/"/>
    <url>/2020/04/28/from-vs-to-cpp/</url>
    
    <content type="html"><![CDATA[<p><del>副标题：从 C + isotream 到 C++</del></p><p>（这是1月底写一点随笔，然后就被丢到一边不管了）</p><h3 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h3><p>全面讲述智能指针的文章：<a href="https://juejin.im/post/5dcaa857e51d457f7675360b" target="_blank" rel="noopener">https://juejin.im/post/5dcaa857e51d457f7675360b</a></p><p>熟悉的<code>unique_ptr</code>，是“拥有独有对象所有权语义的智能指针”。</p><a id="more"></a><h4 id="智能指针的释放"><a href="#智能指针的释放" class="headerlink" title="智能指针的释放"></a>智能指针的释放</h4><p>一个基本概念，要用<code>.</code>而非<code>-&gt;</code>。（<a href="https://blog.csdn.net/delphicui/article/details/4213811）" target="_blank" rel="noopener">https://blog.csdn.net/delphicui/article/details/4213811）</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">smartPointer.release();   <span class="hljs-comment">// 正确</span><br>smartPointer-&gt;release();  <span class="hljs-comment">// 错误</span><br></code></pre></td></tr></table></figure><p>在 VapourSynth Plugin 的编写时，要在<code>Free()</code>函数里写<code>delete d;</code>，但又在<code>Create()</code>函数里写了<code>d.release()</code>。可不可以这么理解，智能指针<code>d</code>在<code>Creat()</code>函数里被声明，所以要在<code>Create()</code>函数内释放一次，但其他地方也用到了<code>d</code>，所以又要写一次<code>delete d</code>？<del>我感觉我在胡说八道</del></p><h4 id="智能指针与数组"><a href="#智能指针与数组" class="headerlink" title="智能指针与数组"></a>智能指针与数组</h4><p>用智能指针创建数组，类似下面这样。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">unique_ptr</span>&lt;<span class="hljs-keyword">float</span>[]&gt; <span class="hljs-built_in">array</span>[<span class="hljs-number">5</span>];<br></code></pre></td></tr></table></figure><p>而且用后并没有释放，这是自然，毕竟智能指针的本意即是如此。</p><p>但我不知道，对于查表用的大数组，有没有必要“升级”成智能指针，对于使用<code>new</code>创建的指针呢？</p><h3 id="com组件"><a href="#com组件" class="headerlink" title="com组件"></a>com组件</h3><p>（被淘汰的技术）</p><p>（我不知道 VapourSynth API 里的 com 是不是这个 com）</p><h3 id="lamda表达式"><a href="#lamda表达式" class="headerlink" title="lamda表达式"></a>lamda表达式</h3><p>（额外延伸的，稍后再看）</p>]]></content>
    
    
    <categories>
      
      <category>图像处理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>VapourSynth</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>色调映射（Tone mapping）</title>
    <link href="/2020/04/28/Tonemapping/"/>
    <url>/2020/04/28/Tonemapping/</url>
    
    <content type="html"><![CDATA[<p>在<a href="https://kiyamou.github.io/2020/02/08/ISP-learn-1/" target="_blank" rel="noopener">之前的博文</a>中提到过色调映射，色调映射可以做很多事情，既包括对相机 raw 文件的亮度调整，也可以做 HDR 的转换。</p><a id="more"></a><p>在 VapourSynth 社区中，原生的色调映射滤镜/脚本有两个，一个<a href="https://github.com/ifb/vapoursynth-tonemap" target="_blank" rel="noopener">滤镜</a>、一个<a href="https://github.com/age1988/vapoursynth-tonemapping" target="_blank" rel="noopener">脚本</a>，另外还有基于 placebo 库的<a href="https://github.com/Lypheo/vs-placebo" target="_blank" rel="noopener">vs-placebo滤镜</a>，以及一个<a href="https://github.com/xyx98/my-vapoursynth-script/blob/master/xvs.py#L1087" target="_blank" rel="noopener">高级函数</a>。</p><p>这些工具中，除了基于 placebo 库的 vs-placebo，因为要用 vulkan 而我的老旧设备不支持外，其余都尝试过了。</p>]]></content>
    
    
    <categories>
      
      <category>图像处理</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Retinex 算法</title>
    <link href="/2020/04/28/Retinex/"/>
    <url>/2020/04/28/Retinex/</url>
    
    <content type="html"><![CDATA[<a id="more"></a><p>Retinex系列算法如下。</p><h4 id="SSR"><a href="#SSR" class="headerlink" title="SSR"></a>SSR</h4><p>SSR（Single-Scale Retinex）：单尺度 Retinex 算法。</p><h4 id="MSR"><a href="#MSR" class="headerlink" title="MSR"></a>MSR</h4><p>MSR（Multi-Scale Retinex）：多尺度 Retinex 算法，对多个单尺度 Retinex 的结果进行平均。</p><h4 id="MSRCP"><a href="#MSRCP" class="headerlink" title="MSRCP"></a>MSRCP</h4><p>MSRCP：色彩恢复多尺度 Retinex 算法，相当于把亮的地方压缩（变黑），而把黑的地方升高变亮。</p><h4 id="MSRCR"><a href="#MSRCR" class="headerlink" title="MSRCR"></a>MSRCR</h4><p>MSRCR（Multi-Scale Retinex with Color Restoration）：色彩恢复多尺度 Retinex 算法，在 MSRCP 的基础上会改变颜色，让颜色均衡，通常会导致画面变暗，但对于一些图像，可以避免 MSRCP 导致的色差（画面颜色过暖）问题。</p>]]></content>
    
    
    <categories>
      
      <category>图像处理</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>边缘检测</title>
    <link href="/2020/04/27/edgemasks/"/>
    <url>/2020/04/27/edgemasks/</url>
    
    <content type="html"><![CDATA[<p>本文翻译自 <a href="https://blog.kageru.moe/legacy/edgemasks.html" target="_blank" rel="noopener">Edge Masks</a>，原作者：<a href="https://github.com/kageru" target="_blank" rel="noopener">kageru</a>。</p><p><em>译者：“mask”的中文译名应该是“蒙版”，不太习惯这个词，于是把标题写成了边缘检测，文内还是直接用英文“mask”。</em></p><a id="more"></a><h3 id="理论、实例和解释"><a href="#理论、实例和解释" class="headerlink" title="理论、实例和解释"></a>理论、实例和解释</h3><p><em>译者：本节篇幅较长，译者添加了小标题。</em></p><p>大多数流行的算法通过卷积来衡量像素邻域变化，以确定亮度变化。卷积计算的时间复杂度为 O(n^2)，其中 n 为卷积核半径，因此卷积核在保存适当精度的前提下越小越好。卷积核半径越低，越容易受到噪声（noise）和瑕疵（artifacts）的影响。</p><p>多数算法采用 3x3 卷积核，在速度和准确性间提供了最佳平衡。例子便是 Prewitt、Sobel、Scharr 和 Kirsch 提出的算子。对于无噪声的干净信号源，也可使用 2x2 卷积（<a href="http://homepages.inf.ed.ac.uk/rbf/HIPR2/roberts.htm" target="_blank" rel="noopener">文献</a>），但目前的硬件已经能够实时处理 3x3 卷积。</p><h4 id="Sobel-算子"><a href="#Sobel-算子" class="headerlink" title="Sobel 算子"></a>Sobel 算子</h4><p>以 Sobel 算子为例，x 方向和 y 方向分别进行卷积。</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">---------------   --------------<br>|<span class="hljs-string"> -1 </span>|<span class="hljs-string"> 2 </span>|<span class="hljs-string"> -1 </span>|<span class="hljs-string">   </span>|<span class="hljs-string"> -1 </span>|<span class="hljs-string"> 0 </span>|<span class="hljs-string"> 1 </span>|<br>|<span class="hljs-string">  0 </span>|<span class="hljs-string"> 0 </span>|<span class="hljs-string">  0 </span>|<span class="hljs-string">   </span>|<span class="hljs-string">  2 </span>|<span class="hljs-string"> 0 </span>|<span class="hljs-string"> 2 </span>|<span class="hljs-string"> </span><br>|<span class="hljs-string">  1 </span>|<span class="hljs-string"> 2 </span>|<span class="hljs-string">  1 </span>|<span class="hljs-string">   </span>|<span class="hljs-string"> -1 </span>|<span class="hljs-string"> 0 </span>|<span class="hljs-string"> 1 </span>|<br>---------------   --------------<br></code></pre></td></tr></table></figure><p>用 VapourSynth 简单实现如下。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">Sobel</span><span class="hljs-params">(src)</span>:</span><br>    sx = src.std.Convolution(matrix=[<span class="hljs-number">-1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>,  <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>], saturate=<span class="hljs-literal">False</span>)<br>    sy = src.std.Convolution(matrix=[<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>,  <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>], saturate=<span class="hljs-literal">False</span>)<br>    <span class="hljs-keyword">return</span> core.std.Expr([sx, sy], <span class="hljs-string">'x y max'</span>)<br></code></pre></td></tr></table></figure><p>甚至，VapourSynth 内置了<code>core.std.Sobel</code>函数，我们不必自己写代码。</p><p>对于边缘模糊的图像，Sobel 算子的效果并不是很好。提高检测精度的一种方法是使用 8 邻域而非 4 邻域，即在邻域的 8 个方向上，或者说在 3x3 卷积核的对角线上，都将被计算。</p><h4 id="Kirsch-算子"><a href="#Kirsch-算子" class="headerlink" title="Kirsch 算子"></a>Kirsch 算子</h4><p>Russel A. Kirsch 在 1970 年提出了 Kirsch 算子（<a href="https://ddl.kageru.moe/konOJ.pdf" target="_blank" rel="noopener">文献</a>）。</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">-----------------<br>|<span class="hljs-string">  5 </span>|<span class="hljs-string">  5  </span>|<span class="hljs-string">  5 </span>|<br>|<span class="hljs-string"> -3 </span>|<span class="hljs-string">  0  </span>|<span class="hljs-string"> -3 </span>|<br>|<span class="hljs-string"> -3 </span>|<span class="hljs-string"> -3  </span>|<span class="hljs-string"> -3 </span>|<br>-----------------<br></code></pre></td></tr></table></figure><p>该卷积核会旋转 45° 以回到其原始位置。</p><p>在 VapourSynth 中并未内置 Kirsch 算子，尝试通过 VapourSynth 内置的卷积方法实现。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">kirsch</span><span class="hljs-params">(src)</span>:</span><br>    kirsch1 = src.std.Convolution(matrix=[<span class="hljs-number">5</span>,   <span class="hljs-number">5</span>,  <span class="hljs-number">5</span>, <span class="hljs-number">-3</span>,  <span class="hljs-number">0</span>, <span class="hljs-number">-3</span>, <span class="hljs-number">-3</span>, <span class="hljs-number">-3</span>, <span class="hljs-number">-3</span>])<br>    kirsch2 = src.std.Convolution(matrix=[<span class="hljs-number">-3</span>,  <span class="hljs-number">5</span>,  <span class="hljs-number">5</span>,  <span class="hljs-number">5</span>,  <span class="hljs-number">0</span>, <span class="hljs-number">-3</span>, <span class="hljs-number">-3</span>, <span class="hljs-number">-3</span>, <span class="hljs-number">-3</span>])<br>    kirsch3 = src.std.Convolution(matrix=[<span class="hljs-number">-3</span>, <span class="hljs-number">-3</span>,  <span class="hljs-number">5</span>,  <span class="hljs-number">5</span>,  <span class="hljs-number">0</span>,  <span class="hljs-number">5</span>, <span class="hljs-number">-3</span>, <span class="hljs-number">-3</span>, <span class="hljs-number">-3</span>])<br>    kirsch4 = src.std.Convolution(matrix=[<span class="hljs-number">-3</span>, <span class="hljs-number">-3</span>, <span class="hljs-number">-3</span>,  <span class="hljs-number">5</span>,  <span class="hljs-number">0</span>,  <span class="hljs-number">5</span>,  <span class="hljs-number">5</span>, <span class="hljs-number">-3</span>, <span class="hljs-number">-3</span>])<br>    kirsch5 = src.std.Convolution(matrix=[<span class="hljs-number">-3</span>, <span class="hljs-number">-3</span>, <span class="hljs-number">-3</span>, <span class="hljs-number">-3</span>,  <span class="hljs-number">0</span>,  <span class="hljs-number">5</span>,  <span class="hljs-number">5</span>,  <span class="hljs-number">5</span>, <span class="hljs-number">-3</span>])<br>    kirsch6 = src.std.Convolution(matrix=[<span class="hljs-number">-3</span>, <span class="hljs-number">-3</span>, <span class="hljs-number">-3</span>, <span class="hljs-number">-3</span>,  <span class="hljs-number">0</span>, <span class="hljs-number">-3</span>,  <span class="hljs-number">5</span>,  <span class="hljs-number">5</span>,  <span class="hljs-number">5</span>])<br>    kirsch7 = src.std.Convolution(matrix=[ <span class="hljs-number">5</span>, <span class="hljs-number">-3</span>, <span class="hljs-number">-3</span>, <span class="hljs-number">-3</span>,  <span class="hljs-number">0</span>, <span class="hljs-number">-3</span>, <span class="hljs-number">-3</span>,  <span class="hljs-number">5</span>,  <span class="hljs-number">5</span>])<br>    kirsch8 = src.std.Convolution(matrix=[ <span class="hljs-number">5</span>,  <span class="hljs-number">5</span>, <span class="hljs-number">-3</span>, <span class="hljs-number">-3</span>,  <span class="hljs-number">0</span>, <span class="hljs-number">-3</span>, <span class="hljs-number">-3</span>,  <span class="hljs-number">5</span>, <span class="hljs-number">-3</span>])<br>    <span class="hljs-keyword">return</span> core.std.Expr([kirsch1, kirsch2, kirsch3, kirsch4, kirsch5, kirsch6, kirsch7, kirsch8],<br>                         <span class="hljs-string">'x y max z max a max b max c max d max e max'</span>)<br></code></pre></td></tr></table></figure><p>显然，简单的复制粘贴并不是一个好主意。当然，代码可以运行。但我不是数学家，而只有数学家才能去编写优雅的代码解决这一问题。换一种思路。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">kirsch</span><span class="hljs-params">(src: vs.VideoNode)</span> -&gt; vs.VideoNode:</span><br>    w = [<span class="hljs-number">5</span>]*<span class="hljs-number">3</span> + [<span class="hljs-number">-3</span>]*<span class="hljs-number">5</span><br>    weights = [w[-i:] + w[:-i] <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">4</span>)]<br>    c = [core.std.Convolution(src, (w[:<span class="hljs-number">4</span>] + [<span class="hljs-number">0</span>] + w[<span class="hljs-number">4</span>:]), saturate=<span class="hljs-literal">False</span>) <span class="hljs-keyword">for</span> w <span class="hljs-keyword">in</span> weights]<br>    <span class="hljs-keyword">return</span> core.std.Expr(c, <span class="hljs-string">'x y max z max a max'</span>)<br></code></pre></td></tr></table></figure><p>已经好多了，先不去管可读性更强的代码。</p><p>将 Sobel mask 与 Kirsch mask 比较，后者的准确性有了明显提升。</p><p>边缘检测的精度越高，就越容易将噪点识别为边缘，可以通过事先降噪来克服上述问题。</p><p>提升精度对速度的影响可以忽略不计，对于 8bit 1080p 输入源，单纯 Sobel 算子（非 VapourSynth 内置的 Sobel 函数，因为它还包括了高通/低通滤波与缩放功能，速度更慢）速度约为 215fps，Kirsch 算子速度为 175fps。诚然，Sobel 算子也检出了许多边缘，但有些边缘不明显，需要使用<code>std.Binarize</code>增强才能达到 Kirsch 算子的效果。</p><h4 id="Canny-算法"><a href="#Canny-算法" class="headerlink" title="Canny 算法"></a>Canny 算法</h4><p>一种更复杂的边缘检测方法是 Canny 算法（译者注：<a href="http://web.archive.org/web/20130218131253/http://bengal.missouri.edu/~kes25c/" target="_blank" rel="noopener">tritical</a> 在 AviSynth 框架下实现了 Canny 算法，被称为 TCanny 滤镜），这种算法使用类似的方法检测边缘，并将边缘的宽度缩小至 1 个像素。理想情况下，这些线条代表边缘的中部，且没有边缘被重复标记。此外，算法会进行高斯模糊，以降低噪声干扰（译者注：高斯模糊是前处理，在施加边缘检测算子之前）。一个例子如下。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">core.tcanny.TCanny(op=<span class="hljs-number">1</span>, mode=<span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><p>其中，<code>op=1</code>表示使用一种改进的算子，具有更好的信噪比。</p><p>下面是使用 5x5 卷积核的例子。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">src.std.Convolution(matrix=[<span class="hljs-number">1</span>,  <span class="hljs-number">2</span>,  <span class="hljs-number">4</span>,  <span class="hljs-number">2</span>, <span class="hljs-number">1</span>,<br>                            <span class="hljs-number">2</span>, <span class="hljs-number">-3</span>, <span class="hljs-number">-6</span>, <span class="hljs-number">-3</span>, <span class="hljs-number">2</span>,<br>                            <span class="hljs-number">4</span>, <span class="hljs-number">-6</span>,  <span class="hljs-number">0</span>, <span class="hljs-number">-6</span>, <span class="hljs-number">4</span>,<br>                            <span class="hljs-number">2</span>, <span class="hljs-number">-3</span>, <span class="hljs-number">-6</span>, <span class="hljs-number">-3</span>, <span class="hljs-number">2</span>,<br>                            <span class="hljs-number">1</span>,  <span class="hljs-number">2</span>,  <span class="hljs-number">4</span>,  <span class="hljs-number">2</span>, <span class="hljs-number">1</span>], saturate=<span class="hljs-literal">False</span>)<br></code></pre></td></tr></table></figure><p>这是尝试通过边缘检测创建边缘 mask。进过一些后处理，可以用于去取 halo 或者清理线条（尽管可以使用其他方法配合常规 mask（或许更好），比如<code>std.Maximum</code>或者<code>std.Expr</code>）。</p><h3 id="边缘-mask-的使用"><a href="#边缘-mask-的使用" class="headerlink" title="边缘 mask 的使用"></a>边缘 mask 的使用</h3><p>我们已经了解了基础知识，来看一下实际应用。目前大多数视频仍为 8bit，几乎不可避免地会产生色带（banding）。正如我在之前提到的，恢复（restoration）滤镜会引入新的瑕疵。在去色带时，细节也随之损失。进一步地，加大去色带力度，则会导致图像模糊。边缘 mask 用于修补上述副作用，实际过程为先让去色带滤镜进行去色带操作，然后使用边缘 mask 识别边缘与细节，并通过<code>std.MaskedMerge</code>恢复。</p><p>GradFun3 滤镜会在内部生成 mask，完成上述操作。另一个流行的去色带滤镜 f3kdb 则没有内置 mask 功能。</p><p>举个例子，单纯地进行去色带会破坏纹理（details，在这一语境下译为纹理比细节更合适），特别是暗场纹理。在这种情况下使用 Sobel 算子进行边缘检测，效果不好。</p><p>为了更好地识别暗场区域，使用 Retinex 算法进行局部对比度增强。</p><p>借助 Retinex 算法降低对比度，低对比度下我们能在暗场看到更丰富的内容。也许有人认为这些原本看不到的暗场细节没有意义，但随着 HDR 显示器的推广，普通观众也能看到这些细节。同时暗场细节不会占用过多码率，所以我认为保留它们没有什么坏处。</p><p>利用这些新知识，一些测试和一点点魔法，我们得到的 mask 准确性之高出乎意料。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">retinex_edgemask</span><span class="hljs-params">(luma, sigma=<span class="hljs-number">1</span>)</span>:</span><br>    ret = core.retinex.MSRCP(luma, sigma=[<span class="hljs-number">50</span>, <span class="hljs-number">200</span>, <span class="hljs-number">350</span>], upper_thr=<span class="hljs-number">0.005</span>)<br>    <span class="hljs-keyword">return</span> core.std.Expr([kirsch(luma), ret.tcanny.TCanny(mode=<span class="hljs-number">1</span>, sigma=sigma).std.Minimum(coordinates=[<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>])], <span class="hljs-string">'x y +'</span>)<br></code></pre></td></tr></table></figure><p>进一步地，借助<code>std.Binarize</code>（或类似的高通/低通函数），以及<code>std.Maximum</code>、<code>std.Inflate</code>的单独/组合调用。我们可以把这一 mask 变成适用性更强的 mask，以应用于去色带或者其他需要精确 mask 的场合。</p><h3 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h3><p>绝大部分边缘检测算法均为简单的卷积运算，在 HD 源上使用也能达到 100fps 以上的速度，像 Retinex 这样复杂的算法当然不能与之相比。虽然使用 Sobel 算子进行简单的边缘检测，速度能超过 200fps，但组合 Retinex 算法后仅为 25 fps。速度瓶颈在 Retinex 算法上，单独使用 Retinex 算法速度约为 36.6fps。一种类似但低精度的暗场增强方法为调整亮度曲线，以暴露低对比度的边缘。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">bright = core.std.Expr(src, <span class="hljs-string">'x 65535 / sqrt 65535 *'</span>)<br></code></pre></td></tr></table></figure><p>理论上，可以通过调整亮度来改善暗场区域的边缘检测效果。</p><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>数十年来，边缘检测一直是图像处理的强大工具，可以缩减图像处理的范围，助推图像分析。在视频处理中同样有重要作用，可以最大限度地降低的副作用与瑕疵。通过卷积可以快速而准确地建立边缘 mask，并且可以通过调整内核参数来自定义卷积，以用于不同目的。此外，还可以通过局部对比度增强来提高检测精度，虽然速度会慢得多。</p><p>文中提到的代码可以在<a href="https://github.com/Irrational-Encoding-Wizardry/kagefunc/blob/master/kagefunc.py" target="_blank" rel="noopener">这里</a>找到。</p>]]></content>
    
    
    <categories>
      
      <category>图像处理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>VapourSynth</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>解释 RemoveGrain</title>
    <link href="/2020/04/27/explaining-removegrain/"/>
    <url>/2020/04/27/explaining-removegrain/</url>
    
    <content type="html"><![CDATA[<p>本文翻译自 <a href="https://blog.kageru.moe/legacy/removegrain.html" target="_blank" rel="noopener">Actually Explaining RemoveGrain</a>，原作者：<a href="https://github.com/kageru" target="_blank" rel="noopener">kageru</a>。</p><a id="more"></a><h3 id="Mode-11-与-12"><a href="#Mode-11-与-12" class="headerlink" title="Mode 11 与 12"></a>Mode 11 与 12</h3><p>Mode 11 与 12 等价于</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">std.Convolution(matrix=[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>])<br></code></pre></td></tr></table></figure><p>Mode 11 和 Mode 12 没有区别，从代码上看是复制过来的，下面的测试也证明了这一点。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">&gt;&gt;&gt; d = core.std.<span class="hljs-constructor">Expr([<span class="hljs-params">clip</span>.<span class="hljs-params">rgvs</span>.RemoveGrain(<span class="hljs-params">mode</span>=11)</span>,<br>clip.rgvs.<span class="hljs-constructor">RemoveGrain(<span class="hljs-params">mode</span>=12)</span>], 'x y - abs')<br>&gt;&gt;&gt; d = d.std.<span class="hljs-constructor">PlaneStats()</span><br>&gt;&gt;&gt; d.get<span class="hljs-constructor">_frame(0)</span>.props.PlaneStatsAverage<br><span class="hljs-number">0.0</span><br></code></pre></td></tr></table></figure><p>但这两种模式与对应的卷积操作存在细微差别。</p><p><strong>Edit</strong>：这也可能是 VapourSynth-R36 中已修复的 PlaneStats bug 导致的，因为 0.05 的误差确实太大了。</p><p>（译者注：应该是 bug 导致的，在 VapourSynth-R49 中测试没有差别，下述结果为译者测试结果）</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs stylus">&gt;&gt;&gt; d = core<span class="hljs-selector-class">.std</span><span class="hljs-selector-class">.Expr</span>([src<span class="hljs-selector-class">.rgvs</span><span class="hljs-selector-class">.RemoveGrain</span>(mode=<span class="hljs-number">12</span>),<br>src<span class="hljs-selector-class">.std</span><span class="hljs-selector-class">.Convolution</span>(matrix=[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>])], <span class="hljs-string">'x y - abs'</span>)<br>&gt;&gt;&gt; d = d<span class="hljs-selector-class">.std</span><span class="hljs-selector-class">.PlaneStats</span>()<br>&gt;&gt;&gt; d.get_frame(<span class="hljs-number">0</span>)<span class="hljs-selector-class">.props</span><span class="hljs-selector-class">.PlaneStatsAverage</span><br><span class="hljs-number">0.0</span><br></code></pre></td></tr></table></figure><p>VapourSynth 内置的卷积滤镜通过插值处理边缘，而 RemoveGrain 则不处理边缘。</p><h3 id="Mode-13-16"><a href="#Mode-13-16" class="headerlink" title="Mode 13 - 16"></a>Mode 13 - 16</h3><p>这些模式为场内插值，速度非常快，但也非常不精确，类似粗制滥造的 EEDI。没有必要使用这些模式（EEDI2 于2005年发布，无论是这些模式还是 EEDI 都没必要使用）。</p><h3 id="Mode-17"><a href="#Mode-17" class="headerlink" title="Mode 17"></a>Mode 17</h3><blockquote><p>Clips the pixel with the minimum and maximum of respectively the maximum and minimum of each pair of opposite neighbour pixels.</p></blockquote><p>听上去可能有些困惑，但描述得很准确。这一模式会创建一个数组，包含极小值（lower）和极大值（upper），然后将中心像素限制在极大值的最小数和极小值的最大数之间。</p><h3 id="Mode-21-与-22"><a href="#Mode-21-与-22" class="headerlink" title="Mode 21 与 22"></a>Mode 21 与 22</h3><h4 id="Mode-21"><a href="#Mode-21" class="headerlink" title="Mode 21"></a>Mode 21</h4><p>中心像素替换为周围四对数字的最大值与最小值的均值。</p><h4 id="Mode-22"><a href="#Mode-22" class="headerlink" title="Mode 22"></a>Mode 22</h4><p>与 Mode 21 类似，但近似方式不同，比 Mode 21 更快。</p><h3 id="Mode-23-与-24"><a href="#Mode-23-与-24" class="headerlink" title="Mode 23 与 24"></a>Mode 23 与 24</h3><p>我难以解释这两个模式，也不知道这两个模式有什么用，如果想了解建议阅读代码。</p>]]></content>
    
    
    <categories>
      
      <category>图像处理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>VapourSynth</tag>
      
      <tag>Avisynth</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Grain 与 Noise</title>
    <link href="/2020/04/26/grain-and-noise/"/>
    <url>/2020/04/26/grain-and-noise/</url>
    
    <content type="html"><![CDATA[<p>本文翻译自 <a href="https://blog.kageru.moe/legacy/grain.html" target="_blank" rel="noopener">Grain and Noise</a>，原作者：<a href="https://github.com/kageru" target="_blank" rel="noopener">kageru</a>。</p><h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>在数字图像处理中存在多种噪声（noise）和瑕疵（artifacts），同时也有多种降噪算法。在本文中，有时将 grain 与 noise 作为同义词使用；通常而言，noise 是一种不符合预期的瑕疵，而 grain 则是为了实现某种特效——如回忆特效、模仿胶片电影颗粒感而添加，或为掩盖色带（banding）而添加。</p><p>Grain 增加了画面混乱程度，是熵增的过程，在视频编码时会导致比特率增加，特别是对于用来掩盖色带的噪点。这种比特率的增加并不能提升编码质量（梯度除外，这个问题我们会在后续讨论）。</p><p>Grain 并非都是坏的，对于消除或减弱色带而言甚至是必要的，但工业化制作时通常会使用动态 grain，这会极大地占用比特率。与此形成对比的是，采用 10bit 编码时，色带的问题并不明显，而且诸如静态 grain （如 f3kdb 的 grain）同样能实现良好的去色带效果。</p><p>有些人为获得干净的画面，喜欢降噪处理（denoise / degrain），仁者见仁智者见智。</p><a id="more"></a><h3 id="不同类型的-grain-与-noise"><a href="#不同类型的-grain-与-noise" class="headerlink" title="不同类型的 grain 与 noise"></a>不同类型的 grain 与 noise</h3><h4 id="1-回忆特效（Flashbacks）"><a href="#1-回忆特效（Flashbacks）" class="headerlink" title="1.回忆特效（Flashbacks）"></a>1.回忆特效（Flashbacks）</h4><h4 id="2-静态胶片颗粒（Constant-film-grain）"><a href="#2-静态胶片颗粒（Constant-film-grain）" class="headerlink" title="2.静态胶片颗粒（Constant film grain）"></a>2.静态胶片颗粒（Constant film grain）</h4><h4 id="3-背景噪点（Background-grain）"><a href="#3-背景噪点（Background-grain）" class="headerlink" title="3.背景噪点（Background grain）"></a>3.背景噪点（Background grain）</h4><h4 id="4-TV-横纹（TV-grain）"><a href="#4-TV-横纹（TV-grain）" class="headerlink" title="4.TV 横纹（TV grain）"></a>4.TV 横纹（TV grain）</h4><h4 id="5-其他特效噪点（Exceptional-grain）"><a href="#5-其他特效噪点（Exceptional-grain）" class="headerlink" title="5.其他特效噪点（Exceptional grain）"></a>5.其他特效噪点（Exceptional grain）</h4><h3 id="不同的降噪方法"><a href="#不同的降噪方法" class="headerlink" title="不同的降噪方法"></a>不同的降噪方法</h3><h4 id="1-基于傅里叶变换的频域降噪（如-dfttest、FFT3D）"><a href="#1-基于傅里叶变换的频域降噪（如-dfttest、FFT3D）" class="headerlink" title="1.基于傅里叶变换的频域降噪（如 dfttest、FFT3D）"></a>1.基于傅里叶变换的频域降噪（如 dfttest、FFT3D）</h4><p>dfftest 是一个较旧的滤镜，自 2007 年起开始开发，是一个很有效的滤镜，具有良好的细节保留能力，但会大幅降低速度，特别是在缺乏多线程支持的 AviSynth 下。VapourSynth 接口的 dfftest 速度更快，且有相同的效果。</p><p>FFT3DGPU 具有硬件加速功能，同样使用了频域降噪算法，速度更快，但细节保留方面精度较低，同时可能更容易导致模糊，可以通过反差补偿锐化来修补。该滤镜提供了 AviSynth 和 VapourSynth 接口，二者没有太大区别。</p><p>关键参数为<code>sigma</code>。</p><h4 id="2-非局部均值降噪（如-KNLmeans、TNLmeans）"><a href="#2-非局部均值降噪（如-KNLmeans、TNLmeans）" class="headerlink" title="2.非局部均值降噪（如 KNLmeans、TNLmeans）"></a>2.非局部均值降噪（如 KNLmeans、TNLmeans）</h4><p>非局部均值（non-local means）降噪由一系列 solid 降噪方法组成。KNLmeans 降噪滤镜基于 OpenCL 对 GPU 运算进行了高度优化，对整体图像处理速度无显著影响，这一点非常吸引人。在较旧的 AviSynth 视频处理框架下，与FFT3DGPU类似，使用GPU版 KNLmeans 还可以绕开 AviSynth 的单线程限制。因此除非无 GPU 设备，否则没有理由使用 CPU 版本（译者注：由于 KNLmeans 基于 OpenCL 进行 GPU 优化，所以在 NVIDIA、AMD、Intel 三家平台通用，很难遇上无 GPU 可用的情况，但在某些 GPU 设备上 KNLmeans 可能因 Bug 而无法使用，这时候才需要考虑 CPU 版本的 TNLmeans）。</p><p>KNLmeans 可以消除相当一部分（a lot of） noise，同时保留很多（a lot of）细节（尽管少于 dft 或 BM3D）。对于历史较久远的动画，推荐使用这一滤镜，因为这些动画往往存在很多 grain（通常是在蓝光重制时添加），但细节并不丰富。这种情况下，适合使用具有硬件加速且降噪力度大的滤镜，比起 FFT3D，KNLmeans 更加合适 。</p><p>需要注意这一滤镜的时-空混合模式（Spatio-Temporal mode），在默认设置下，AviSynth 和 VapourSynth 版本的 KNLmeans 均不使用时间参考帧，当参数<code>d</code>大于 0 时，在降噪中启用时间参考帧，开启时间参考帧可以改善质量。对于 YUV444 采样格式的视频，请将<code>cmode</code>参数设置为<code>True</code>，以开启色度平面降噪，因为在默认设置下仅对亮度平面进行处理。</p><p>上述两个参数的设置均会降低速度，但除非使用古老的 GPU 或者同时使用多个 GPU 优化的滤镜，否则不会对编码速度产生明显影响，控速步仍为 CPU 的编码过程。KNLmeans 的文档在<a href="https://github.com/Khanattila/KNLMeansCL/wiki" target="_blank" rel="noopener">这里</a>。</p><h4 id="3-三维块匹配算法（BM3D）"><a href="#3-三维块匹配算法（BM3D）" class="headerlink" title="3.三维块匹配算法（BM3D）"></a>3.三维块匹配算法（BM3D）</h4><p>BM3D 很有价值，也很慢，仅有 VapourSynth 接口。在 AviSynth 上运行可能会导致崩溃，除非大幅优化内存占用，否则很难实现 AviSynth 接口。</p><p>BM3D可以并行化并在 GPU 上运行（可参考此处的<a href="https://books.google.com/books?id=xqfNBQAAQBAJ&pg=PA380&lpg=PA380&dq=bm3d+GPU+parallel&source=bl&ots=MS9-Kzi-8u&sig=fMcblGOrD-wCUrZzijmAdQF2Tj8&hl=en&sa=X&ei=wljeVI-LKcqAywPVyILgDQ&ved=0CDQQ6AEwBA#v=onepage&q=bm3d%20GPU%20parallel&f=false" target="_blank" rel="noopener">文献</a>，译者注：BM3D 已经有诸多 GPU 版本，可以在 Github 等地方搜索到），但 AviSynth 或 VapourSynth 尚无 GPU 实现（译者注：在<a href="http://vsdb.top/plugins/bm3dgpu" target="_blank" rel="noopener">这里</a>提到了一份 VapourSynth 接口的 BM3D-GPU 实现，但原始代码库已无法获取）。</p><p>BM3D 实现了模糊程度与体积的最佳平衡（因此也导致了细节损失），但在基于 CPU 的降噪滤镜中，BM3D 是速度最慢的。</p><p>值得注意的是，BM3D 滤镜有一个<code>ref</code>参数，用以设定降噪时的参考视频，可以将<code>ref</code>设定为其他降噪滤镜的处理结果，从而实现 BM3D 与其他降噪滤镜的协同处理。在 BM3D <a href="https://github.com/HomeOfVapourSynthEvolution/VapourSynth-BM3D" target="_blank" rel="noopener">文档</a>中有如下举例：</p><blockquote><p>使用自定义降噪滤镜作为基础降噪结果，并使用V-BM3D的最终降噪函数做精细化处理</p><p>这样做可以在两种降噪滤镜间取长补短。在下面的例子中，SMDegrain滤镜在时空平滑上很有效，但可能导致鬼影（blending）和细节损失，V-BM3D可以很好地保留细节，但对于大的噪声pattern（例如粗颗粒）效果不好</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">src = core.bm3d.RGB2OPP(src)<br>ref = haf.SMDegrain(src)<br>flt = core.bm3d.VFinal(src, ref, radius=<span class="hljs-number">1</span>, matrix=<span class="hljs-number">100</span>).bm3d.VAggregate(radius=<span class="hljs-number">1</span>)<br>flt = core.bm3d.OPP2RGB(flt)<br></code></pre></td></tr></table></figure></blockquote><p>最关键的参数为<code>sigam</code>，可以为不同平面设定不同的数值。</p><h4 id="4-SMDegrain"><a href="#4-SMDegrain" class="headerlink" title="4.SMDegrain"></a>4.SMDegrain</h4><p>SMDegrain 似乎是很多人降噪的首选，因为它不会导致过多的模糊，而且降噪效果似乎弱到对图像没有明显影响，不会明显改变文件体积。</p><p>较弱的降噪效果也能使（因降噪而暴露的）色带更少，这在希望保留细节而不太考虑比特率的情况下很有用。</p><p>与此同时，即使不在降噪后进行反差补偿锐化，SMDegrain 似乎也可以对某些边缘起到收线/细化线条的效果。</p><p>需要注意的是，SMDegrain 在处理色度平面时可能会带来副作用，AviSynth Wiki 描述如下：</p><blockquote><p>注意在<code>plane=1-4</code>时色度平面可能会产生色度鬼影，这种情况下建议在空域中处理色度平面。</p></blockquote><p>事实上，这可以通过将多个帧模糊为单个帧进行修补。</p><h4 id="5-基于卷积神经网络的-Waifu2x"><a href="#5-基于卷积神经网络的-Waifu2x" class="headerlink" title="5.基于卷积神经网络的 Waifu2x"></a>5.基于卷积神经网络的 Waifu2x</h4><p>Waifu2x 使用深度卷积神经网络进行超分辨率与降噪，听上去很棒但需要大量算力。在图形处理器上使用 Waifu2x 对 720p 视频进行降噪，其速度可能低于 1fps（译者注：Waifu2x 进行了更新，见下文的<strong>Edit</strong>）。降噪有三种级别可供选择，2 级和 3 级降噪难以保留细节，无法使用，1 级降噪可以恰当地去除 grain，但细节的保留程度可能与输入源关系很大，且无法调节。因此在使用中，要么接受 Waifu2x 单一模式的降噪结果（而且这还可能是最慢的算法），要么换用其他降噪滤镜（译者注：Waifu2x 进行了更新，见下文的<strong>Edit</strong>）。</p><p>基于深度神经网络的算法还有很多（如<a href="https://www.researchgate.net/publication/300688682_Deep_Gaussian_Conditional_Random_Field_Network_A_Model-Based_Deep_Network_for_Discriminative_Denoising" target="_blank" rel="noopener">文献</a>），但多数未公开算法。</p><p>对于动画风格的图像使用 Waifu2x 进行降噪没有问题，但对于真实图像，其纹理可能被识别为噪点，进而被破坏。</p><p><strong>Edit</strong>：在写完本节后，Waifu2x 进行了重大升级，速度进一步提升，并且在降噪功能上提供了更多选项。</p><h4 id="6-去色带（Debanding）"><a href="#6-去色带（Debanding）" class="headerlink" title="6.去色带（Debanding）"></a>6.去色带（Debanding）</h4><h3 id="Grain-编码"><a href="#Grain-编码" class="headerlink" title="Grain 编码"></a>Grain 编码</h3>]]></content>
    
    
    <categories>
      
      <category>图像处理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>VapourSynth</tag>
      
      <tag>Avisynth</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>gcc 10尝鲜及后续</title>
    <link href="/2020/04/08/gcc-use-2/"/>
    <url>/2020/04/08/gcc-use-2/</url>
    
    <content type="html"><![CDATA[<p>在<a href="https://github.com/sekrit-twc/zimg" target="_blank" rel="noopener">zimg项目</a>的Issue中看到这样一个问题，使用gcc 10编译出现了编译器把<code>size_t</code>错认成<code>std::size_t</code>，从而导致编译出错。看到这个问题有点惊讶，gcc居然都出到10了，支持了C++20的一些新特性，便想尝试一下。</p><p>看了gcc官网，10版本还没发布编译好的版本，想了一下，比起自己编译，还是装个新版的Fedora系统更省事一点。</p><a id="more"></a><h3 id="收集各种Linux发行版"><a href="#收集各种Linux发行版" class="headerlink" title="收集各种Linux发行版"></a>收集各种Linux发行版</h3><p>说起来我也是用过复数个Linux发行版的人了，不再像一年前那样懵懂，能够比较从容地折腾这些发行版了。</p><p>Fedora也是用yum管理依赖包，这才让我想起“我眼中的各Linux发行部用户”那张图。</p><p><img src="https://i.loli.net/2020/04/08/wRYn7JoMeLNOsbq.jpg" srcset="/img/loading.gif" lazyload alt=""><br><img src="https://i.loli.net/2020/04/09/7GU1I5z9oOJX3rL.jpg" srcset="/img/loading.gif" lazyload alt=""></p><blockquote><p>fedora：红帽子家养的小白鼠无误，有什么新想(nao)法(dong)都先往fedora上招呼<br>Archlinux：战斗机，很厉害，B格很高<br>ubuntu：吉祥物，用自己的种种行为卖傻卖萌，负责Linux桌面推广，人民群众喜闻乐见，实际上没有卵用<br>redhat：我是负责服务器的工程师<br>CentOS：我是楼上那个工程师的影分身<br>gentoo linux：相比Arch这个战斗机，我已然冲出大气层<br>openSUSE：YAST就是你的专职妹抖，用♂过都说好<br>Slackware：祖宗之法大于天（任何用户都应该自己解决包依赖）<br>debian：看过动画《轻音少女》的都知道，姐姐没有妹妹来照料起居，基本就活不下去……<br>Mint：ヨーロッパ是欧洲的意思，这表示Mint是Ubuntu偷渡欧洲了？</p></blockquote><p>以上转自<a href="https://www.zhihu.com/question/22605825/answer/76171890" target="_blank" rel="noopener">Kan Kikou@知乎</a></p><h4 id="Fedora"><a href="#Fedora" class="headerlink" title="Fedora"></a>Fedora</h4><p>我对Fedora的感觉</p><ul><li>用和ArchLinux一样的GNOME桌面</li><li>用和CentOS/RedHat一样的yum包管理</li><li>工具都是最新的</li></ul><p>不过这倒是挺符合我的胃口，毕竟我就是从CentOS转到ArchLinux的。</p><p>回到Fedora本身，一开始用workstation版本，感觉对新手异常友好。但Fedora 31还没问题，Fedora 32一进入安装界面就出现诡异的花屏。然而Fedora 31也没有gcc 10啊，遂转用network install版本。</p><p>倒是挺顺利，只是忘了装桌面…嘛，反正也用不上，而且Fedora的命令行界面比ArchLinux要好多了，有彩色文字，还能占满整个屏幕，不像ArchLinux无法自适应分辨率，只有屏幕中央800x600的一小块。</p><h4 id="Linux-Mint"><a href="#Linux-Mint" class="headerlink" title="Linux Mint"></a>Linux Mint</h4><p>上面那组图真是万能，这Mint完全就是Ubuntu套个壳Windows UI的壳…更神奇的时，命令行工具长得和cmder好像…</p><p>安装过程比Fedora还傻瓜，但这也不好，没法选择基础工具的安装，比如后文中我就遇到了缺少<code>python3-dev</code>的问题。</p><h3 id="基础设施"><a href="#基础设施" class="headerlink" title="基础设施"></a>基础设施</h3><p>一开始用的Fedora桌面版，很多东西都没装；之后用命令行版，倒是因为勾选齐全，可以开箱即用。</p><p>重点记一下Fedora桌面版在使用gcc编译前的一些工作。</p><p>编译zimg的流程如下，和编译VapourSynth一样。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">./autogen.sh<br>./configure<br>make<br>make install<br></code></pre></td></tr></table></figure><p>在此之前，需要安装</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-built_in">auto</span>conf<br><span class="hljs-built_in">auto</span>make<br>make<br>libtool<br>gcc-c++<br></code></pre></td></tr></table></figure><p>逐个说一下</p><ul><li>无autoconf，<code>autogen.sh</code>脚本无法运行</li><li>无automake，运行<code>autogen.sh</code>报错缺少<code>aclocal</code>。</li><li>无make，呃…这个你懂的</li><li>无libtool，在执行<code>make</code>命令时，报错<figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs subunit"><span class="hljs-keyword">error: </span>Libtool library used but 'LIBTOOL' is undefined<br></code></pre></td></tr></table></figure></li><li>无gcc-c++，在执行<code>make</code>命令时，报错<figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs subunit"><span class="hljs-keyword">error: </span>A compiler with support for C+<span class="hljs-string">+11</span> language features is required.<br></code></pre></td></tr></table></figure></li></ul><h3 id="基础设施Plus"><a href="#基础设施Plus" class="headerlink" title="基础设施Plus"></a>基础设施Plus</h3><h4 id="构建与编译工具"><a href="#构建与编译工具" class="headerlink" title="构建与编译工具"></a>构建与编译工具</h4><p>回看之前的<a href="https://kiyamou.github.io/2020/03/11/build-vapoursynth/" target="_blank" rel="noopener">编译VapourSynth的博文</a>，才记起之前接触过autoconf、automake、libtool。这才意识到，autoconf和automake是用于构建的通用工具，而libtool则是编译依赖。</p><p><code>gcc-c++</code>是红帽家（CentOS、RedHat、Fedora）yum包管理器中的名字，在Ubuntu、Mint系的apt-get下叫<code>g++</code>。</p><p>在Linux Mint下编译VapourSynth，报错</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-function"><span class="hljs-title">checking</span></span> <span class="hljs-keyword">for</span> PYTHON3... <span class="hljs-keyword">no</span><br><span class="hljs-function"><span class="hljs-title">checking</span></span> <span class="hljs-keyword">for</span> PYTHON3... <span class="hljs-keyword">no</span><br>configure: error: Package requirements (python<span class="hljs-number">-3.6</span>) were <span class="hljs-keyword">not</span> met:<br><span class="hljs-keyword">No</span> package <span class="hljs-string">'python-3.6'</span> found<br></code></pre></td></tr></table></figure><p>这是因为缺少<code>python3-dev</code>，在红帽家的yum系中叫<code>python3-devel</code>。</p><h4 id="关于zimg"><a href="#关于zimg" class="headerlink" title="关于zimg"></a>关于zimg</h4><p>在ArchLinux下，居然能用pacman安装zimg，我记得我在ArchLinux编译VapourSynth没有编译zimg的过程，就是通过pacman安装的。</p><p>顺带，这里有必要区分下zimg。我自己所提到的zimg，包括这篇博文与之前编译VapourSynth时用的，都是指<a href="https://github.com/sekrit-twc/zimg" target="_blank" rel="noopener">sekrit-twc/zimg</a>项目，这是图像处理库，提供了位深转换、色彩空间转换、缩放功能，ArchLinux的pacman包管理器提供的zimg，也是指这个；而在另一些语境下，zimg则是指<a href="https://github.com/buaazp/zimg" target="_blank" rel="noopener">buaazp/zimg</a>，这是图像存储与处理系统。</p><h3 id="回到size-t"><a href="#回到size-t" class="headerlink" title="回到size_t"></a>回到<code>size_t</code></h3><p>这次的折腾缘起于上面Issue中gcc 10对<code>size_t</code>报错，但我尝试之后，没有报错…</p><p>于是搜了一下类似的报错（自定义了类型<code>size_t</code>，却被编译器认为是<code>std::size_t</code>忘了写<code>std</code>），原来由来已久，我还以为的gcc 10支持了什么新特性，导致代码冲突呢…</p><p>搜了下，也是一笔糊涂账，可能是编译环境中有什么问题导致的，先不管了…</p><p>写完才发现跑题了…那我也溜了吧…Orz</p><h3 id="Makefile相关"><a href="#Makefile相关" class="headerlink" title="Makefile相关"></a>Makefile相关</h3><p>既然跑题了，再塞点东西。</p><p>根据这篇博文<a href="https://blog.csdn.net/fzy0201/article/details/17427761" target="_blank" rel="noopener">Makefile/Makefile.am/Makefile.in三者关系</a>，可以梳理一下使用make构建和编译的流程。</p><ol><li><p>创建工作目录</p></li><li><p>写代码</p></li><li><p>生成<code>configure</code></p><ul><li>在zimg中借助脚本，也就是这样一行命令<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">autoreconf --verbose --install --force<br></code></pre></td></tr></table></figure></li><li>手动的话要借助<code>aclocal</code>和<code>autoconf</code>命令，分别会产生<code>aclocal.m4</code>及<code>configure</code></li></ul></li><li><p>写<code>Makefile.am</code></p></li><li><p>使用automake生成<code>Makefile.in</code></p></li><li><p>执行<code>configure</code>生成<code>Makefile</code></p></li><li><p>执行<code>make</code>编译</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>工具使用</category>
      
    </categories>
    
    
    <tags>
      
      <tag>构建与编译</tag>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JincResize 代码重构（3）</title>
    <link href="/2020/03/23/rebuild-JincResize-3/"/>
    <url>/2020/03/23/rebuild-JincResize-3/</url>
    
    <content type="html"><![CDATA[<p>JincResize avs版迁移工作告一段落了，速度比之前快了5-6倍，在这个过程中学到了C/C++结构、C++类和对象（特别是通过调用构造函数、公有函数实现抽象）、C++内存对齐与回收的知识，对堆栈有了初步的概念，同时对程序整体设计有了大致的概念。</p><p>当修改好readme，发布了JincResize-r7-RC1，再来回看commit历史，有些感动。在这一周的时间中，有些印象很深的改动，都忘记了是早期的几天就完成的；而同时在最初的几天，以现在的视角看，更多的是四处尝试，像在黑暗中一样，但最终是看到了光亮。</p><a id="more"></a><p>如果说早期的coding是崎岖但知道方向；那么中期之后，在我得到一份能看到结果、但带有问题的代码时，再往前走，就有些戏剧性了。虽然通过Debug找到一些改正的线索，但还不够，真要靠一些运气才走下去的。当时主要是为了在实际代码中应用一下类，其实不用类完全也可以实现当时预想的目的。在这个过程中学到基础知识且不提，在把计算Lut（Look up table）的过程放到Lut类后，我突然意识到，把整个计算好的Lut表传给函数，（占用了过多内存），可能是导致编译好dll调用一次就崩溃的原因。这时我才明白avs版代码为什么要封装一个函数，Lut表中的数据随用随调。虽然是仿写，但我自己能独立想到原因，这也是值得欣喜的。之后又经历了一两天的折腾，才明白怎么去正确地初始化变量。终于不崩溃了。</p><p>虽然还有一个bug未解决，但这两三天也为此花了不少时间，该放下就放下，先告一段落吧，这一周的工作已经收获很多了。</p><p>要学会发现和留住成就感，这是增加自信的一种方式。</p><h3 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h3><p><code>_aligned_malloc()</code>、<code>_aligned_free()</code>是微软提出的动态申请、释放内存对齐函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">void</span>* _aligned_malloc(<span class="hljs-keyword">size_t</span> size, <span class="hljs-keyword">size_t</span> alignment);<br><span class="hljs-keyword">void</span>* _aligned_free(<span class="hljs-keyword">void</span>* memblock);<br></code></pre></td></tr></table></figure><p>Examples：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">_aligned_malloc(array_size * <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">float</span>), <span class="hljs-number">64</span>);<br>_aligned_free(<span class="hljs-built_in">array</span>);<br></code></pre></td></tr></table></figure><p>Windows下的gcc编译器也可以接受上述函数，但Linux下的gcc编译器就不行了。</p><p>Linux下的通用替代方法且不提，在VapourSynth下有专门的替代函数<code>vs_aligned_malloc()</code>、<code>vs_aligned_free()</code>，用法和前面的原始函数一样（虽然就是给Linux下的相应函数起个别名，但毕竟方便很多）。</p><h3 id="从结构到类"><a href="#从结构到类" class="headerlink" title="从结构到类"></a>从结构到类</h3><p>这次迁移了AviSynth版JincResize中的EWA（椭圆加权平均）重采样方法，关于算法本身的疑问先放一下（因为我还是觉得，AviSynth版用的重采样也是通过圆划定范围、进行计算，而非椭圆——虽然直观时上觉得，干脆用椭圆的长轴长为半径画圆不是更精确吗？或许椭圆本身能减少不太必要的计算？），在实现算法时，设计了两个类，一个（辅助的）类用来存放重采样/反向映射用的圆/椭圆半径、指针移动相关的数据，另一个类用来存放传递过来的核心Lut表及其他辅助数据（包括前一个类）。</p><p>以上这些都是常规设计，但计算时的函数调用，让我感觉把结构改成类，或许看上去更C++一点。</p><p>如果就是单独存一些数据，那似乎是没必要把结构写成类，但类似构造函数的初始化、计算，类似析构函数的内存释放都出来了，而且就单独写一个函数放在头文件里，可能写成类和成员函数看上去更舒服一点。</p><p>带着这种想法，我打算先把主cpp中计算Lut表的过程单独拿出来写成类（至于上面提到的EWA重采样过程，既然结构已经完善，先这样放着吧）。具体的过程，写几个私有变量、构造函数、Lut计算函数、空的析构函数，再写一个销毁数组释放内存的函数，大概就OK了。</p><p>调用，用new方法新建一个Lut对象（实际操作为创建一个数组），将Lut计算函数作用于该对象（由于数组用new方法创建，所以用指针运算符<code>-&gt;</code>访问成员函数），将lut数组定义为Lut类的公有变量，在主cpp里调用lut数组，传递给后续函数（commit <a href="https://github.com/Kiyamou/VapourSynth-JincResize/commit/8fbcfdc1797f7209997eaee3aea8c898ef755f28" target="_blank" rel="noopener"><code>8fbcfdc</code></a>）。</p><h3 id="不要一次都塞进来"><a href="#不要一次都塞进来" class="headerlink" title="不要一次都塞进来"></a>不要一次都塞进来</h3><p>在当时，代码存在一个问题，虽然能正常运行，但只能运行一次，每次关闭vsedit的预览窗口，再打开，就会崩溃。</p><p>我想到，现在把计算Lut表的过程封装/抽象成类，但本质上和之前没有区别，还是把整个lut数组传递给函数，这可能导致内存泄漏，可能是导致崩溃的原因。</p><p>同时，我发现我在写构造函数、创建lut数组时，没有确定数组长度，像下面这样。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">int</span> lut_size;<br>    <span class="hljs-keyword">double</span> radius;<br>    <span class="hljs-keyword">double</span> blur;<br>&#125;;<br><br>Lut::Lut()<br>&#123;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> defined(_MSC_VER)</span><br>    lut = <span class="hljs-keyword">new</span> <span class="hljs-keyword">double</span>[lut_size];<br><span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span><br>    lut = (<span class="hljs-keyword">double</span>*)_mm_malloc(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">double</span>) * lut_size, <span class="hljs-number">64</span>);<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br>&#125;<br></code></pre></td></tr></table></figure><p>于是从两个方向入手解决。</p><ul><li><p>增加获取Lut数组的函数，这样改后应该是一次传递一个，而不是把每次都把整个数组传递过去（commit <a href="https://github.com/Kiyamou/VapourSynth-JincResize/commit/70100f24e645f5a08e912451425be0365110c934" target="_blank" rel="noopener"><code>70100f</code></a>）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">float</span> Lut::GetFactor(<span class="hljs-keyword">int</span> index)<br>&#123;<br>  <span class="hljs-keyword">return</span> (<span class="hljs-keyword">float</span>)lut[index];<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>给<code>lut_size</code>手动设定初始值（commit <a href="https://github.com/Kiyamou/VapourSynth-JincResize/commit/5fcf58470c157c1329214aaea6f7a507872c6c64" target="_blank" rel="noopener"><code>5fcf58</code></a>），虽然代码不好看，但毕竟解决问题了</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">int</span> lut_size = <span class="hljs-number">1024</span>;<br>&#125;;<br></code></pre></td></tr></table></figure></li></ul><h3 id="Debug"><a href="#Debug" class="headerlink" title="Debug"></a>Debug</h3><h4 id="基于vsedit自带的信息"><a href="#基于vsedit自带的信息" class="headerlink" title="基于vsedit自带的信息"></a>基于vsedit自带的信息</h4><p>最开始写好初版代码，编译好后，vsedit居然打不开了。于是先打开vsedit再把dll丢进去，终于看到报错信息，原来是我把python接口的<code>float</code>写成了<code>foat</code>…orz…在编译时肯定看不出来问题，在调用时肯定出问题…</p><h4 id="VS-Debug"><a href="#VS-Debug" class="headerlink" title="VS Debug"></a>VS Debug</h4><h5 id="调试方法"><a href="#调试方法" class="headerlink" title="调试方法"></a>调试方法</h5><p>在“调试”-“命令”里把vsedit的路径写进去，就可以用VS调试了。</p><p>一开始我傻傻地把gcc编译好dll丢进去，让VS调试…呃，肯定是加载不了啊。</p><h5 id="崩溃问题"><a href="#崩溃问题" class="headerlink" title="崩溃问题"></a>崩溃问题</h5><p>前面提到的<code>lut_size</code>没有初始化，就是借助VS Debug发现的。</p><h5 id="文字的Bug"><a href="#文字的Bug" class="headerlink" title="文字的Bug"></a>文字的Bug</h5><p>虽然用断点查看具体计算过程有些有趣，但对解决文字Bug没有实质性的帮助。这个问题先放一放吧。</p>]]></content>
    
    
    <categories>
      
      <category>Code</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Travis CI持续集成与各编译器对C++新特性的支持</title>
    <link href="/2020/03/12/CI-and-compiler/"/>
    <url>/2020/03/12/CI-and-compiler/</url>
    
    <content type="html"><![CDATA[<h3 id="Travis-CI的部署"><a href="#Travis-CI的部署" class="headerlink" title="Travis CI的部署"></a>Travis CI的部署</h3><p>很早就有体验Travis CI持续集成的想法，于是拿<a href="https://github.com/Kiyamou/VapourSynth-JincResize" target="_blank" rel="noopener">VapourSynth-JincResize</a>项目试一试。</p><h4 id="依赖问题"><a href="#依赖问题" class="headerlink" title="依赖问题"></a>依赖问题</h4><p>昨天给JincResize项目照猫画虎写了<code>.travis.yml</code>脚本。一开始打算沿用我在Linux下编译的模式，基于meson+ninja构建。为此还专门去搜了Github Issues，从Issues上面抄了使用meson的<code>.travis.yml</code>脚本。</p><p>但等我上传了脚本、部署完成之后才想起，JincResize项目使用pkg-config解决依赖的问题，而配置pkg-config需要先编译VapourSynth…在服务器上编译也不是不行，但这样也太脱裤子放屁了…于是我便想不借助构建工具了，直接用gcc编译，反正我的项目结构简单。</p><a id="more"></a><p>直接用gcc编译也需要解决VapourSynth头文件的依赖，绞尽脑汁想了个略显蛋疼的办法，从VapourSynth的官方仓库中下载头文件到服务器，再移到相应位置。之所以这么折腾，而不是把需要的头文件传到JincResize项目的仓库中，是因为<del>很多其他VapourSynth的Plugin项目都不传这类通用头文件</del>不同版本VapourSynth头文件对应不同版本的VapourSynth API，API版本不同，编译出来的动态链接库没法被VapourSynth主程序调用。如果我自己向仓库传了某一版本的头文件，反而可能误导其他人。</p><p>然而VapourSynth毕竟不是一个小项目，起初想试一下git 2.25.0新增的部分克隆功能，只克隆我需要的两个头文件，但我太笨了…不会用。遂用wget下载Release中打包好的源码（体积毕竟比整个仓库小），然后再解压我想要的文件、移动。</p><h4 id="编译器版本问题"><a href="#编译器版本问题" class="headerlink" title="编译器版本问题"></a>编译器版本问题</h4><p>Travis CI服务器用的是ubuntu 16 + gcc 5，由于JincResize项目使用了C++17的特殊数学函数（<code>cyl_bessel_j()</code>），需要gcc 7及以上版本。好办，直接给服务器装gcc 7呗。</p><p>话是这么说，而且也部署成功并编译通过了，但我总觉得安装gcc 7时要把系统依赖都升级一遍（<code>sudo apt-get upgrade</code>）有点不太环保（<del>虽然Travis CI的服务器性能强劲</del>）。于是改了一下代码，当gcc版本小于7时，用传统的<code>ji()</code>函数，不涉及C++17。</p><p>总算环保地在服务器上编译通过了。</p><h3 id="各编译器对C-新特性的支持"><a href="#各编译器对C-新特性的支持" class="headerlink" title="各编译器对C++新特性的支持"></a>各编译器对C++新特性的支持</h3>]]></content>
    
    
    <categories>
      
      <category>工具使用</category>
      
    </categories>
    
    
    <tags>
      
      <tag>构建与编译</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ArchLinux下VapourSynth和VapourSynth-editor的编译与配置</title>
    <link href="/2020/03/11/build-vapoursynth/"/>
    <url>/2020/03/11/build-vapoursynth/</url>
    
    <content type="html"><![CDATA[<h3 id="ArchLinux安装桌面"><a href="#ArchLinux安装桌面" class="headerlink" title="ArchLinux安装桌面"></a>ArchLinux安装桌面</h3><p>参考<a href="https://www.viseator.com/2017/05/17/arch_install/" target="_blank" rel="noopener">以官方Wiki的方式安装ArchLinux</a>安装ArchLinux的基本系统。</p><p>参考<a href="https://starrycat.me/archlinux-install-gnome-desktop.html" target="_blank" rel="noopener">ArchLinux安装GNOME图形桌面环境</a>和<a href="https://www.viseator.com/2017/05/19/arch_setup/" target="_blank" rel="noopener">ArchLinux安装后的必须配置与图形界面安装教程</a>安装图形界面。</p><p>顺带提一下我的经验，若是在VMware虚拟机中安装，不要在VM下拉伸桌面，不然重启系统后黑屏…</p><h3 id="编译VapourSynth"><a href="#编译VapourSynth" class="headerlink" title="编译VapourSynth"></a>编译VapourSynth</h3><p>在之前的<a href="https://kiyamou.github.io/2020/02/07/arch-and-meson/" target="_blank" rel="noopener">一篇博文</a>中，提到了编译VapourSynth。但我不知道为什么，可能是升级了ArchLinux系统（<code>pacman -Syu</code>），导致之前编译好的用不了，只能重新编译一次。</p><a id="more"></a><h4 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h4><p>VapourSynth的必要依赖包括：</p><ul><li>构建与编译依赖<ul><li>Autoconf、Automake、Libtool</li><li>pkg-config</li><li>GCC 4.8及以上版本 或 Clang</li></ul></li><li>功能依赖<ul><li>zimg <a href="https://github.com/sekrit-twc/zimg/tree/v2.9" target="_blank" rel="noopener">v2.9分支</a> （由于新版R49增加了<code>spline64</code>，这是zimg 2.9.3新增的内容，所以要用新版）</li></ul></li><li>Python环境<ul><li>Python 3 （Python 3即可，不需要指定3.x，只有Windows下安装编译好的二进制文件时，才需要限定小版本）</li><li>Cython 0.28及以上版本</li></ul></li></ul><p>此外，还有四个可选的依赖</p><ul><li>构建文档：Sphinx</li><li>编译字幕滤镜：iconv、libass、ffmpeg</li><li>编译读写图片的Imwri滤镜：ImageMagick 7</li><li>编译OCR滤镜：Tesseract 3</li></ul><p>我感兴趣的是Imwri，而ImageMagick 7作为ArchLinux默认安装的包已经装好了。</p><p>在ArchLinux下，安装必要依赖的命令如下。</p><p>（gcc和Python 3应该是装好系统就自带了，没写。（在ArchLinux的pacman语境下，gcc指最新版的gcc（目前是9.2.1），这个应该是系统默认就安装了的，gcc8指gcc 8.x的稳定版，应该需要自己安装。））</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">pacman -S autoconf automake libtool<br>pacman -S pkg-config<br>pacman -S zimg<br><br>pip install cython<br></code></pre></td></tr></table></figure><h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><p>下载VapourSynth源码。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">git clone https://github.com/vapoursynth/vapoursynth.git<br>cd vapoursynth<br></code></pre></td></tr></table></figure><p>若担心开发中的版本不稳定，可下载打包发布的版本。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">wget https://github.com/vapoursynth/vapoursynth/archive/R49-RC1.tar.gz<br>tar -xzvf R49-RC1.tar.gz<br>cd vapoursynth-R49-RC1<br></code></pre></td></tr></table></figure><p>进行构建和编译。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">./autogen.sh<br>./configure<br>make<br>make install<br></code></pre></td></tr></table></figure><p>在这里提一下我编译时遇到的问题。我用的源码是R49-RC1版本，自带的<code>resize</code>函数新增了<code>spline64</code>，然而我在编译中报错说<code>ZIMG_RESIZE_SPLINE64</code>未声明。于是把两行相关代码注释掉（位于<code>src/core/vsresize.cpp</code>），编译通过。可能和zimg版本问题有关？我猜的。</p><p>补记：猜的没错，新版R49增加了<code>spline64</code>，这是zimg 2.9.3新增的内容。</p><p>顺带试了一下R48，因为这个版本还没有添加<code>spline64</code>，结果出现了一个通用的报错，没有去深究，放弃了。</p><h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><p>编译好后，配置搜索路径和Python环境。</p><p>编译完成，会在<code>/usr/local/lib</code>（或其他类似的文件中）得到相关<code>.so</code>库文件，包括<code>libvaoursynth.so</code>、<code>libvapoursynth-script.so.0.0.0</code>，把这些库文件链接到<code>/usr/lib</code>中，完成搜索路径的配置。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">ln -s /usr/local/lib/libvapoursynth.so /usr/lib/libvapoursynth.so<br>ln -s /usr/local/lib/libvapoursynht-script.so.0.0.0 /usr/lib/libvapoursynth-script.so<br></code></pre></td></tr></table></figure><p>配置好搜索路径，在Python中安装VapourSynth。这听上去有点怪，但根据VapourSynth的设计思路，需要先完成上面的编译和配置，才能用pip安装。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">pip install vapoursynth<br></code></pre></td></tr></table></figure><p>完成上述配置后，vsedit就能搜索到VapourSynth。</p><h3 id="编译vsedit"><a href="#编译vsedit" class="headerlink" title="编译vsedit"></a>编译vsedit</h3><h4 id="安装依赖-1"><a href="#安装依赖-1" class="headerlink" title="安装依赖"></a>安装依赖</h4><p>vsedit是基于qt的图形界面程序，需要qt5相关的依赖包。</p><p>下面列出的这个包是我个人在编译vsedit中需要的。根据官方的编译指南，需要<code>build-essential</code>、<code>qtbase5-dev</code>。但在ArchLinux下似乎不叫这两个名字，没有去深究。强行编译，发现缺少下面这个包。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">pacman -S qt5-websockets<br></code></pre></td></tr></table></figure><h4 id="配置头文件"><a href="#配置头文件" class="headerlink" title="配置头文件"></a>配置头文件</h4><p>编译时需要VapourSynth的头文件，也就是<code>vapoursynth/include</code>文件下的三个<code>.h</code>文件。在<code>/usr/include</code>中新建一个<code>vapoursynth</code>文件夹，把这三个文件复制过去即可。</p><h4 id="编译-1"><a href="#编译-1" class="headerlink" title="编译"></a>编译</h4><p>下载源码。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">git clone https://bitbucket.org/mystery_keeper/vapoursynth-editor.git<br>cd vapoursynth-editor/pro<br></code></pre></td></tr></table></figure><p>进行构建和编译。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">qmake -norecursive pro.pro CONFIG+=release<br>make<br></code></pre></td></tr></table></figure><p>在<code>vapoursynth-editor/build/release-64bit-gcc</code>或类似的地方，得到vsedit等二进制文件，可以用<code>ln</code>命令做一个链接，方便平时使用。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ln -s $Home/vapoursynth-editor/build/release-64bit-gcc/vsedit ~/Desktop/vsedit<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd ~/Desktop<br>./vsedit<br></code></pre></td></tr></table></figure><p>运行vsedit，即可弹出图形界面。</p><h3 id="关于滤镜"><a href="#关于滤镜" class="headerlink" title="关于滤镜"></a>关于滤镜</h3><p>滤镜应该放在<code>/usr/local/lib/vapoursynth</code>下。</p>]]></content>
    
    
    <categories>
      
      <category>工具使用</category>
      
    </categories>
    
    
    <tags>
      
      <tag>构建与编译</tag>
      
      <tag>Linux</tag>
      
      <tag>VapourSynth</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>周记 2020.03.02-03.08</title>
    <link href="/2020/03/08/week-202003-1/"/>
    <url>/2020/03/08/week-202003-1/</url>
    
    <content type="html"><![CDATA[<h3 id="1-逐项完成ISP算法"><a href="#1-逐项完成ISP算法" class="headerlink" title="1.逐项完成ISP算法"></a>1.逐项完成ISP算法</h3><p>感慨到还是Python方便啊，在涉及矩阵运算的时候。另外，还是觉得先要解决一下数据结构的问题，不然现在写起来太蛋疼了。</p><p>重新梳理了一遍ISP的流程，重点看了Tone Mapping和Gamma校正。</p><a id="more"></a><h3 id="2-C-科学计算"><a href="#2-C-科学计算" class="headerlink" title="2.C++科学计算"></a>2.C++科学计算</h3><p>Eigen库是一个C++科学计算库，主要是各种矩阵运算。</p><h3 id="3-为什么没好好学数学"><a href="#3-为什么没好好学数学" class="headerlink" title="3.为什么没好好学数学"></a>3.为什么没好好学数学</h3><p>本不该倒垃圾，但这几年的学，从数学能力的角度，真是越上越回去了（所以这也是我的专业症结所在）。矩阵论稀里糊涂上完了…在看现在需要用的SVD、范数计算…数学跟不上了…</p><h3 id="4-VSGAN与升级VS版本"><a href="#4-VSGAN与升级VS版本" class="headerlink" title="4.VSGAN与升级VS版本"></a>4.VSGAN与升级VS版本</h3><p>（先吐槽一句，为什么我电脑上装了3.6、3.7、3.8三个版本的Python…而且更蛋疼的是Python 3.7装在了Visual Studio里面…）</p><p>干脆把电脑有Python全卸了，重装上了Python 3.8，VapourSynth也升级到了最新的R49预览版。由于这次把Python装在<code>C:\Program Files</code>里面，经常需要管理员权限，有点蛋疼…</p><p>弄好环境后，尝试了VSGAN，想试一下<code>waifuGAN</code>和<code>1xESRGAN</code>两个模型，然而电脑没有显卡，用CPU实在太慢了，先放弃了…</p><p>看了一下VSGAN的代码（还是Python看着简洁），基于Pytorch调用.pth模型，实现基于ESRGAN网络的超分辨率或其他操作。模型可以在<a href="https://upscale.wiki/wiki/Model_Database" target="_blank" rel="noopener">这里</a>找到。</p><p>说起来两个星期前还在感叹技术太渣，连ESRGAN模型调用都调不了…现在也算是（借助别人的工具）弥补上了。</p><h3 id="5-原生分辨率"><a href="#5-原生分辨率" class="headerlink" title="5.原生分辨率"></a>5.原生分辨率</h3><p>这个东西也算是我的心结之一了。<code>getnative.py</code>搞定，测试了一下，感觉鲁棒性还挺好，而对于我自己缩到720p再升到1080p的例子，也能认出是720p（但是信号特征不如原始图片855p那么明显）。</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>VapourSynth</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>周记 2020.02.24-03.01</title>
    <link href="/2020/03/05/week-202002-4/"/>
    <url>/2020/03/05/week-202002-4/</url>
    
    <content type="html"><![CDATA[<h3 id="1-C-互斥锁"><a href="#1-C-互斥锁" class="headerlink" title="1.C++互斥锁"></a>1.C++互斥锁</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;mutex&gt;</span></span><br><br><span class="hljs-built_in">std</span>::mutex<br></code></pre></td></tr></table></figure><a id="more"></a><h3 id="2-解决VapourSynth版本问题？"><a href="#2-解决VapourSynth版本问题？" class="headerlink" title="2.解决VapourSynth版本问题？"></a>2.解决VapourSynth版本问题？</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> VAPOURSYNTH_API_VERSION &lt; 0x30002</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> FMTC_RESAMPLE_OLD_FIELDBASED_BEHAVIOUR</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br></code></pre></td></tr></table></figure><p>（来自KNLmeansCL？）</p><h3 id="3-OpenCL"><a href="#3-OpenCL" class="headerlink" title="3.OpenCL"></a>3.OpenCL</h3><p>看了《OpenCL异构计算》的两个例子，借助OpenCL加速图像直方图处理和卷积计算。</p><h3 id="4-OpenCL设计思路的理解"><a href="#4-OpenCL设计思路的理解" class="headerlink" title="4.OpenCL设计思路的理解"></a>4.OpenCL设计思路的理解</h3><p>我能理解到的几点…</p><ul><li>OpenCL中存在主机与设备共享内存？（定义了通用的内存模型，以实现跨平台）</li><li>类似cuda，OpenCL的计算模式大概也是“先传输数据到设备，计算后再传回主机”？（OpenCL通过上下文（Context）在主机与设备间通信）</li><li>OpenCL主要使用 SIMD（数据并行）和 MIMD（任务并行）</li><li>CPU 线程 = OpenCL 工作项（Work Item）</li></ul><h3 id="5-OpenCL与C"><a href="#5-OpenCL与C" class="headerlink" title="5.OpenCL与C++"></a>5.OpenCL与C++</h3><p>在C++中使用OpenCL，可以直接调用OpenCL库，也可以借助Boost库的compute库调用。</p><p>可以不写的<code>.cl</code>文件的说。</p><h3 id="6-C-STL库"><a href="#6-C-STL库" class="headerlink" title="6.C++ STL库"></a>6.C++ STL库</h3><p>C++标准模板库，（抛开<code>string</code>）可以分为两条线路，容器与方法。元素的插入、删除和访问方法不同，构成了不同容器的差别，而方法可以理解成一个函数，或者说一种操作。</p><p>例如容器<code>vector</code>、<code>queue</code>，方法<code>at</code>、<code>emplace</code>。</p><p>感觉现在，我已经把21天学通C++这本书从总体上做了概览。</p><h3 id="7-Mkdocs：写自己的图书"><a href="#7-Mkdocs：写自己的图书" class="headerlink" title="7.Mkdocs：写自己的图书"></a>7.Mkdocs：写自己的图书</h3><p>去搜算法导论的课后题，偶然发现了Mkdocs，感觉比gitbooks自由度更高。也知道了原来github pages不仅可以用来搭博客，还可以做一般项目的展示页。github展示页配合Mkdocs就可以实现自己的图书。</p><h3 id="8-交流"><a href="#8-交流" class="headerlink" title="8.交流"></a>8.交流</h3><p>在D9上帖出了AreaResize，通过交流我才意识到，之前我修改的JincResize，以及其他常用的Resize方法，都可以视为卷积操作（所以这也带来了OpenCL加速或指令集优化的可能）。</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>OpenCL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>周记 2020.02.17-02.23</title>
    <link href="/2020/03/05/week-202002-3/"/>
    <url>/2020/03/05/week-202002-3/</url>
    
    <content type="html"><![CDATA[<h3 id="1-边缘检测"><a href="#1-边缘检测" class="headerlink" title="1.边缘检测"></a>1.边缘检测</h3><p>突然注意到一个事情，用Laplacian和Sobel算子，过渡/渐变性的背景不会被误认为是边缘，而用Schaar和Canny，尤其是前者，就有这种问题。</p><p>嗯，虽然是和参数有关的（更何况Schaar调一下就可以变成Sobel），但还是值得注意一下。</p><a id="more"></a><h3 id="2-utility"><a href="#2-utility" class="headerlink" title="2.utility"></a>2.utility</h3><h3 id="3-自己写ISP"><a href="#3-自己写ISP" class="headerlink" title="3.自己写ISP"></a>3.自己写ISP</h3><p>我自己写，还是用C++吧</p><h3 id="4-回到vs"><a href="#4-回到vs" class="headerlink" title="4.回到vs"></a>4.回到vs</h3><p>之前一直没有用过lut调色板，只是用Expr工具。通过循环给数组赋值，做一个lut，然后用这个lut调节亮度。</p><p>说起来，Python当中的<code>try</code>、<code>append()</code>我都没用过。</p><h3 id="5-并行与MPI与其他"><a href="#5-并行与MPI与其他" class="headerlink" title="5.并行与MPI与其他"></a>5.并行与MPI与其他</h3><p>回想起一年前上的并行计算课，有些东西真的是在不经意间积累，然后又不经意的出现在你身边。</p><p><a href="https://chenxiaowei.gitbook.io/heterogeneous-computing-with-opencl2-0/1.0-chinese/1.9-chinese" target="_blank" rel="noopener">OpenCL 2.0 异构计算</a></p><blockquote><p>消息传递接口（MPI）库经历了时间的磨砺，在当今环境下依旧是很受欢迎的消息传递中间件</p></blockquote><p>粒度，不同模型：</p><ul><li>单指令多数据（SIMD）</li><li>单程序多数据（SPMD）</li></ul><p>OpenCL的内核类似于SPMD模型</p><p>说起来fmtc有指令集优化，但没用OpenCL。（话说我见过的用OpenCL的滤镜也只有Canny和KNMeans了）</p><h3 id="6-Mat与IPlImage"><a href="#6-Mat与IPlImage" class="headerlink" title="6.Mat与IPlImage"></a>6.Mat与IPlImage</h3><p>IPlIMage是OpenCV 1中概念，Mat则是OpenCV 2与OpenCV 3中的概念。Mat“更加C++”，引入了类的概念，同时不再需要像IPlIMage那执着于内存管理。</p><p>现在读取raw格式还是用的IPlIMage，总感觉这样不太好，还是用Mat更好吧。我得再整理一下整个处理流程了…要不直接把14bit补成16bit？</p><p>后续就是用<code>cvConvertScale()</code>函数把14bit扩张/收缩到了16bit/8bit。</p><h3 id="7-C-基础"><a href="#7-C-基础" class="headerlink" title="7.C++基础"></a>7.C++基础</h3><p>读到了<a href="https://changkun.de/modern-cpp/" target="_blank" rel="noopener">《现代C++教程：高速上手 C++ 11/14/17/20》</a>这本书，感慨万千啊，过多话不展开了，记录一下我读到的内容。</p><h4 id="auto关键字"><a href="#auto关键字" class="headerlink" title="auto关键字"></a>auto关键字</h4><p><code>auto</code>不能用于函数传参，也不能用于数组推导。</p><h4 id="区间for迭代"><a href="#区间for迭代" class="headerlink" title="区间for迭代"></a>区间for迭代</h4><p>让C++像Python那样简洁地写for循环。</p><h4 id="typename与class"><a href="#typename与class" class="headerlink" title="typename与class"></a>typename与class</h4><p>在写模版时，<code>typename</code>与<code>class</code>大部分时候没有区别，但有嵌套依赖类型的变量时，需要使用<code>typename</code>。</p><h4 id="实例化与外部模版"><a href="#实例化与外部模版" class="headerlink" title="实例化与外部模版"></a>实例化与外部模版</h4><p>C++11引入了外部模版，可以控制编译器是否对模版进行实例化。通过<code>template class</code>与<code>extern template class</code>关键字实现。</p><h4 id="默认模版参数"><a href="#默认模版参数" class="headerlink" title="默认模版参数"></a>默认模版参数</h4><p>C++11可指定默认模版参数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T = <span class="hljs-keyword">int</span>, <span class="hljs-keyword">typename</span> U = <span class="hljs-keyword">int</span>&gt;<br></code></pre></td></tr></table></figure><h4 id="变长参数模版"><a href="#变长参数模版" class="headerlink" title="变长参数模版"></a>变长参数模版</h4><p>可以对类模板和函数模版使用变长参数（真的~好神奇的感觉~~）。</p><h4 id="面向对象部分的新特性"><a href="#面向对象部分的新特性" class="headerlink" title="面向对象部分的新特性"></a>面向对象部分的新特性</h4><p>这部分有点过于强大…我还得好好理解一下…我之前一直不知道<code>override</code>和<code>final</code>这两个关键字是C++11引入的新特性。</p><h3 id="8-去马赛克"><a href="#8-去马赛克" class="headerlink" title="8.去马赛克"></a>8.去马赛克</h3><p>突发奇想，从某个角度想，raw格式照片的Bayer数据结构，和YUV420的色度半采样有点像。</p><p>一些问题</p><p>难得在运行出错后，在cmd里有了报错信息，如下。</p><figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs taggerscript">OpenCV(3.4.9) Error: Assertion failed (size.width&gt;0 &amp;&amp; size.height&gt;0) in cv::imshow, file C:<span class="hljs-symbol">\b</span>uild<span class="hljs-symbol">\3</span>_4_winpack-build-win64-vc15<span class="hljs-symbol">\o</span>pencv<span class="hljs-symbol">\m</span>odules<span class="hljs-symbol">\h</span>ighgui<span class="hljs-symbol">\s</span>rc<span class="hljs-symbol">\w</span>indow.cpp, line382<br></code></pre></td></tr></table></figure><h3 id="9-牛客网刷题"><a href="#9-牛客网刷题" class="headerlink" title="9.牛客网刷题"></a>9.牛客网刷题</h3><p>突然想到今天（2.20）明明也认真的，但Github上却没有commit。想了一下，上午在牛客网做题。嗯，这样也挺好的。</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>周记 2020.02.10-02.16</title>
    <link href="/2020/03/05/week-202002-2/"/>
    <url>/2020/03/05/week-202002-2/</url>
    
    <content type="html"><![CDATA[<h3 id="1-异常处理"><a href="#1-异常处理" class="headerlink" title="1.异常处理"></a>1.异常处理</h3><p><del>敲OpenCV，阈值化，故意尝试一个异常。</del></p><p><del>把两个回调函数的<code>imshow(&quot;Output&quot;, dst)</code>的<code>dst</code>写成同一个变量，引发如下异常。</del></p><p>上述操作根本不会引发异常…即使是拖动Trackbar也互补影响。引发异常的原因是我把<code>adaptiveThreshold()</code>的参数写错了…</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-number">0x000007FEFD77B87D</span> 处(位于 <span class="hljs-number">6.7</span>_Threshold.exe 中)有未经处理的异常: Microsoft C++ 异常: cv::Exception，位于内存位置 <span class="hljs-number">0x000000000029EC98</span> 处。<br></code></pre></td></tr></table></figure><p>抛出异常的函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">CV_INLINE CV_NORETURN <span class="hljs-keyword">void</span> <span class="hljs-title">errorNoReturn</span><span class="hljs-params">()</span>  <span class="hljs-comment">// bash.hpp 308行</span></span><br></code></pre></td></tr></table></figure><a id="more"></a><h3 id="2-自己实现ISP基本流程"><a href="#2-自己实现ISP基本流程" class="headerlink" title="2.自己实现ISP基本流程"></a>2.自己实现ISP基本流程</h3><p>这就是我的第三个项目。</p><p>核心部分，至少实现Retinex吧。</p><h3 id="3-做个学习项目？"><a href="#3-做个学习项目？" class="headerlink" title="3.做个学习项目？"></a>3.做个学习项目？</h3><p>把VapourSynth的经验用OpenCV实现一遍，放到Github上（C++实现，或许还能来个Python/Matlab多语言，或干脆Jupyter）。或许…能骗赞？</p><p>虽然对我学习本身的帮助可能不是很大。</p><h3 id="4-阅读OpenCV源码"><a href="#4-阅读OpenCV源码" class="headerlink" title="4.阅读OpenCV源码"></a>4.阅读OpenCV源码</h3><p>想看一下<code>guidedFilter()</code>的实现过程。<del>虽然官网就有，不用我折腾一圈去查OpenCV…</del></p><h3 id="5-VS-GuideFilter"><a href="#5-VS-GuideFilter" class="headerlink" title="5. VS GuideFilter"></a>5. VS GuideFilter</h3><p><del>话说vs有方块滤波（boxfilter）吗？</del> 不就是<code>RemoveGrain(20)</code>嘛。</p><p>涉及的概念：</p><ul><li><code>local patch</code></li></ul><h3 id="6-话说学一下Matlab"><a href="#6-话说学一下Matlab" class="headerlink" title="6.话说学一下Matlab"></a>6.话说学一下Matlab</h3><p>虽然从大二就接触了Matlab，但似乎没有把它视为一门语言。</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs matlab">[hei, wid] = <span class="hljs-built_in">size</span>(I);<br></code></pre></td></tr></table></figure><p>上面这句话告诉我们，Matlab与C/C++不同，左值也是可以赋值的。</p><h3 id="7-准备面试"><a href="#7-准备面试" class="headerlink" title="7.准备面试"></a>7.准备面试</h3><p>话说除了算法题，智力题什么的，也要准备一下。</p><p>话说面试面向OpenCV且要求不使用<code>Mat</code>的那类题，要看一下。</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>十年一序：我一直都没有离开，只是换了一种方式存在</title>
    <link href="/2020/02/21/look-back-10-years/"/>
    <url>/2020/02/21/look-back-10-years/</url>
    
    <content type="html"><![CDATA[<h3 id="2009"><a href="#2009" class="headerlink" title="2009"></a>2009</h3><p>第一次看到了正弦曲线。做几何题。</p><h3 id="2010"><a href="#2010" class="headerlink" title="2010"></a>2010</h3><p>看微积分。去书店买书时，初二的我说我在读高二，长得高也有优势嘛。刷数学吧。初三跑1000米，也没有怎么练，成绩比初二一下提高了至少15秒。</p><p>嫦娥二号发射。</p><a id="more"></a><h3 id="2011"><a href="#2011" class="headerlink" title="2011"></a>2011</h3><p>注册了好几个百度账号后，初中化学竞赛前又注册了一个账号，稳定地使用到现在。中考。中考结束后买了格言杂志的番外杂志，《纸时代》。也许是借着三角函数的基础，也许是初入学兴头正高，高一时考出了中学时代最好的一次排名。买了数学竞赛的书。</p><p>嫦娥二号飞抵拉格朗日L2点。</p><h3 id="2012"><a href="#2012" class="headerlink" title="2012"></a>2012</h3><p>高一寒假每天在新家和借宿的家之间来回，浪费了很多时间，很难进入一个投入的读书状态，数竞根本没有怎么看下去，这件事情我到现在都无法释怀。买了本数学五三，开始刷题，但没有坚持下去。运动会上跑了5000米和1500米，5000米的时候，P和T在一旁给我递水。</p><p>某节体育课上，X问我听没听过江南Style，我说在某个休周的周日，听说过，但没有听过。X似乎若有所思。渐渐不去刷数学吧了。</p><p>嫦娥二号飞过图塔蒂斯小行星。</p><h3 id="2013"><a href="#2013" class="headerlink" title="2013"></a>2013</h3><p>或许是从2013开始变得迷茫，也不知道为什么，或许是之前在贴吧灌水的人都渐渐走了…不知道。看不到L和Y发帖，当时应该是以为他们都杳无音信了。好像是在这一年，因为太迷茫，删了珍贵的邮件。体育课也上得没意思了。数学竞赛考得很烂…也是意料之中。之后更加迷茫，高三的卷子那么多，有时候都不想做了。自主招生和我没有搭上任何关系，把两本中等数学给了J。</p><p>《冰雪奇缘》上映，没去看电影，但被相关介绍吸引，想去做建模和渲染。</p><h3 id="2014"><a href="#2014" class="headerlink" title="2014"></a>2014</h3><p>高三的下半年成绩连降两次，降到了我从未想过的名次，之后回光返照，回到了一个看上去不错的名次。高考时又gg了。想去武大，家人不让，我退缩了。想学数学，被一些帖子劝阻了。胆小鬼没有资格追求幸福。我甚至以为数学专业要么去当老师，要么去搞科研，填完志愿了，Y的爸爸却说不是那样。</p><p>进入大学之后，看着其他学院好看的院衫，我好难过。当时就意识到我学的这个专业要读到博士才可以谈出路，但却什么都没有做。</p><p>大一上学期选了西方哲学史，上了这门课后，我就决定大学里不再选其他授课性质的公共选修课了。因为我觉得不会再有比M老师讲课更好的老师了。</p><h3 id="2015"><a href="#2015" class="headerlink" title="2015"></a>2015</h3><p>因为没有去学数学，我打算和数学告别，拒绝了两次同学的邀请，没有去做数学建模。但后来还是去上了大学数学竞赛的课，阴差阳错地拿了个省级一等奖（虽然还有特等奖Orz）。虽然大学数学竞赛的难度和含金量远远比不上高中数学竞赛，但毕竟拿了奖，还是很开心的。</p><p>暑假里大学班级集体去了青岛，走在沙滩上，和P说了曾经想做建模和渲染的愿望，感叹这条路已经渐远。</p><p>大二时重新刷贴吧，但与高二时一样，没有回到数学吧，而是去了消遣性质的地方。想辅修计算机，但大概是因为一名之差没有报上。</p><h3 id="2016"><a href="#2016" class="headerlink" title="2016"></a>2016</h3><p>寒假里额外在学校住了一段时间，本来是想学力学，但后来成了研究各种人名反应。</p><p>跟着L老师手算有限元，听H老师讲数字图像处理。第一次写Matlab代码，第一次用专业软件，第一次在C++课之外写C++。</p><p>暑假里听L讲了一个星期的数学竞赛课，之后跟着Z去实验室做三个星期的实验。看《四月是你的谎言》。上人生中最后的数学竞赛课，上课时遇到了一个女孩，也许…为数不多的感受到了心动。最后的数学竞赛草草结束，那个女孩也就消失在了人海里。</p><p>之后好像是恋爱了，和她一起跑步，给她我做过的大作业。我幻想能有一个…一起读书的女生。注册了乐乎账号。</p><h3 id="2017"><a href="#2017" class="headerlink" title="2017"></a>2017</h3><p>寒假里继续看没有看完的《四月是你的谎言》，几乎是看一次哭一次。4月底看完最后一集，5月去了武汉。在武大里骑ofo着上了珞珈山，眺望东湖，以为来到了海边。</p><p>给Y发了邮件，想交流一下未来怎么走。我这才第一次意识到生活环境工作环境之类的问题。</p><p>暑假接触B站，Github。第一次看《四月》和《柯南》之外的番剧，补完《路人女主的养成方法》第一季。</p><p>看《秒速五厘米》，看得有点自闭了。去了国防科大，但毕竟是军校，还是没有决心留在那里并且冲一冲浙大，最后选择继续在学校里读研。保研之后无所事事，才开始刷知乎。</p><p>后来我翻了朋友圈才想起，在2017年10月，我发了一个票圈，说我自己不知道努力，配图是一部微电影。现在想想，努力总要有个方向，我不是不知道努力，是没有了方向。</p><p>机缘巧合下我接触了数字图像处理和视频编码，虽然之前学过简单的数字图像处理，但当我用Matlab打开图片输出像素点值时，我感觉世界都不一样了，原来是可以如此精确地控制图像。一开始要写代码时，感觉头都大了。开始学习代码。</p><p>玩《高考恋爱一百天》，通宵打完了小涵线，一边玩一边哭。在隐藏的娜薇拉线，娜薇拉说了一句话，“不会编程的人，会被时代淘汰的”，记忆犹新。</p><h3 id="2018"><a href="#2018" class="headerlink" title="2018"></a>2018</h3><p>大四寒假是应该是我最充实的一个寒假了，带着高昂的兴趣，恶补了数字图像处理的基本知识。渐渐感受到笔记本算力的不足，想装一台PC。</p><p>寒假的某个晚上去吃拉面，当时好像还在看金融的一些东西。就感叹，选了这个专业，被限制了好多，之后也再没想过。</p><p>很认真地做毕设，遇上了H学姐，H学姐的科研精神感染了我，但这也阻止了我跳坑的决心，不知是福是祸。来到计算化学公社，接触量子化学。夏天时去北京听sob讲量子化学。夏天里还玩了《余香》，剧本篇幅中等，打完之后很模糊地说了一些想跳坑的话，但并没有让我自己下决心。</p><p>但夏天总体上是有些松懈的，说好的插值算法，说好的反卷积，都告吹了。知乎上有人提了一个问题，深度学习的调参和材料的炒菜有什么区别。研究生开学，组装了我自己的PC。数学课居然也听不下去了，或许是专业上用不到数学导致了退化。</p><h3 id="2019"><a href="#2019" class="headerlink" title="2019"></a>2019</h3><p>元旦假期去了深圳，第一次坐飞机，感受到我不能一味等他人的阳光，我也可以散发阳光去感染别人。之后又去听了sob的分子动力学。P从澳大利亚回来，几个人一起去吃了火锅，火锅真好吃。三月又一次去了武汉，去华科看了樱花，去光谷软件园吃午饭。</p><p>读研的第二个学期选了机器学习算法和人工智能基础两门课，受益匪浅。特别是机器学习算法，让我再次推导起了数学公式。借着写课程作业，开始写更多的代码，开始用Linux，开始用LaTex写报告和论文。两门课程结束，开始学Caffe，之后再次拾起C++。再之后，本想学PyTorch，但暂时放下了。在这个过程中，我渐渐意识到，我之前虽然是在敲代码，但本质上和用GUI的人没有区别，按下一个按键或者敲下几行短短的代码，都只是调用现成的东西，而我不知道原理。“从用户到开发者”，这样的念头在我的脑海里越来越清晰。</p><p>读研第三个学期过了一个月，我写了更多的代码，决计从爱好中毕业了。之后，跳坑转行的想法渐渐清晰，特别是和X聊过之后。开始了我的第一个开源项目JincResize，虽然是基于已经代码的改进，但终于迈出了第一步。忙碌的十一月十二月就这样过去了。</p><blockquote><p>写这篇回忆的直接原因是昨天突然翻到了L和Y的近况（嘛，因为不好写全名，上文有两个朋友都是Y），我本以为L和Y在2013年的前后就销声匿迹，平凡地生活，然而并不是这样，他们在努力生活。虽然不在贴吧，但是有其他地方啊。我在2013年开始消沉，以为曲终人散，但并不是这样。</p><p>一直都没有离开，只是换了一种方式存在。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>日记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>ISP笔记（2）：ISP pipeline总结</title>
    <link href="/2020/02/14/ISP-learn-2/"/>
    <url>/2020/02/14/ISP-learn-2/</url>
    
    <content type="html"><![CDATA[<p>不同的ISP pipeline设计还是有些区别的，相较第一篇针对一个具体项目进行分析，这篇尽量做稍微全面的总结。</p><p>此文绝赞施工中…应该要等到我有更深入理解时，才能写完。</p><a id="more"></a><h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><ul><li>A/D转换</li><li>黑电平校正（Black Level Correction）</li><li>坏点校正（Bad Pixel Correction）</li><li>阴影校正（Shading Correction）：包括镜片阴影校正和色彩阴影校正（Color Shading Correction）。</li><li>耀斑补偿（Flare Offset）：由于镜片等组件产生的反光，导致图像灰蒙蒙的。Flare Offset要在线性空间下进行，不能在RGB下进行。</li><li>3A：<ul><li>AE（Auto Exposure）：自动曝光</li><li>AF（Auto Focus）：自动对焦</li><li>AWB（Auto White Balance）：自动白平衡</li></ul></li><li>去马赛克/色彩重建（de-mosaic）</li><li>颜色校正（Color Correction）：然后非线性化</li><li>Gamma校正（Gamma Correction）</li><li>色调映射（Tone Mapping）</li><li>降噪（Noise Reduction）</li><li>图像增强（Image Enhancement）：锐化（Sharpening）、边缘增强（Edge Enhancement）之类的</li><li>输出编码</li></ul><p>重点应该还是放在降噪、图像增强以及去马赛克等方面（除了3A之外），因为其他的应该说比较成熟了。</p><h3 id="色调映射"><a href="#色调映射" class="headerlink" title="色调映射"></a>色调映射</h3><blockquote><p>算法千差万别，但是目的是一样的，就是通过公式，把输入值HDR颜色或正常颜色映射到0-1范围内去显示。并且根据曝光系数调整曲线，使大部分颜色看起来更加接近该亮度。</p></blockquote><p>其实这个是和曲线相关的。Gamma校正也是属于色调映射。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p>1.<a href="https://github.com/mushfiqulalam/isp" target="_blank" rel="noopener">https://github.com/mushfiqulalam/isp</a><br>2.<a href="https://zhuanlan.zhihu.com/p/36379267" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/36379267</a><br>3.<a href="https://zhuanlan.zhihu.com/p/98820927" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/98820927</a></p>]]></content>
    
    
    <categories>
      
      <category>图像处理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ISP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>周记 2020.02.03-02.09</title>
    <link href="/2020/02/13/week-202002-1/"/>
    <url>/2020/02/13/week-202002-1/</url>
    
    <content type="html"><![CDATA[<h3 id="1-deque"><a href="#1-deque" class="headerlink" title="1.deque"></a>1.<code>deque</code></h3><p><code>deque</code>的声明</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// std::deque</span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;deque&gt;</span></span><br><span class="hljs-keyword">template</span> &lt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span>, <span class="hljs-title">class</span> <span class="hljs-title">Alloc</span> = <span class="hljs-title">allocator</span>&lt;T&gt; &gt; <span class="hljs-title">class</span> <span class="hljs-title">deque</span>;</span><br><br><span class="hljs-comment">// example</span><br><span class="hljs-built_in">deque</span> &lt;TreeNode*&gt; tree_que;<br>node = tree_que.front();<br></code></pre></td></tr></table></figure><h3 id="2-C-调用函数"><a href="#2-C-调用函数" class="headerlink" title="2.C++调用函数"></a>2.C++调用函数</h3><p>用Python用惯了，才发现在C++中调用函数，这样把形参写进去的写法，是不行的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;opencv2/opencv.hpp&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> cv;<br><br>Canny(edge, edge, <span class="hljs-number">3</span>, <span class="hljs-number">9</span>, <span class="hljs-number">3</span>);  <span class="hljs-comment">// ✔</span><br>Canny(edge, edge, threshold1=<span class="hljs-number">3</span>, threshold2=<span class="hljs-number">9</span>, apertureSize=<span class="hljs-number">3</span>);  <span class="hljs-comment">// ✖</span><br></code></pre></td></tr></table></figure><a id="more"></a><h3 id="3-关于vector"><a href="#3-关于vector" class="headerlink" title="3. 关于vector"></a>3. 关于<code>vector</code></h3><p>不需额外声明头文件，但需要使用<code>std</code>命名空间，即<code>std::vector</code>。</p><p>这天在做二叉树的题和敲OpenCV时，都遇到了<code>vector</code></p><h3 id="4-cpp拆分"><a href="#4-cpp拆分" class="headerlink" title="4.cpp拆分"></a>4.cpp拆分</h3><p>1.<code>static</code>修饰的函数，只能在本文件中调用。</p><p>2.<code>#ifndef</code>、<code>#define</code>、<code>#endif</code>配合使用，避免一个.h文件被重复include。</p><h3 id="5-使用Meson编译"><a href="#5-使用Meson编译" class="headerlink" title="5.使用Meson编译"></a>5.使用Meson编译</h3><p>在win下，通过msi安装包安装Meson，再把现成的<code>ninja.exe</code>添加到环境变量中即可。</p><p>编译时出现的问题如下。</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">Did <span class="hljs-keyword">not</span> find pkg-config <span class="hljs-keyword">by</span> <span class="hljs-type">name</span> <span class="hljs-string">'pkg-config'</span><br><span class="hljs-built_in">Found</span> Pkg-config: <span class="hljs-keyword">NO</span><br>Did <span class="hljs-keyword">not</span> find CMake <span class="hljs-string">'cmake'</span><br><span class="hljs-built_in">Found</span> CMake: <span class="hljs-keyword">NO</span><br>Run-<span class="hljs-type">time</span> dependency vapoursynth <span class="hljs-built_in">found</span>: <span class="hljs-keyword">NO</span><br></code></pre></td></tr></table></figure><p>就是该装的依赖没有装。（虽然我不好说这里的<code>vapoursynth</code>指什么：.h文件，还是编译好的动态链接库？）</p><p>顺带，下面这些信息，好像也不是我希望的。这应该是我的gcc存在32位和64位共存导致。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">C</span>++ <span class="hljs-selector-tag">compiler</span> <span class="hljs-selector-tag">for</span> <span class="hljs-selector-tag">the</span> <span class="hljs-selector-tag">host</span> <span class="hljs-selector-tag">machine</span>: <span class="hljs-selector-tag">c</span>++ (<span class="hljs-selector-tag">gcc</span> 8<span class="hljs-selector-class">.2</span><span class="hljs-selector-class">.0</span> "<span class="hljs-selector-tag">c</span>++ (<span class="hljs-selector-tag">MinGW</span><span class="hljs-selector-class">.org</span> <span class="hljs-selector-tag">GCC-8</span><span class="hljs-selector-class">.2</span><span class="hljs-selector-class">.0-5</span>) 8<span class="hljs-selector-class">.2</span><span class="hljs-selector-class">.0</span>")<br><span class="hljs-selector-tag">C</span>++ <span class="hljs-selector-tag">linker</span> <span class="hljs-selector-tag">for</span> <span class="hljs-selector-tag">the</span> <span class="hljs-selector-tag">host</span> <span class="hljs-selector-tag">machine</span>: <span class="hljs-selector-tag">c</span>++ <span class="hljs-selector-tag">GNU</span> <span class="hljs-selector-tag">ld</span><span class="hljs-selector-class">.bfd</span> 2<span class="hljs-selector-class">.32</span><br><span class="hljs-selector-tag">Host</span> <span class="hljs-selector-tag">machine</span> <span class="hljs-selector-tag">cpu</span> <span class="hljs-selector-tag">family</span>: <span class="hljs-selector-tag">x86</span><br><span class="hljs-selector-tag">Host</span> <span class="hljs-selector-tag">machine</span> <span class="hljs-selector-tag">cpu</span>: <span class="hljs-selector-tag">x86</span><br></code></pre></td></tr></table></figure><h3 id="6-VapourSynth着手支持音频处理"><a href="#6-VapourSynth着手支持音频处理" class="headerlink" title="6.VapourSynth着手支持音频处理"></a>6.VapourSynth着手支持音频处理</h3><p>才发现上个月底，VapourSynth官网发布了一个预告性质的说明，要支持音频处理了。不过还没有发布。</p><p>先不谈音频问题，一个需要关注的问题是api的更改，clip类型变成了<code>vnode</code>。但似乎，好像对编写plugin没有影响？因为写plugin用的是C++ api的<code>VSNodeRef</code>，而不是现在<code>cython/vapoursynth.pyx</code>里Python api的<code>VideoNode</code>。但我继续看这个说明，提到了<code>VSMap</code>和其他context，这个C++ api里也有。</p><p>音频源滤镜：<code>BestAudioSource .dll</code></p><p>函数：<code>bas.Source</code>、<code>bas.BlankAudio 、</code>bas.AudioSplice <code>、</code>bas.AudioTrim`</p><p>在脚本最后，输出音频要用<code>audio.set_output(1)</code>，要给<code>set_output</code>加标号了。</p><p>输出结果可喂给VSPipe（VS pipeline，和ISP pipeline一个意思的其实吧）、AVFS、VFW。</p><h3 id="7-可以考虑学一学Cython"><a href="#7-可以考虑学一学Cython" class="headerlink" title="7.可以考虑学一学Cython"></a>7.可以考虑学一学Cython</h3><p>或许有可能写面向进阶用户的东西的时候，会用上？</p><h3 id="8-脑洞"><a href="#8-脑洞" class="headerlink" title="8.脑洞"></a>8.脑洞</h3><p>侦测-&gt;抠像-&gt;用vs代替pr？</p><h3 id="9-指令集优化与编译原理"><a href="#9-指令集优化与编译原理" class="headerlink" title="9.指令集优化与编译原理"></a>9.指令集优化与编译原理</h3><p>既然修改JincResize代码涉及到了指令集优化，就要重新翻开编译原理了。</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>VapourSynth</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ISP笔记（1）：一个ISP项目的流程梳理</title>
    <link href="/2020/02/08/ISP-learn-1/"/>
    <url>/2020/02/08/ISP-learn-1/</url>
    
    <content type="html"><![CDATA[<p>通过学习<a href="https://github.com/mushfiqulalam/isp" target="_blank" rel="noopener">mushfiqulalam/isp</a>项目整理一下ISP的流程。虽然这类博文很多，但不自己写一下总感觉不扎实，而且很多博文没有代码只是概述，更觉得不扎实。</p><h3 id="基本的印象"><a href="#基本的印象" class="headerlink" title="基本的印象"></a>基本的印象</h3><p>镜片阴影校正（Lens shading correction），话说最开始接触这个概念，还是在看介绍Jinc函数的pdf里。</p><p>最后的降噪和锐化，是我很熟悉的。降噪用了sigma filter，代码还没有读，盲猜是Gaussian？锐化用了USM锐化，或许我可以，用一些我熟悉的效果更明显的降噪方法。</p><a id="more"></a><h3 id="流程梳理"><a href="#流程梳理" class="headerlink" title="流程梳理"></a>流程梳理</h3><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs 1c">.raw文件 →<br>  <span class="hljs-number">1</span>. black level correction   <span class="hljs-string">|  黑电平校正（BLC，或称OBC）</span><br>  <span class="hljs-number">2</span>. lens shading correction  <span class="hljs-string">|  镜片阴影校正（LSC）</span><br>  <span class="hljs-number">3</span>. bad pixel correction     <span class="hljs-string">|  坏点校正</span><br>  <span class="hljs-number">4</span>. white balance            <span class="hljs-string">|  白平衡（AWB）</span><br>  <span class="hljs-number">5</span>. bayer denoise            <span class="hljs-string">|  bayer降噪</span><br>  <span class="hljs-number">6</span>. demosaic                 <span class="hljs-string">|  去马赛克</span><br>  <span class="hljs-number">7</span>. local color ratio        <span class="hljs-string">|  锐化方法/去马赛克的一种后处理</span><br>  <span class="hljs-number">8</span>. median filter            <span class="hljs-string">|  中值滤波</span><br>  <span class="hljs-number">9</span>. color correction         <span class="hljs-string">|  颜色校正（有明显的颜色变化，能看到更多颜色/细节）</span><br>  <span class="hljs-number">10</span>.gamma                    <span class="hljs-string">|  gamma校正（照片由暗变明，直观上的“正常”图像）</span><br>  <span class="hljs-number">11</span>.chromatic aberration<br>     correction               <span class="hljs-string">|  色差校正（即去除紫色/绿色条纹）</span><br>  <span class="hljs-number">12</span>.tone mapping             <span class="hljs-string">|  色调映射（图像变亮，类似SDR-&gt;HDR的感觉）</span><br>  <span class="hljs-number">13</span>.memory color enhancement <span class="hljs-string">|  </span><br>  <span class="hljs-number">14</span>.noise reduction          <span class="hljs-string">|  降噪</span><br>  <span class="hljs-number">15</span>.sharpening               <span class="hljs-string">|  锐化</span><br>  <span class="hljs-number">16</span>.distortion correction    <span class="hljs-string">|  失真校正</span><br></code></pre></td></tr></table></figure><p><del>全程在32bit下处理。</del>其实原项目并不是这样，是每个处理单元内部使用32bit处理，而单元间的数据传递似乎还是16bit。在之前的经验中，是不要反复转换位深；但看了下代码，32bit float与16bit int间的转换无非就是<code>np.float32()</code>与<code>np.clip(image, 0, 65536)</code>的转换，好像也没有什么精度损失。</p><h4 id="去马赛克（Demosaicing）"><a href="#去马赛克（Demosaicing）" class="headerlink" title="去马赛克（Demosaicing）"></a>去马赛克（Demosaicing）</h4><p>包含了后处理local color ratio，用以增强锐度，因为插值之后的图像缺少锐度（<a href="http://www.dsp.toronto.edu/~kostas/Publications2008/pub/53.pdf" target="_blank" rel="noopener">文献1：10.1109/TCSVT.2004.828316</a>）。</p><p>我用简单的插值做去马赛克，效果和项目的中差别较大（我做得更亮），倒是和OpenCV自带的<code>xxxxtorgb()</code>效果几乎一致。</p><h4 id="Gamma校正"><a href="#Gamma校正" class="headerlink" title="Gamma校正"></a>Gamma校正</h4><p>分两步进行，亮度调整（Luma adjustment）、量化（Equation）（另外两个<code>by_value()</code>和<code>by_table()</code>函数没有启用）。</p><p>亮度调整部分就是我们熟悉的加个系数、进行Gamma校正的过程，也就是提高亮度（Brightening）。项目给定的系数是<code>log10(80)</code>，即1.903。</p><p>说起来平时做Resize，需要Gamma校正的时候就只做这一步，亮度增强。有没有必要也模仿这样做后续的处理。另外，根据AreaResize的经验，在32bit做Resize不需要做Gamma校正/亮度增强，因为精度已经足够（对哦…在这里本来就是为了提高亮度，不处理是黑的…和处理精度没关系）。</p><h4 id="色调映射（Tone-Mapping）"><a href="#色调映射（Tone-Mapping）" class="headerlink" title="色调映射（Tone Mapping）"></a>色调映射（Tone Mapping）</h4><p>项目包含了两种独立的方法，每个ISP流程只执行一种方法。</p><ul><li>非线性mask（Nonlinear Masking）</li><li>动态范围压缩（Dynamic Range Compression）</li></ul><p>在中文wiki中介绍了Photographic算法（英文wiki中没有对应的内容），从字面和算法含义两个方面，都可以理解成“摄影算法”，这种色调映射方法借助了摄影or照片冲洗的技巧。但我直观地看上去，就是动态范围压缩的路数。</p><h3 id="通用的基础操作"><a href="#通用的基础操作" class="headerlink" title="通用的基础操作"></a>通用的基础操作</h3><h4 id="限制像素值范围"><a href="#限制像素值范围" class="headerlink" title="限制像素值范围"></a>限制像素值范围</h4><p>不能让像素值越界。</p><p>在C++中</p><p>在C++17中引入了<code>std::clamp()</code>函数，用法和下面Python中的<code>np.clip()</code>一样。不用C++17的话就自己定义一个~~</p><p>在Python中</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br>dst = np.clip(dst, range_min, range_max)<br></code></pre></td></tr></table></figure><h4 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h4><p>在VapourSynth内，16bit int 的像素值范围是[0, 65535]，32bit float YUV的像素值范围是[0.0, 1.0]，32bit float RGB [-1.0, 1.0]。而在直接用Python和NumPy处理图像数据时，把输入数据升至<code>float32</code>，只是单纯地数据类型的转变，其范围并没有变啊。别用VapourSynth用多了，习惯于高度封装的环境，结果忘了最基础的数据类型。</p><p>所以才需要量化（逃…</p>]]></content>
    
    
    <categories>
      
      <category>图像处理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>ISP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JincResize 代码重构（2）</title>
    <link href="/2020/02/07/rebuild-JincResize-2/"/>
    <url>/2020/02/07/rebuild-JincResize-2/</url>
    
    <content type="html"><![CDATA[<h3 id="指令集优化"><a href="#指令集优化" class="headerlink" title="指令集优化"></a>指令集优化</h3><h4 id="Generation"><a href="#Generation" class="headerlink" title="Generation"></a>Generation</h4><p>（更多内容可查看<a href="http://enigmahuang.me/2017/09/29/AVX-SIMD/" target="_blank" rel="noopener">使用 AVX 系列指令集进行向量化</a>，也可看一下这篇很欢乐的文章<a href="https://zhuanlan.zhihu.com/p/59868499" target="_blank" rel="noopener">GCC神坑：-march=native</a>）</p><p>对于GCC编译器，在编译命令中加入<code>-march=native</code>选项，可调用本地的库，使用AVX指令集优化。</p><h4 id="Functions"><a href="#Functions" class="headerlink" title="Functions"></a>Functions</h4><p>（Doc在<a href="https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm_malloc" target="_blank" rel="noopener">这里</a>，直接搜索想查的函数即可）</p><p>（另外也可看一下<a href="http://kawa0810.hateblo.jp/entry/20120304/1330852197" target="_blank" rel="noopener">Intel AVX を使用して SIMD 演算を試してみる - その2 -</a>，但函数参数不如上面的Doc详细）</p><p><code>_mm_malloc(size_t size, size_t align)</code>：对齐的问题</p><p><code>_mm256_load_ps</code>：float类型输入</p><p><code>_mm256_load_pd</code>：double类型输入</p><p><code>__m256d _mm256_mul_pd(__m256d, __m256d)</code>：256位双精度乘法</p><a id="more"></a><h4 id="Type"><a href="#Type" class="headerlink" title="Type"></a>Type</h4><p>（来自<a href="https://www.xlsoft.com/jp/products/intel/compilers/manual/14/cpp/GUID-A9C3B12F-7A9A-4C8D-A6CD-9974ABC570E9.htm" target="_blank" rel="noopener">インテル® アドバンスト・ベクトル・エクステンション (インテル® AVX) 組込み関数の詳細</a>）</p><p><code>__m256</code>：容纳8个32位单精度浮点数值</p><p><code>__m256d</code>：容纳4个64位双精度浮点数值</p><h4 id="实际代码"><a href="#实际代码" class="headerlink" title="实际代码"></a>实际代码</h4><p>这部分代码来自luglio，我只是做了一点适配，因为我现在还没有把JincResize的中间数据从double改为float。</p><h5 id="对齐的问题"><a href="#对齐的问题" class="headerlink" title="对齐的问题"></a>对齐的问题</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">double</span>* lut = (<span class="hljs-keyword">double</span> *)_mm_malloc(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">double</span>) * d-&gt;sample, <span class="hljs-number">64</span>);<br></code></pre></td></tr></table></figure><p><code>_mm_malloc</code>相比一般的<code>malloc</code>，增加了一个用于数据对齐的参数。具体在这里（<a href="https://software.intel.com/zh-cn/articles/data-alignment-to-assist-vectorization" target="_blank" rel="noopener">数据对齐有助于实现向量化</a>）有讲。</p><p>虽然我现在还不能完全理解这个概念，但经过测试，对于JincResize现有的代码，把上面的<code>64</code>写成<code>32</code>，和没有AVX优化的速度几乎一样。</p><h5 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">__mm256_store_ps(lut + j * <span class="hljs-number">8</span>, rl);  <span class="hljs-comment">// float</span><br>__mm256_store_pd(lut + j * <span class="hljs-number">4</span>, rl);  <span class="hljs-comment">// double</span><br></code></pre></td></tr></table></figure><p>看一下两个函数的声明</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">void</span> _mm256_store_ps (<span class="hljs-keyword">float</span> * mem_addr, __m256 a)<br><span class="hljs-keyword">void</span> _mm256_store_pd (<span class="hljs-keyword">double</span> * mem_addr, __m256d a)<br></code></pre></td></tr></table></figure><p>注意到第二个参数类型分别是<code>__m256</code>、<code>__m256d</code>，所以有了上述区别。</p><h3 id="代码细节的整理"><a href="#代码细节的整理" class="headerlink" title="代码细节的整理"></a>代码细节的整理</h3><p>（2020.3.2完成 2020.3.8补记）</p><h4 id="删去冗余代码"><a href="#删去冗余代码" class="headerlink" title="删去冗余代码"></a>删去冗余代码</h4><p>之前没注意，可以直接获取特定平面尺寸的啊（commit <a href="https://github.com/Kiyamou/VapourSynth-JincResize/commit/83eb7fb83a887d1237607621926c40d68aff7830" target="_blank" rel="noopener">83eb7f</a>）。</p><h4 id="把乘方换成乘法"><a href="#把乘方换成乘法" class="headerlink" title="把乘方换成乘法"></a>把乘方换成乘法</h4><p>嗯，就是求平方嘛，直接乘多好，用<code>pow()</code>更慢。</p><p>说起来虽然是这么一个小改动，但速度提升真是明显（从r5到r6的25%速度提升，AVX优化贡献的可能还不如这里多）。毕竟是在计算量最大的四重循环内，微小的改动就能有大的影响。</p><p>经过从r5到r6的修改，以及对卷积的认识，算是把JincResize代码重新认识了一遍，哪里是速度敏感的，怎么样让代码简洁一点，也有了体会。</p>]]></content>
    
    
    <categories>
      
      <category>Code</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ArchLinux和Meson构建工具的使用</title>
    <link href="/2020/02/07/arch-and-meson/"/>
    <url>/2020/02/07/arch-and-meson/</url>
    
    <content type="html"><![CDATA[<h3 id="爱恨交加的CentOS"><a href="#爱恨交加的CentOS" class="headerlink" title="爱恨交加的CentOS"></a>爱恨交加的CentOS</h3><p>我最开始接触的Linux系统是CentOS，因为有sob的讲解，很快上手。CentOS简洁明亮的界面给我留下了很深的好感，也不需要时不时就敲个sudo。从分子动力学和量子化学，到用LaTex写论文，再到学习Caffe，2019年上半年的经历甚至都能用CentOS穿出一条线。</p><p>但这次编译VapourSynth着实让我感觉蛋疼。</p><a id="more"></a><h4 id="编译VapourSynth"><a href="#编译VapourSynth" class="headerlink" title="编译VapourSynth"></a>编译VapourSynth</h4><p>用了这么长时间的Linux，基本的编译套路也该熟悉了。一般开发者都会提供<code>autogen.sh</code>或者<code>configure</code>文件，运行一下。然后<code>make</code>和<code>make install</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> vapoursynth<br>./autogen.sh<br>./configure<br>make<br>make install<br></code></pre></td></tr></table></figure><p>在<code>make</code>这一步，编译到<code>exprfilter.cpp</code>这个文件时，出现了一堆报错。我看了一下，<code>exprfilter.cpp</code>应该是针对32bit系统定义了一些常量，报的错是说这些常量没有被声明。</p><p>这不是当然的吗？！难道编译器选择性地忽视了<code>#ifndfe CPU_32</code>和<code>#endif</code>…好像还真是，我把被<code>#ifndfe CPU_32</code>和<code>#endif</code>框起来的语句都删除后，就不报错了…</p><p>感觉我的编译器是个智障…</p><p>然而，继续编译，一个文件名带有<code>avx2</code>字样的cpp文件，编译器干脆连注释都不认识…</p><p>搜索了一下，发现有人把GCC编译器从4.8升级到了5.3，就解决了类似不认识<code>#ifndfe</code>的问题。而且升级编译器，也能更好地支持C++的新标准。</p><p>我盘算了一下，比起升级编译器，我干脆换个系统吧…之前有人说CentOS的依赖包陈旧，我在装caffe时就感觉到了（有些包需要手动编译新版本，而不能用yum直接装），而这次编译器出问题…emmm我还是尝试一下别的系统吧。</p><h3 id="ArchLinux的安装使用"><a href="#ArchLinux的安装使用" class="headerlink" title="ArchLinux的安装使用"></a>ArchLinux的安装使用</h3><p>这个也没啥好说的，虽然ArchLinux在Linux系统下也算是入门门槛较高的了，但教程很详尽，照着做就好。</p><p>安装依赖使用<code>pacman -S package</code>，但是不能指定版本，只提供最新版。</p><p>说起来，我的转变也是很大的：之前用最小安装的CentOS，只是好玩；现在用没有桌面的ArchLinux，也能完成实际工作了。</p><p>因为没有装桌面，只说一下<code>pacman</code>给我的感受。感觉很方便，既不需要想Ubuntu那样没事敲sudo，又不需要担心CentOS提供的包没有更新，也不需要担心CentOS下的包有不一样的名字。</p><p>顺便学了/复习了Linux下的常用命令。</p><h3 id="Meson与pkg-config的使用"><a href="#Meson与pkg-config的使用" class="headerlink" title="Meson与pkg-config的使用"></a>Meson与pkg-config的使用</h3><h4 id="Meson"><a href="#Meson" class="headerlink" title="Meson"></a>Meson</h4><p>Meson和ninja在ArchLinux下一键安装，基础的cmake、VapourSynth需要的pkg-config，都是一样。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">pacman -S cmake<br>pacman -S meson<br>pacman -S pkg-config<br></code></pre></td></tr></table></figure><p>只是VapourSynth需要版本限定的zimg v2.9，而<code>pacman</code>又只提供最新版。但我试了一下，目前最新版的zimg v2.9.2和VapourSynth R49（这个时候R49还没有发布，但我之后编译好，发现版本号已经改成R49了），至少在编译阶段没有冲突。</p><p>目前Meson没什么好说的，因为我现在的项目，还是结构很简单的项目，而且Meson的语法简单明了。只是Meson的教程藏得有点深，推荐去Github上看，<a href="https://github.com/mesonbuild/meson/blob/master/docs/markdown/Reference-manual.md" target="_blank" rel="noopener">https://github.com/mesonbuild/meson/blob/master/docs/markdown/Reference-manual.md</a> 。</p><h4 id="pkg-config"><a href="#pkg-config" class="headerlink" title="pkg-config"></a>pkg-config</h4><p>关于pkg-config，我搜了一下，应该和Meson一样，也是一款跨平台的工具…但我觉得，还是只在Linux下用吧…</p><p>使用pkg-config的项目要写一个.pc后缀的配置文件，具体到VapourSynth，就是说明了头文件的位置。这个.pc文件会在项目中提供，要自己放到<code>usr/lib/pkgconf</code>下面，然后使用pkg-config时就会到这里搜索。</p><p>在我看来，这样避免了每新面对一个项目就重新配环境。</p><p>.pc文件也容易读懂，就是通常的配置文件的内容。</p><h3 id="在Linux下编译VapourSynth-Plugin"><a href="#在Linux下编译VapourSynth-Plugin" class="headerlink" title="在Linux下编译VapourSynth Plugin"></a>在Linux下编译VapourSynth Plugin</h3><p>上面的准备工作都完成后，两行命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">meson build<br>ninja -C build<br></code></pre></td></tr></table></figure><p>即可完成编译，得到期待已久的<code>libxxx.so</code>文件。</p><p>今天顺利用上ArchLinux，并确认编译出错源自GCC编译器的陈旧。</p><p>成功编译VapourSynth。</p><p>成功借助Meson在Linux下编译VapourSynth Plugin。</p><p>虽然现在看来不算难事，但在不久的之前，还是困扰我的问题。所以，我的进步是看得见的。</p><p>这种扎实的喜悦是一方面。而另一方面，在编译中看着跳动的命令行，感受到计算机内部是怎样运行，而且也不再把红色的Error看得不可解决，这也是感性的成长。</p>]]></content>
    
    
    <categories>
      
      <category>工具使用</category>
      
    </categories>
    
    
    <tags>
      
      <tag>构建与编译</tag>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>记一次从AviSynth到VapourSynth的迁移（3）：找不到的Bug与代码优化</title>
    <link href="/2020/02/06/ported-to-vs-3/"/>
    <url>/2020/02/06/ported-to-vs-3/</url>
    
    <content type="html"><![CDATA[<h3 id="回忆重连"><a href="#回忆重连" class="headerlink" title="回忆重连"></a>回忆重连</h3><p>离写这个系列的<a href="https://kiyamou.github.io/2020/01/01/ported-to-vs-2/" target="_blank" rel="noopener">上一篇Blog</a>已经一个月有余，离发布VapourSynth版AreaResize也三个星期了。一直没有继续写Blog，有些东西都要忘了。这个时候发现commit表情还是挺有用的。</p><p>从功能上讲，上一篇Blog写到（基于原始avs版）修正了颜色问题，也在一定程度上支持高位深输入；但目标尺寸仍必须是“常规”的尺寸，比如960x540这样的，在一些稍“不常规”的尺寸上（如1280x900），8bit会分屏，32bit会奔溃。</p><p>总之问题集中在尺寸上，尝试好久，包括调换垂直方向与水平方向的处理顺序，以及其他一些细节的尝试，都没有帮助。当时为了找这个bug，盯着屏幕盯了好像有两三天，也没有结果。</p><p>最后没办法， 因为AreaResize除了原始的avs版，还有一个优化过的avs版。优化版作者的本意的加快处理速度，但我把代码迁移到vs后，发现上面的Bug居然解决了——虽然我真的看不出，两份代码除了速度优化外，其他方面的区别。</p><a id="more"></a><h3 id="神奇的优化"><a href="#神奇的优化" class="headerlink" title="神奇的优化"></a>神奇的优化</h3><p>如前面所说，我并没有发现原始avs版代码和优化avs版代码有除了速度优化之外的区别，但真的迁移了优化版代码后，上面的Bug就解决了。</p><p>具体的分析，等我看明白了再写吧。代码改到这里，排查了手滑写错了一个循环，除了700x700这样奇怪格式外，对于YUV格式，在高位深、一般目标尺寸输入上都没有问题了。下面就是支持RGB的问题。</p><p>在1月2号晚上和1月3号一天，都在解决支持RGB的问题，其实也就是在学相关的概念和数据结构。如同我在某个commit下面的评论中所写：“让我开始阅读VapourSynth的源码和官方plugins示例（就是vscore.cpp中的那些函数）。让我对vs api与框架有了近乎全面的认识，至少知道从头到尾是怎么计算的。”其中，数据结构的相关内容写在了<a href="https://kiyamou.github.io/2019/12/18/image-process-code-1/" target="_blank" rel="noopener">这篇Blog中</a>。</p><h3 id="支持RGB"><a href="#支持RGB" class="headerlink" title="支持RGB"></a>支持RGB</h3><p>写一写支持RGB的代码实现。</p><p>对于YUV格式，写一个循环，依次处理三个平面/通道即可。但我这么套在RGB上，不行，崩溃（但其实奔溃还有数据类型的问题，一开始的代码有整型处理，遇到浮点数就崩了）。让后又试着按stack格式写了代码，不循环，一个像素点依次处理三个通道，再移动到下一个像素点。像下面这样</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++">ps = <span class="hljs-number">3</span>;  <span class="hljs-comment">// plane_size，用于下面乘3，三个通道一起处理</span><br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ResizeVerticalRGB</span><span class="hljs-params">()</span> <span class="hljs-keyword">noexcept</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> curPixel = <span class="hljs-number">0</span>; curPixel &lt; target_width * ps; curPixel++)<br>    &#123;<br>        <span class="hljs-keyword">const</span> T* curSrcpR = srcR + curPixel * ps;<br>        <span class="hljs-keyword">const</span> T* curSrcpG = srcG + curPixel * ps + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">const</span> T* curSrcpB = srcB + curPixel * ps + <span class="hljs-number">2</span>;<br>        T* curDstpR = srcR + curPixel * ps;<br>        T* curDstpG = srcG + curPixel * ps + <span class="hljs-number">1</span>;<br>        T* curDstpB = srcB + curPixel * ps + <span class="hljs-number">2</span>;<br>        <br>        ...<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>话说这改后，好像也是崩溃（或者是在关闭预览窗口后奔溃），所以放弃了，老老实实地（在<code>process()</code>函数中）先转换为Interleaved结构，在送到具体的<code>Ver()</code>中处理。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">if</span> (d-&gt;vi-&gt;format-&gt;colorFamily == cmYUV)<br>&#123;<br>    ...<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>    <span class="hljs-keyword">const</span> T* srcpR = <span class="hljs-keyword">reinterpret_cast</span>&lt;<span class="hljs-keyword">const</span> T*&gt;(vsapi-&gt;getReadPtr(src, <span class="hljs-number">0</span>));<br>    <span class="hljs-keyword">const</span> T* srcpG = <span class="hljs-keyword">reinterpret_cast</span>&lt;<span class="hljs-keyword">const</span> T*&gt;(vsapi-&gt;getReadPtr(src, <span class="hljs-number">1</span>));<br>    <span class="hljs-keyword">const</span> T* srcpB = <span class="hljs-keyword">reinterpret_cast</span>&lt;<span class="hljs-keyword">const</span> T*&gt;(vsapi-&gt;getReadPtr(src, <span class="hljs-number">2</span>));<br>    <br>    <span class="hljs-keyword">int</span> src_stride = vsapi-&gt;getStride(src, <span class="hljs-number">0</span>) / <span class="hljs-keyword">sizeof</span>(T);<br>    <span class="hljs-keyword">int</span> dst_stride = vsapi-&gt;getStirde(dst, <span class="hljs-number">0</span>) / <span class="hljs-keyword">sizeof</span>(T);<br>    <br>    T* srcInterleaved = <span class="hljs-keyword">new</span> (<span class="hljs-built_in">std</span>::nothrow) T[d-&gt;vi-&gt;width * d-&gt;vi-&gt;height * <span class="hljs-number">3</span>];<br>    T* dstInterleaved = <span class="hljs-keyword">new</span> (<span class="hljs-built_in">std</span>::nothrow) T[d-&gt;target    * d-&gt;target     * <span class="hljs-number">3</span>];<br>    <br>    <span class="hljs-comment">// 将待处理的数据转换为Interleaved结构</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> y = <span class="hljs-number">0</span>; y &lt; src_height; y++)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> x = <span class="hljs-number">0</span>; x &lt; src_width; x++)<br>        &#123;<br>            <span class="hljs-keyword">const</span> <span class="hljs-keyword">unsigned</span> pos = (x + y * src_width) * <span class="hljs-number">3</span>; <span class="hljs-comment">// 这里要乘3，因为是转成Interleaved</span><br>            <span class="hljs-comment">// 这里的RGB顺序其实无所谓，只要自洽即可，但为了显得专业，按BGR的顺序</span><br>            srcInterleaved[pos] = srcpB[x];<br>            srcInterleaved[pos + <span class="hljs-number">1</span>] = srcpG[x];<br>            srcInterleaved[pos + <span class="hljs-number">2</span>] = srcpR[x];<br>        &#125;<br>        srcpB += src_stride; <span class="hljs-comment">// src_stride ≈ src_width，完成整个帧的遍历</span><br>        srcpG += src_stride;<br>        srcpR += src_stride;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 核心处理</span><br>    Func(dst, src, (<span class="hljs-keyword">const</span> T*)srcInterleaved, dstInterleaved, src_stride, dst_stride, d, vsapi);<br>    <br>    T* VS_RESTRICT dstpR = <span class="hljs-keyword">reinterpret_cast</span>&lt;T*&gt;(vsapi-&gt;getWritePtr(dst, <span class="hljs-number">0</span>));<br>    T* VS_RESTRICT dstpG = <span class="hljs-keyword">reinterpret_cast</span>&lt;T*&gt;(vsapi-&gt;getWritePtr(dst, <span class="hljs-number">1</span>));<br>    T* VS_RESTRICT dstpB = <span class="hljs-keyword">reinterpret_cast</span>&lt;T*&gt;(vsapi-&gt;getWritePtr(dst, <span class="hljs-number">2</span>));<br>    <br>    <span class="hljs-comment">// 将处理后的数据转换为Planar结构</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> y = <span class="hljs-number">0</span>; y &lt; target_height; y++)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> x = <span class="hljs-number">0</span>; x &lt; target_width; x++)<br>        &#123;<br>            <span class="hljs-keyword">const</span> <span class="hljs-keyword">unsigned</span> pos = (x + y * target_width) * <span class="hljs-number">3</span>;<br>            dstpB[x] = dstInterleaved[pos];<br>            dstpG[x] = dstInterleaved[pos + <span class="hljs-number">1</span>];<br>            dstpR[x] = dstInterleaved[pos + <span class="hljs-number">2</span>];<br>        &#125;<br>        dstpB += dst_stride;<br>        dstpG += dst_stride;<br>        dstpR += dst_stride;<br>    &#125;  <span class="hljs-comment">// 此时，dst已经是Planar结构</span><br>    <br>    <span class="hljs-keyword">delete</span>[] srcInterleaved;<br>    <span class="hljs-keyword">delete</span>[] dstInterleaved;<br>&#125;<br></code></pre></td></tr></table></figure><p>至此，数据结构的问题已经解决，但对于RGB输入仍不能正常处理。</p><p>然后修正了一个蛋疼的Bug：我在写<code>peak</code>的时候，把<code>1 &lt;&lt; bitsPerSample</code>写成了<code>1 &lt;&lt; sampleType</code>，所以一直有问题、崩溃。改正之后，8bit RGB输入终于能看了。而16bit和32bit由于查表的范围问题，还会崩溃。</p><p>然后将<code>gamma_LUT</code>声明为double。到这里，输出结果是图像中的一部分带有蓝点红点绿点（提高<code>gamma_LUT</code>的精度，在单个帧中，会让这些点变少，而正常图像的部分增多）。</p><p>顺带，说一个C++的基础知识，对于<code>auto</code>声明，应该是确定了后就不能改了，而不能在不同变量类型间反复横跳。</p><h3 id="修正查表（LUT）的相关问题"><a href="#修正查表（LUT）的相关问题" class="headerlink" title="修正查表（LUT）的相关问题"></a>修正查表（LUT）的相关问题</h3><p>查表，即Look up table，在代码中一般缩写为LUT。</p><h4 id="论数组与指针的区别"><a href="#论数组与指针的区别" class="headerlink" title="论数组与指针的区别"></a>论数组与指针的区别</h4><p>1月12号解决了上述（8bit）下图像带有红点绿点的问题。解决方法是<strong>把<code>gamma_LUT</code>的声明由数组变成指针</strong>。（开发版commit：<code>a5dc85d</code>）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">double</span> gamma_LUT[RGB_PIXEL_RANGE_EXTENDED];  <span class="hljs-comment">// old</span><br><span class="hljs-keyword">double</span> gamma_LUT = <span class="hljs-keyword">new</span> (<span class="hljs-built_in">std</span>::nothrow) duoble[RGB_PIXEL_RANGE_EXTENDED];  <span class="hljs-comment">// new</span><br></code></pre></td></tr></table></figure><p>至于为什么从数组变到指针就没有问题了，这个…我猜是数组一些地方溢出了？但我尝试过加<code>[0, 255]</code>限制，也不能彻底解决啊。</p><h4 id="增加16bit支持"><a href="#增加16bit支持" class="headerlink" title="增加16bit支持"></a>增加16bit支持</h4><p>这个更偏向于体力活，没有太多要写的。只是需要明白一个事情，在8bit处理中用到的宏常量<code>RGB_PIXEL_RANGE_EXTENDED</code>，是为了让8bit的计算不那么僵硬，增加中间数据的过渡，就和我们要把8bit的图像素材扩展到10bit或16bit处理是一个道理。这里定义的宏常量值为<code>25501</code>，相当于把8bit的计算范围扩大了100倍。</p><p>事实上，<code>log2(25501)</code>介于14与15之间。所以对于喂给AreaResize的RGB输入，只有16bit（和一般不会有人用的15bit）能实现比8bit更“精细”的处理。（但话说回来，就算8bit的中间数据再精细，终归还要化为8bit，所以10bit的优势还是在的？）</p><h4 id="增加32bit支持与gamma参数"><a href="#增加32bit支持与gamma参数" class="headerlink" title="增加32bit支持与gamma参数"></a>增加32bit支持与<code>gamma</code>参数</h4><p>1月13号做的事情包括增加16bit与32bit支持，增加<code>gamma</code>参数。</p><p>先思考一下为要查表。就AreaResize而言，由于对RGB格式增加了Gamma校正（但我不太明白原作者为什么不给YUV格式增加Gamma校正？是一般的滤镜都不做的惯例吗？），计算量增大，不如把Gamma校正后的颜色值用查表的形式给出。</p><p>但是，对32bit浮点数数据，由于数据过于精细，计算表格本身的计算量过大，已经不适合再查表了。而且查表的初衷是为了做Gamma校正，而无论是我查的一些资料，还是我的实际测试，在32bit下，由于精度足够高，做不做Gamma校正都没什么区别。</p><p>所以在32bit的处理上，没有加Gamma校正，也没有做成查表的形式，直接是用到的时候再计算。</p><p>另外，给8~16bit RGB增加了Gamma校正参数，让使用者能够自行调整Gamma校正的数值。因为Gamma校正具体用什么值，本身似乎就是需要商榷的。</p><p>至此，面上的问题都解决了。然后整理了一下代码，就发布了。</p><h3 id="未来要做的"><a href="#未来要做的" class="headerlink" title="未来要做的"></a>未来要做的</h3><h4 id="bool型的函数"><a href="#bool型的函数" class="headerlink" title="bool型的函数"></a>bool型的函数</h4><p>其实我在迁移的过程中，一直都回避了一个问题。在avs版代码中，核心处理函数<code>Ver()</code>和<code>Hor()</code>都是bool型，在调用过程中会借此给一些特殊情况单独处理，以增强鲁棒性（在最开始，我以为这个判断是防止内存溢出的）。但我为了快点迁移代码，把这个问题暂时忽略了。</p><h4 id="代码优化了什么"><a href="#代码优化了什么" class="headerlink" title="代码优化了什么"></a>代码优化了什么</h4><p>虽然说，优化前后的两版avs代码，都不难读懂，但这种优化的思路，值得我去学习。这是把实际项目和算法题联系起来的桥梁。况且，为什么换成优化后的代码，就没有“挑剔输入尺寸”的Bug，这个问题我还不知道。</p><h3 id="一些优化"><a href="#一些优化" class="headerlink" title="一些优化"></a>一些优化</h3><h4 id="没什么用的指令集优化"><a href="#没什么用的指令集优化" class="headerlink" title="没什么用的指令集优化"></a>没什么用的指令集优化</h4><p>在AreaResize中，接受8bit和16bit RGB输入时，要进行查表操作。联想到JincResize的经验，能否在计算table的时候进行指令集优化，以加快速度。</p><p>于是风风火火写了相关代码。但代码写完，冷静下来才注意到，AreaResize所需的表格很简单。相比JincResize中由两个向量（数组）得到table，AreaResize中计算table仅需一些算数乘除法，好像不需要我再专门优化，因为由于很简单…或许编译器本身就给优化了？</p><p>特意进行了稍长一点的测试，发现8bit下优化之后的代码稍快，而16bit则是优化前的稍快。所以…好像没什么必要吧。</p><h4 id="或许画蛇添足的Parallel"><a href="#或许画蛇添足的Parallel" class="headerlink" title="或许画蛇添足的Parallel"></a>或许画蛇添足的Parallel</h4><p>因为偶然看到《OpenCL 2.0 异构计算》这本书，读到了C++ AMP（已经成为C++11标准的一个扩展），明白了<code>parallel_for</code>的含义，可以简单理解为将for循环并行化。</p><p>由于有不同的实现方式，所以多少让人感到凌乱。这里用了微软的<code>ppl.h</code>（已经整合到了msvc中），至于gcc…先放着吧…Orz</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> defined(_MSC_VER)</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;ppl.h&gt;</span></span><br><br>Concurrency::parallel_for(<span class="hljs-number">0</span>, (<span class="hljs-keyword">int</span>)range, [&amp;](<span class="hljs-keyword">int</span> i)<br><span class="hljs-comment">// for (int i = 0; i &lt; range; i++)</span><br>&#123;<br>    ...<br>&#125;);<br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br></code></pre></td></tr></table></figure><p>测试发现加了上述优化后，速度反而降了…Orz…然后我才注意到，VapourSynth本身已经有<code>fmParallel</code>参数，应该是已经包含了Parallel相关优化？所以我这样做是画蛇添足？</p><p>目前Github上repo的情况，Parallel部分提交到了主分支，而AVX部分则是提交到了新建的dev分支。</p><p>总之，这应该是我走出前人已有算法，做出属于我的微小贡献的第一步吧。</p>]]></content>
    
    
    <categories>
      
      <category>Code</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>VapourSynth</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2020寒假计划与回顾</title>
    <link href="/2020/02/04/2020-winter-holiday/"/>
    <url>/2020/02/04/2020-winter-holiday/</url>
    
    <content type="html"><![CDATA[<p>目前要做的东西真是太多了，而我还在顾着发朋友圈，没有完全进入状态。这个假期要做的事情，能想到的有这么多：</p><ul><li>BM3D算法介绍的后续工作</li><li>基于BM3D算法的去模糊和神经网络（选一个，就前者？）</li><li>JincResize的代码维护<ul><li><del>增加dering</del></li><li>结构整理（✔）</li><li>修改算法介绍的博文</li><li>（指令集优化）（✔）</li></ul></li><li>剑指Offer和LeetCode刷题（进度：20%）</li><li><del>准备三级考试（这个可以缓一下，但别忘了报名啊）</del>；不考了，才发现5月根本没有三级考试，安慰一下自己，考了恐怕也不能为简历增色</li><li>OpenCV，争取把书上的我没在VS下接触过的东西，敲一遍代码（进度：40~50%）</li><li>数据结构和算法，从学校背回来的这两本书总归要看一下（进度：5%）</li><li>关于C++基础（和一些编程的思维），把最近一段时间在知乎的收藏和截屏整理一下</li><li>直方图相关的内容，HDR、色彩增强等我不熟悉的，要趁着假期看一下（进度：20%）</li><li>把这段时间看到ISP内容总结一下（进度：30%）</li><li>AreaResize迁移和Debug过程的总结（✔）</li><li>Waifu2x相关，这个在家真没办法了，先搁置吧</li></ul><a id="more"></a><p>总结一下1月份假期回家这十天的工作</p><ul><li>初步整理了下这段时间看到ISP（及其它我不在VS中常用的）内容，主要包括<ul><li>去马赛克</li><li>去摩尔纹</li></ul></li><li>因为刚回家，刷题刷不进去，两三天之后，转入写blog和Doc<ul><li>Jinc插值的介绍（2~3天）</li><li>BM3D滤镜的说明（4天左右）</li></ul></li><li>刷题，也算是…不再停滞不前了</li><li>OpenCV开始入手我不太熟悉的部分，hough变换</li></ul><p>因为写文花的时间最多，感受也最深。</p><p>写Jinc插值的时候，发现了ImageMagic的Doc，有了很深的启发，也学到了以前不知道的东西。另外，有些自夸地说，中文博文中，似乎很少有专门介绍Jinc的文章，至少我没搜到，所以我也算是一个拓荒者吧。虽然Jinc插值已经..至少从开发者的角度，已经陈旧了。</p><p>写BM3D的时候，我发现我从本科开始，就有的一个问题，就是不知深入，看论文浅尝辄止。</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>周记 2020.01.27-02.02</title>
    <link href="/2020/02/04/week-202001-4/"/>
    <url>/2020/02/04/week-202001-4/</url>
    
    <content type="html"><![CDATA[<h3 id="1-LINK-2019错误"><a href="#1-LINK-2019错误" class="headerlink" title="1.LINK 2019错误"></a>1.<code>LINK 2019</code>错误</h3><p><code>LINK 2019</code>错误，目前遇到的错误原因：</p><ul><li><p>没有写<code>main()</code>函数<br>但我记得之前写dll的时候，根本不需要写<code>main()</code>，也出现了类似的错误，然后我从VS2019换到了GCC，就不报错了…</p></li><li><p>头文件和库文件设置错误，64位和32位搞混</p></li></ul><a id="more"></a><ul><li><p>面向对象时，少写了public函数的定义<br>向下面这样，少写了<code>func1()</code>函数的定义，就有报错。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">className</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>    className();<br>    <span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">func1</span><span class="hljs-params">(<span class="hljs-keyword">double</span> parameter)</span></span>;<br><span class="hljs-keyword">private</span>:<br>    ...<br>&#125;;<br><br>className::className()<br>&#123;<br>    ...<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    className one;<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; one.func1(<span class="hljs-number">1.0</span>) &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="2-Debug的过程"><a href="#2-Debug的过程" class="headerlink" title="2.Debug的过程"></a>2.<code>Debug</code>的过程</h3><p>Q：Debug时，<code>index</code>值为-858993460</p><p>A：没赋值就输出，这是未赋值时的随机值。“C语言中，变量要先赋值，才能引用，否则是任意值。”</p><p>Q：但我的问题是，<code>start</code>变量明明直接赋值为0，但在Debug过程却显示为-1。</p><h3 id="3-图像处理的warning"><a href="#3-图像处理的warning" class="headerlink" title="3.图像处理的warning"></a>3.图像处理的warning</h3><p> 某张png图片</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">libpng warning: iCCP: cHRM chunk <span class="hljs-keyword">does</span> <span class="hljs-keyword">not</span> match sRGB<br></code></pre></td></tr></table></figure><p>另一张png图片报了两个warning，多了一个这个</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs groovy">libpng <span class="hljs-string">warning:</span> <span class="hljs-string">iCPP:</span> known incorrect sRGB profile<br></code></pre></td></tr></table></figure><h3 id="4-declspec-dllexport"><a href="#4-declspec-dllexport" class="headerlink" title="4.__declspec(dllexport)"></a>4.<code>__declspec(dllexport)</code></h3><p>关于<code>__declspec(dllexport)</code></p><p>一般的理解如下：</p><blockquote><p><code>__declspec(dllimport)</code>和<code>__declspec(dllexport)</code>是一对的，在动态链接库中<code>__declspec(dllexport)</code>管导出，<code>__declspec(dllimport)</code>管导出，有出口也有进口</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>To 2020</title>
    <link href="/2020/02/03/To-2020/"/>
    <url>/2020/02/03/To-2020/</url>
    
    <content type="html"><![CDATA[<p>听着香菜唱的《有点甜》，心情瞬间平静了。</p><p>也许这段时间忙着发朋友圈，有点…浮躁？也许这段时间思考了太多的人生，虽然是好事情，但务虚太多也会变得消极。</p><a id="more"></a><p>从人生规划上说，我应该明白，选择了就意味着失去其他一些东西。我不能为此平添烦恼，至少要把烦恼放下，留到以后去解决。从现在的我来看，毕业后去北漂或者其他地方漂，基本已是决定。本科毕业的那个暑假，去北京听sob的量子化学，那几天的经历给了我一种印象，去北漂真的很苦。</p><p>虽然在那之前与之后，都去过不止一次北京。但因为是去玩，所以很轻松很开心。大四，本来约好和Shanny吃饭，但她身体不舒服，我说走就走一般地去了国家图书馆。其他去北京的经历，也都很开心。而那次，每天骑着二三十分钟共享单车，穿过车水马龙的街道，印象有点过于深刻了。</p><p>还是那句话，因为不是去玩，行程就胧上了一层灰色。大二，我自己一个半夜走在唐山北站外昏暗的小路上，不觉得害怕，反而觉得很有趣。而那次的北京之行，找酒店找到了漆黑的角落，就不开心，甚至有些害怕。</p><p>这么想起来，研一时元旦两天去深圳，一边玩一边准（应）备（付）英语考试。之后又是在学校与北京间反复横跳，一边考试一边听sob的分子动力学。我的心理素质真是提高了。听完分子动力学，正好是Fate HF第一章上映的日子，又开心地和G、H去看了电影。哦，对了，相比之下，暑假那次北京之行，返程时把车误了…</p><p>顺带，两次去北京听sob讲课，住酒店的花销好像差不多，但无论是位置还是环境，第二次都好很多。所以有些事情，是要动动脑子提前准备的啊。</p><p>写了这么多，我应该明白，没有必要提前害怕，放松心态，能活得很开心。</p><p>前几天在知乎，无意间搜索到了一位曾经在数学吧活跃的吧友。若是说起当时在数学吧的回忆，应该伴随着这么几条主线。</p><p>第一条就是我莫名其妙地觉得我自己虚度了时间，乃至时光走到了尽头。初中初入吧时感叹，高中学数竞时感叹，甚至到了大学，偶尔回忆起的时候，还在感叹。我在感叹虚度时间的时候虚度了时间。</p><p>第二条是朋友or前辈？有时候我过于谦卑，虚心向他人学习当然是好的。但我学到一定程度的时候，就该有勇气，和大家一起站在队伍的前面。</p><p>若再加一条，当年从L那里看到了《数学之美》。我很好奇，明明L已经学到了那般程度，为何还要看这样一本科普级的入门书；但我也没有去探究。直到一两个月前，我终于买了这本书，才知道这是一本披着数学的标题，实则介绍机器学习的书。那可是我高中时候的事情啊，那个时候还没有阿尔法狗。</p><p>说起来，我在15年还是16年时，看到了百度的自然语言处理项目拿到了国家科学技术奖。当时也只是好奇，没有去深究。嗯，从看不见、到看不起、最后看不懂。人就是这么与时代脱节的。</p><p>对吧，历史进程、个人努力。八个字，两组词，相辅相成，缺一不可。这应该能回答，我为什么要转行，能回答我为什么大学前两年认真投入地学习，却有些鸡毛。</p><p>也没必要说得这么沉重而决绝，人总是在变化中成长与进步的。未来，我肯定还要奔向下一站。不然现在的我，就有可能重蹈过去的覆辙。但我希望我自己记住，要身心合一，不要分离地做一件事，望着另一件事。</p><p>嗯，总之的话，有很多事情要我忙，北漂或者X漂，只是一个过程，而不是目的，不要被从属的事情影响了主体。</p><p>写到这里，该结尾了。想想我的头像，大概感觉就是如此吧。</p>]]></content>
    
    
    <categories>
      
      <category>日记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>PyTorch流水账与基于Torch的Waifu2x代码分析</title>
    <link href="/2020/01/19/pytorch-model-waifu2x/"/>
    <url>/2020/01/19/pytorch-model-waifu2x/</url>
    
    <content type="html"><![CDATA[<h3 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h3><p>1.<code>nn.PixelShuffle</code>这个函数从名字上看，和<code>ShufflePlanes</code>好像。（<a href="https://github.com/XuecaiHu/Meta-SR-Pytorch/blob/master/model/common.py）" target="_blank" rel="noopener">https://github.com/XuecaiHu/Meta-SR-Pytorch/blob/master/model/common.py）</a></p><p>2.字面上，bias是偏差的意思。</p><blockquote><p>bias(<code>tensor</code>) - 卷积的偏置系数，大小是（<code>out_channel</code>）</p></blockquote><p>3.现在的libtorch模型读入文件已经解决，而Torch模型的Json与t7的关系虽尚未明白，但具体内容人类可读，已经看了大概。</p><p>现在的任务是明白网络内容，网络结构保存了什么信息。</p><h3 id="模型保存的内容"><a href="#模型保存的内容" class="headerlink" title="模型保存的内容"></a>模型保存的内容</h3><ul><li>网络的结构和模型参数</li><li>只保存网络的模型参数</li></ul><p>在waifu2x的<code>appendix/arch/cunet.txt</code>中是网络结构的描述。虽然我还不知道这仅仅是个文档性能的描述，还是确是导入了代码中…看上去只是一个描述（我不觉得会专门写一段代码，去匹配这样的文字``-&gt;`）。</p><a id="more"></a><h3 id="扫盲"><a href="#扫盲" class="headerlink" title="扫盲"></a>扫盲</h3><p>4.Waifu2x中vgg_7 -&gt; cunet?</p><p>5.话说waifu-caffe中的cNet是代表什么啊，莫不就是cunet？</p><p>6.一个灵魂发问，这些代码，抛开实用化的接口，不就是在搭网络吗？</p><p>所以我现在学这些代码，除了我耽误之急要用的模型和前向传播相关，余下的核心，不就是怎么搭网络吗。</p><p>7.Torch的函数</p><ul><li><code>SpatialZeroPadding()</code></li></ul><h3 id="waifu2x-项目结构分析"><a href="#waifu2x-项目结构分析" class="headerlink" title="waifu2x 项目结构分析"></a>waifu2x 项目结构分析</h3><ul><li><p>appendix (附录 -&gt; 所以<code>cunet.txt</code>果然只是说明文件)</p><ul><li><p>arch: descripte network for torch (only has two files for cunet)</p></li><li><p>caffe_prototxt: prototxt is for caffee, and has a .py file for making cunet.</p><blockquote><p>Generate prototxt of waifu2x’s cunet/upcunet arch. Training is not possible.</p></blockquote></li><li><p>其余是markdown说明和.sh文件</p></li></ul></li><li><p>assets</p><p>看名字是和网站相关的，里面的文件也是html、css、js三剑客，不用管</p></li><li><p>cache</p><p>顾名思义，里面也没有内容</p></li><li><p>data</p><p>同样没有内容，不知道这是什么套路</p></li><li><p>image_generators</p><ul><li>dots (字面上是点)</li></ul><p>Only has a gen.lua file, which has this code. So it’s for generating images. However, I can’t understand the meanings of dots.</p><p>But ever, this is for cmd…So…I can ignore it now?</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Lua">cmd:text(<span class="hljs-string">"dot image generator"</span>)<br>image.save(<span class="hljs-built_in">path</span>.join(opt.o, i .. <span class="hljs-string">".png"</span>), img)<br></code></pre></td></tr></table></figure></li><li><p>images</p><p>Using for description, although some images aren’t used in readme, yet they all seems to used to show the networks. </p><ul><li><p>layer_outputs folder</p></li><li><p>Other images and .sh file</p></li></ul></li><li><p>lib</p><p>Seem to build the newtwork, such as <code>srcnn.lua</code>, which is decripted the SRCNN?</p><p>看了一下w2nn.Lua，感觉Lua这门语言，有点…简单得过分了，调用其他文件，用类似这样的写法，还是在代码的结尾</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-built_in">require</span> <span class="hljs-string">'Print'</span><br></code></pre></td></tr></table></figure></li><li><p>models</p><p>models</p></li><li><p>tools</p><p>在这里看到了<code>export_model.Lua</code>，这应该能解答我对模型内容的疑惑。</p><p>emmm，<code>export_model.Lua</code>开篇第一句就是</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Lua"><span class="hljs-comment">-- adapted from https://github.com/marcan/cl-waifu2x</span><br></code></pre></td></tr></table></figure><p>这是什么意思，cl-waifu2x明明是建立在waifu2x基础上的OpenCL支持项目。（其实..在Lua里这是注释的意思）</p><p>在代码结尾有好看的东西</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Lua">cmd:option(<span class="hljs-string">"-i"</span>, <span class="hljs-string">"input.t7"</span>, <span class="hljs-string">'Specify the input torch model'</span>)<br>cmd:option(<span class="hljs-string">"-o"</span>, <span class="hljs-string">"output.json"</span>, <span class="hljs-string">'Specify the output json file'</span>)<br></code></pre></td></tr></table></figure><p>这话说的是，进去t7，出来json。依此分析，文件名<code>export</code>的含义，并不是把Torch用的模型输出成t7，而是把导出的t7模型转换成json。也就是说，t7和json的内容，是一致的。</p><p>（顺带一提，看这Lua写的命令行构建代码，真是简洁啊。之前看av1的rust命令行构建代码，虽然不能说比C++更复杂，但也挺长的。）</p></li><li><p>webgen</p><p>For web app, can ignore it.</p></li><li><p>Single Files</p><ul><li>convert_data.lua -&gt; 似乎是图片预处理的过程</li><li>install_lua_modules.sh -&gt; 安装依赖</li><li>train.lua</li><li>waifu2x.lua</li><li>web.lua</li><li>Dockerfile</li><li><strong><em>Other Files</em></strong></li></ul></li></ul><p>综上分析，与核心处理相关的代码，位于<code>lib</code>文件夹（描述网络）和主文件（调用）下，核心代码并不是很多，甚至让我觉得，比Caffe版还要简洁一点。</p><h3 id="回到保存的模型"><a href="#回到保存的模型" class="headerlink" title="回到保存的模型"></a>回到保存的模型</h3><p>由上面的代码分析，并且去看了历史提交，发现json版的模型文件在初始提交中并没有，而是稍晚时添加的，同时添加了上面的<code>export_model.lua</code>。（虽然初始代码还没有像现在这样构建命令行，但意思是一样的）</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-built_in">io</span>.<span class="hljs-built_in">write</span>(cjson.encode(jmodules))<br></code></pre></td></tr></table></figure><p>所以先前的判断是没错的，json模型和t7模型就是一致的。json模型是为了“跨框架”而准备的，使预测/前向传播不限于Torch（+CUDA）的框架。</p><p>当然，json模型下那一堆小数（与t7模型中整齐的模型参数形成了对比），应该是转换过程中近似计算导致的。这应该很好理解，在Torch下的函数别的地方没有，那只能把数值算出来，用类似查表的方式提供给其他框架。</p><p>比如Waifu2x-convert，在<code>modelHandler.hpp/.cpp</code>就用下面的语句读取json模型的内容（借助picojson）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">picojson::<span class="hljs-built_in">array</span> &amp;wOutputPlane = jsonObj[<span class="hljs-string">"weight"</span>].get&lt;picojson::<span class="hljs-built_in">array</span>&gt;();<br></code></pre></td></tr></table></figure><p>所以可以推测，用json模型会比用t7模型（以及直接由t7转向其他框架模型，如由t7转向pt）精度低？</p><p>所以延伸一下，我不能偷懒（或者说瞎折腾），把json模型喂给PyTorch，而还是要借助低版本PyTorch完成从t7到pt的模型转换。但忘了在哪看到了，说PyTorch的C++前端没有明显提速、甚至慢于Python前端，很大程度是因为读取pt模型拖慢了速度。那我能否使用json模型实现精度换速度？</p><p>…有想法，但我目前还是按套路出牌吧…</p><h3 id="进一步说模型"><a href="#进一步说模型" class="headerlink" title="进一步说模型"></a>进一步说模型</h3><h4 id="各版本模型情况"><a href="#各版本模型情况" class="headerlink" title="各版本模型情况"></a>各版本模型情况</h4><table><thead><tr><th align="center">版本</th><th align="center">主体文件</th><th align="center">辅助文件</th><th align="center">hash一致</th></tr></thead><tbody><tr><td align="center">Waifu2x</td><td align="center">json/t7</td><td align="center">/</td><td align="center">√</td></tr><tr><td align="center">Waifu2x-caffe</td><td align="center">json</td><td align="center">prototxt</td><td align="center">√</td></tr><tr><td align="center">VapourSynth-Waifu2x-caffe</td><td align="center">json.caffemodel</td><td align="center">protobin</td><td align="center">×</td></tr></tbody></table><h4 id="关于t7转pt"><a href="#关于t7转pt" class="headerlink" title="关于t7转pt"></a>关于t7转pt</h4><p>这个别想了，用目前查到的<code>convert_torch.py</code>，因为模型结构的原因，没法转cunet的模型，其他的没试（其实在两天前，周五的时候，就在某篇博文上读到过，<code>convert_torch.py</code>不是万能的，今天更是在Github issues上看到了作者类似的回复）。所以Waifu2x-caffe直接用的json模型。</p><p>不过话说回来，json模型是怎么转成caffe的caffemodel的？（这样转是为了提高读入速度吗？）</p><p>而我从来没注意过Waifu2x-caffe和VapourSynth版代码的区别，读这两种不同格式的模型（json/caffemodel），代码上总归得有点区别吧。</p><h4 id="下一步的模型转换计划"><a href="#下一步的模型转换计划" class="headerlink" title="下一步的模型转换计划"></a>下一步的模型转换计划</h4><p>所以对于写libtorch，要么想办法手动读入json模型，要么…onnx？</p><p>在<a href="https://github.com/yu45020/Waifu2x/blob/master/Models.py" target="_blank" rel="noopener">Waifu2x-PyTorch</a>版中，作者自定义了函数<code>load_pre_train_weights()</code>用以加载json模型，所以我可以直接拿来用了？</p><p>但Waifu2x-PyTorch的Readme中有句话很让人在意。</p><blockquote><p>Model inference (32 fp only) can run in cpu only.</p></blockquote><p>像只做预测的VapourSynth-Waifu2x-caffe、ncnn版是在GPU中运行的。这里只能在CPU中运行，这是一个可改进的地方。</p><p>Whatever，现在情况已经明了了，基于不重复造轮子的原则<del>和我什么不会的实际情况</del>，我完全可以在现有Waifu2x-PyTorch的基础上，去写libtorch的前向计算。至于是写出独立项目，还是基于VapourSynth，这个可以后续再考虑。</p>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Torch</tag>
      
      <tag>PyTorch</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Windows下CUDA兼容性的问题与LibTorch的使用——珍爱生命，远离MSVC</title>
    <link href="/2020/01/18/cuda-and-msvc/"/>
    <url>/2020/01/18/cuda-and-msvc/</url>
    
    <content type="html"><![CDATA[<p>前几天把CUDA 9.1升级到了CUDA 9.2，以便和PyTorch匹配。升级CUAD以及作为铺垫的升级显卡驱动倒没啥好说的，点开exe，覆盖安装就行了。</p><p>…除了一个地方。安装CUDA 9.2时，需要把和Visual Studio相关的一项取消勾选，否则装不上。等我装完CUDA 9.2，再打开VS2019，弹出一个错误，没太细看，是和CUDA有关的。</p><p>今天去用CMake编译时，拿libtorch的示例都编译不过去，查了一下，发现CUDA和高版本的VS不兼容…具体可以看这里，<a href="https://devtalk.nvidia.com/default/topic/1035794/cuda-setup-and-installation/cuda-9-2-quot-nvidia-installer-failed-quot-/2" target="_blank" rel="noopener">CUDA 9.2: “NVIDIA Installer Failed”</a>。</p><p>在<code>C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v9.2\include\crt\host_config.h</code>的131行开始，有如下语句。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> _MSC_VER <span class="hljs-meta-string">&lt; 1600 || _MSC_VER &gt; 1913</span></span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">error</span> -- unsupported Microsoft Visual Studio version! Only the versions 2012, 2013, 2015 and 2017 are supported!</span><br></code></pre></td></tr></table></figure><p>而我用VS2019，MSVC版本为1921。所以无论是安装时的问题，还是安装后VS2019的报错，抑或是现在的编译不过去，都知道了原因，CUDA 9.2和高版本的MSVC不兼容。</p><a id="more"></a><h3 id="升级到CUDA-10-1"><a href="#升级到CUDA-10-1" class="headerlink" title="升级到CUDA 10.1"></a>升级到CUDA 10.1</h3><p>这次安装倒没出什么问题，无脑点next就OK了。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">Installed:<br>     - Nsight <span class="hljs-keyword">for</span> Visual Studio <span class="hljs-number">2019</span><br>     - Nsight Monitor <span class="hljs-keyword">and</span> HUD Launcher<br>Not Installed:<br>     - Nsight <span class="hljs-keyword">for</span> Visual Studio <span class="hljs-number">2017</span><br>       Reason: VS2017 was <span class="hljs-keyword">not</span> found<br>     - Nsight <span class="hljs-keyword">for</span> Visual Studio <span class="hljs-number">2015</span><br>       Reason: VS2015 was <span class="hljs-keyword">not</span> found<br></code></pre></td></tr></table></figure><p>看到上面这样的提示，还是很放心的。然后把Python版和C++版的PyTorch都重装成CUDA 10.1版本的。</p><p>虽然说远离MSVC…但在Windows平台上…不得不低头额…还是真香。</p><h3 id="编译LibTorch的示例"><a href="#编译LibTorch的示例" class="headerlink" title="编译LibTorch的示例"></a>编译LibTorch的示例</h3><p>示例在<a href="https://pytorch.org/cppdocs/installing.html" target="_blank" rel="noopener">这里</a>。</p><p>cpp和CMakeLisits.txt的内容copy过来，编译。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">mkdir build &amp; cd build<br>cmake ..<br>cmake --build . --config Release<br></code></pre></td></tr></table></figure><p>在第二步和官方示例不一样，省了设置路径（其实是我忘了），官方示例是这样的。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">cmake -DCMAKE_PREFIX_PATH=/absolute/path/to/libtorch ..<br></code></pre></td></tr></table></figure><p>因为已经把libtorch添加进了环境变量，所以省去也没关系吧。</p><p>虽然还是没有看到Makefile，但已经编译好了exe。只是这个<code>Release</code>文件夹体积太吓人了，把cuDNN相关的dll、torch和torch_python的本体dll都复制进来了…（诶，话说为什么要有<code>torch_python.dll</code>？）</p><p>最后纪念一下我编译出来的第一个C++版PyTorch代码。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">λ cd Release<br>λ example-app<br> <span class="hljs-number">0.0935</span>  <span class="hljs-number">0.2273</span>  <span class="hljs-number">0.5856</span><br> <span class="hljs-number">0.0627</span>  <span class="hljs-number">0.0996</span>  <span class="hljs-number">0.7945</span><br>[ CPUFloatType&#123;<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125; ]<br></code></pre></td></tr></table></figure><h3 id="LibTorch的模型调用与预测"><a href="#LibTorch的模型调用与预测" class="headerlink" title="LibTorch的模型调用与预测"></a>LibTorch的模型调用与预测</h3><p>这里没太多好说的，照着<a href="https://pytorch.org/tutorials/advanced/cpp_export.html" target="_blank" rel="noopener">官方教程</a>，编译了一遍。</p><p>载入模型</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">λ libtorch-test model.pt<br>ok<br></code></pre></td></tr></table></figure><p>模型预测</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs lsl">λ libtorch-test <span class="hljs-string">"PATH/TO/model.pt"</span><br><span class="hljs-number">-0.1862</span>  <span class="hljs-number">0.3385</span> <span class="hljs-number">-0.3066</span> <span class="hljs-number">-0.3085</span> <span class="hljs-number">-0.3040</span><br>[ CPUFloatType&#123;<span class="hljs-number">1</span>,<span class="hljs-number">5</span>&#125; ]<br>ok<br></code></pre></td></tr></table></figure><p>代码上没遇到明显的问题，只是概念上要明白，虽然模型都是.pt的后缀，但PyTorch的Python前端和C++前端的模型格式并不一样，Python得到的模型，不能直接在C++中载入，需要转换格式。</p><h4 id="关于模型，额外的话"><a href="#关于模型，额外的话" class="headerlink" title="关于模型，额外的话"></a>关于模型，额外的话</h4><p>顺带一提，在纯Python前端的项目，经常看到<code>model</code>文件夹下只是.py文件，这是生成模型的代码，而不是模型本身啊。</p><p>但我还是不知道，Torch中的模型，除了.t7，还能不能保存成json格式？</p>]]></content>
    
    
    <categories>
      
      <category>工具使用</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CUDA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>周记 2020.01.06-01.12</title>
    <link href="/2020/01/15/week-202001-2/"/>
    <url>/2020/01/15/week-202001-2/</url>
    
    <content type="html"><![CDATA[<p>最近的生活也算是走上正轨，但却好像抽不出时间写周记。这是不好的，因为就算再忙，也要知道我在忙什么，不然可能会很危险的。</p><p>姑且把上周写的一些C++笔记当作周记吧，毕竟也是涵盖了上周的大部分活动。</p><h3 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h3><p>预处理功能有三种：宏定义，文件包含和条件编译</p><p><strong>条件编译</strong></p><p><code>#ifndef</code>与<code>#endif</code>配套使用</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> defined(__GNUC__) || defined(__clang__)</span><br></code></pre></td></tr></table></figure><p>这是条件编译的意思</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++">_WIN32    <span class="hljs-comment">// Windows</span><br>__linux   <span class="hljs-comment">// Linux</span><br><br>__clang__ <span class="hljs-comment">// Clang</span><br>__GNUC__  <span class="hljs-comment">// GCC（需要注意的是Clang也会定义这个宏）</span><br>_MSC_VER  <span class="hljs-comment">// MSVC</span><br></code></pre></td></tr></table></figure><p>所以我在vs代码中看到的，只是为了满足不同的编译器。</p><a id="more"></a><h3 id="一些概念"><a href="#一些概念" class="headerlink" title="一些概念"></a>一些概念</h3><p>Q：.hpp与.h的区别<br>A：.h只有声明没有实现，.hpp既有声明又有实现</p><p>Q：用VS编译（GCC编译没有这个事），为什么会找不到标识符，明明IDE说的变量在错误行根本没有，而且变量已经定义了</p><p>Q：<code>delete</code>与<code>delete[]</code>的区别<br>A：目前我的理解是，对于类，上述两者有区别，对于普通类型变量没有区别。但我现在面对的是结构体中的变量…怎么办…</p><h3 id="C-标准"><a href="#C-标准" class="headerlink" title="C++标准"></a>C++标准</h3><p>C++11正式引入了多线程的概念，直到现在，仍能看到指定基于C++11标准进行编译的项目。我现在的用VS2019，似乎默认基于C++14标准编译。现在也开始接触C++17的一些函数。</p><h3 id="编译的经验"><a href="#编译的经验" class="headerlink" title="编译的经验"></a>编译的经验</h3><p>从在CentOS上编译caffe开始，到后来在Windows下编译av1，再到现在。</p><h4 id="1-版本限定"><a href="#1-版本限定" class="headerlink" title="1.版本限定"></a>1.版本限定</h4><p>在用Python装一些依赖库的时候，就会遇到不仅有版本下限的要求，还会有版本上限的要求。</p><p>我在这段时间编译vs plugin时，作为接口的头文件，要与自用的vs保持一致，用更高版本的也不行，vseditor无法识别。</p><p>又比如，编译C++ API的TensorFlow，似乎所需的proto要和TensorFlow版本一致，高低都不行，这和上面vs的情况很类似。</p><p>直到现在，还会觉得编译是个让人头疼的问题。不过头疼是面对向TensorFlow这样我不熟悉的代码时；而我熟悉的vs，虽然搞明白版本依赖也是踩坑之后才想明白的，但因为熟悉，很快就接受并习以为常了。</p><p>所以，“人和人真不是相通的”，很多时候我自己写的笔记，我可以肯定很多人会看不明白，因为这是写给我自己的。相应的，其实很多体量已经很庞大的项目，那些Doc也未必适合初学者，不理解是正常的。而每个人的机器不一样，空机器还好；一台用了很久的机器，潜在的依赖不知道是什么样。自己编译源码时出现问题，更是很正常的。</p><h4 id="2-在Windows下像Linux一样编译"><a href="#2-在Windows下像Linux一样编译" class="headerlink" title="2.在Windows下像Linux一样编译"></a>2.在Windows下像Linux一样编译</h4><p>小标题现在看来像是一句正确的废话。但很长一段时间以来的我，都以Linux有着独特“优势”。这话说出来，看上去没什么错，但我的理解有问题。直到用了Visual Studio的Developer Command Prompt和MSVC，用了cmake，我才知道，原来Windows下也能这么编译。而Linux所谓的优势，或许是更便捷，而并非“专属”。</p><h4 id="3-复杂依赖的解决"><a href="#3-复杂依赖的解决" class="headerlink" title="3.复杂依赖的解决"></a>3.复杂依赖的解决</h4><p>或者更具体点，复杂头文件的解决。</p><p>起初我编译自己写的vs plugin，所需的头文件很少，直接copy到工程目录也不是事。之后学OpenCV，被教程惯坏了，照着书本一通配置库目录，然后就能无脑敲代码了。</p><p>其实很简单的逻辑关系，我挺早的时候就弄明白了，依赖的无非就是头文件和库文件。但依赖一多，比如我编译基于ncnn写的代码的时候，一堆依赖，再用复制大法..恐怕也不行…</p><p>所以老老实实地配环境，配目录吧。（话说MSVC还有<code>x64.props</code>和<code>Win32.props</code>，读取用户器件上的依赖，避免了版本不匹配的问题）</p><h4 id="4-从GCC到指令集优化"><a href="#4-从GCC到指令集优化" class="headerlink" title="4.从GCC到指令集优化"></a>4.从GCC到指令集优化</h4><p><em>话说我很喜欢写“从…到…”的句式。因为要补的东西太多，往往遇见一个新东西就能启发到另一个东西。</em></p><p>在64位的GCC目录下，藏着这么个东西，<code>immintrin.h</code>。</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal">mingw64\<span class="hljs-class"><span class="hljs-keyword">lib</span>\<span class="hljs-title">gcc</span>\<span class="hljs-title">x86_64</span>-<span class="hljs-title">w64</span>-<span class="hljs-title">mingw32</span>\8.1.0\<span class="hljs-title">include</span></span><br></code></pre></td></tr></table></figure><p><code>immintrin.h</code>集成了AVX指令集优化的相关头文件，是打开指令集优化大门的撬棍。我心念念的指令集优化终于有了着落。</p><h3 id="人生相谈"><a href="#人生相谈" class="headerlink" title="人生相谈"></a>人生相谈</h3><p>在NGA论坛看到的，值得好好读一下。</p><blockquote><p>gcc和msvc等编译工具要熟悉，make file要会写。</p><p>From: <a href="https://bbs.nga.cn/read.php?tid=19639952&amp;page=2" target="_blank" rel="noopener">https://bbs.nga.cn/read.php?tid=19639952&amp;page=2</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>记一次从AviSynth到VapourSynth的迁移（2）：感受不同的API 下</title>
    <link href="/2020/01/01/ported-to-vs-2/"/>
    <url>/2020/01/01/ported-to-vs-2/</url>
    
    <content type="html"><![CDATA[<p>距离写上一篇博文已经过去几天了（事实上那篇博文在更早的几天就写了草稿）。这几天学到了不少东西，硬塞到上一篇博文中好像不太合适；而且上一篇博文就是在思路不太清时写，有点混乱。总之，干脆新写一篇。</p><p>为了加强理解、尽量全面，可能会有些重复的话。</p><h3 id="srcp、dstp的理解"><a href="#srcp、dstp的理解" class="headerlink" title="srcp、dstp的理解"></a><code>srcp</code>、<code>dstp</code>的理解</h3><p>约定俗成的变量命名，<code>src</code>已经习惯，是输入，而<code>dsp</code>则是结果。</p><p>关于<code>srcp</code>和<code>dstp</code>，通常这样定义</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">const</span> T* srcp = <span class="hljs-keyword">reinterpret_cast</span>&lt;<span class="hljs-keyword">const</span> T*&gt;(vsapi-&gt;getReadPtr(src, plane));<br>T* VS_RESTRICT dstp = <span class="hljs-keyword">reinterpret_cast</span>&lt;T*&gt;(vsapi-&gt;getWritePtr(dst, plane));<br></code></pre></td></tr></table></figure><ol><li><code>getReadPtr()</code>和<code>getWritePte()</code>均是<code>uint8_t *</code>型，为满足不同位深的输入输出，也就是能够给不同类型的变量赋值，用<code>reinterpret_cast</code>做类型转换，转换为模版中的<code>T</code>。</li><li>需要注意到，<code>srcp</code>和<code>dstp</code>已经包含了平面信息，或者说代表了特定平面，在滤镜核心处理函数中，用for循环遍历各个平面，for循环内就会基于<code>srcp</code>和<code>dstp</code>，对单个平面做处理。</li><li>注意<code>srcp</code>、<code>dstp</code>是指针，这个在稍后会继续说。</li></ol><a id="more"></a><h3 id="stride的理解"><a href="#stride的理解" class="headerlink" title="stride的理解"></a><code>stride</code>的理解</h3><p>avs api和vs api的一大区别，就是隐藏在习惯变量名不同（<code>pitch</code>与<code>stride</code>）之下的单位问题。</p><p>从Doc上看，avs api获取的<code>pitch</code>和vs api获取的<code>stride</code>都是以字节为单位。在使用中，vs框架下要除以变量所占的字节，即</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> dst_stride = vsapi-&gt;getStride(dst, plane) / <span class="hljs-keyword">sizeof</span>(T);<br></code></pre></td></tr></table></figure><p>但我读过的几份avs滤镜代码，都是直接用的，没有除<code>sizeof</code>。</p><p>突然明白，我忘了一个事情，<strong><code>sizeof(uint8_t)</code> = 1啊</strong>，所以不需要除<code>sizeof</code>，是不是以字节为单位，都是一样的啊。</p><h5 id="疑问的解释"><a href="#疑问的解释" class="headerlink" title="疑问的解释"></a>疑问的解释</h5><p>我一直在纠结下面的avs与vs代码会不会有区别。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// avs</span><br>srcp += src_pitch;<br>dstp += target_width;<br><span class="hljs-comment">// vs</span><br>srcp += src_stride;<br>dstp += target_width; <span class="hljs-comment">// dstp += dst_stride;</span><br></code></pre></td></tr></table></figure><p>但其实这个问题是不存在的。对于avs，基于全程8bit的假设，<code>sizeof</code> = 1，虽然<code>src_pitch</code>是以字节为单位，但数值上与<code>target_width</code>是同级的；对于vs，<code>src_stride</code>是除过<code>sizof</code>的，与<code>target_width</code>单位一致。</p><p>所以无论vs怎么写，与avs都是一致的，且<code>srcp</code>与<code>dstp</code>数值都是同级的。</p><h3 id="stride与dstp的共同作用"><a href="#stride与dstp的共同作用" class="headerlink" title="stride与dstp的共同作用"></a><code>stride</code>与<code>dstp</code>的共同作用</h3><p>类似<code>dstp += dst_stride;</code>这样的语句，实现了指针的移动，<del>让继续处理下一帧？</del>是处理同列中个下个像素。</p><p><del>而<code>dstp[y + x * dst_stride]</code>应该是二维平面上的指针移动。</del>这话也没有错，但有种误导的感觉，其实和上面是一个意思，只不过上面单独处理列，这个是行和列同时处理。</p><p>详情在<a href="https://kiyamou.github.io/2019/12/18/image-process-code-1/" target="_blank" rel="noopener">另一篇博文</a>里写了。</p><h3 id="VapourSynth数据结构的猜测"><a href="#VapourSynth数据结构的猜测" class="headerlink" title="VapourSynth数据结构的猜测"></a>VapourSynth数据结构的猜测</h3><p>（有人说编程是算法+数据结构，现在终于能理解到这句话了）</p><p>简单地说，是像一维数组那样横着排的？对<code>dstp</code>加上一个<code>width</code>就到下一帧？</p><p>但这样想，上面那样的<code>dstp[y + x * dst_stride]</code>又说不通了。</p><h3 id="void函数做了什么"><a href="#void函数做了什么" class="headerlink" title="void函数做了什么"></a><code>void</code>函数做了什么</h3><p>这个问题看上去很蠢，但也许是我上半年写Python留下的后遗症。总以为函数后要<code>return</code>个什么东西，仿佛把封装好的函数当成一个计算黑箱。这样理解也谈不上错吧，但却让我在一开始读vs滤镜代码时一头雾水。</p><p>经过了一个<code>void</code>函数，函数内的全局变量（或者是生存期大过该函数的变量）已经被改变。简单地说，就是“酒肉穿肠过，该变的都变了”的意思。</p><h3 id="vsapi的理解"><a href="#vsapi的理解" class="headerlink" title="vsapi的理解"></a><code>vsapi</code>的理解</h3><p>可以将滤镜分为两类：一类是resize型滤镜，输入输出的尺寸不一致；一类是非resize型滤镜，输入输出的尺寸一致。</p><p>对于后者，在初始化函数<code>FilterInit()</code>中，只需原样写下<code>vi</code>即可</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> VS_CC <span class="hljs-title">FilterInit</span><span class="hljs-params">(VSMap* in, VSMap* out, <span class="hljs-keyword">void</span>** instanceData, VSNode* node, VSCore* core, <span class="hljs-keyword">const</span> VSAPI* vsapi)</span></span><br><span class="hljs-function"></span>&#123;<br>    FilterData* d = <span class="hljs-keyword">static_cast</span>&lt;FilterData*&gt;(*instanceData);<br>    vsapi-&gt;setVideoInfo(d-&gt;vi, <span class="hljs-number">1</span>, node);<br>&#125;<br></code></pre></td></tr></table></figure><p>对于前者，要在初始化中将尺寸改写为输出尺寸</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> VS_CC <span class="hljs-title">FilterInit</span><span class="hljs-params">(VSMap* in, VSMap* out, <span class="hljs-keyword">void</span>** instanceData, VSNode* node, VSCore* core, <span class="hljs-keyword">const</span> VSAPI* vsapi)</span></span><br><span class="hljs-function"></span>&#123;<br>    FilterData* d = <span class="hljs-keyword">static_cast</span>&lt;FilterData*&gt;(*intanceData);<br>    VSVideoInfo dst_vi = (VSVideoInfo)* d-&gt;vi;<br>    dst_vi.width = d-&gt;output_width;<br>    dst_vi.height = d-&gt;output_height;<br>    vsapi-&gt;setVideoInfo(&amp;dst_vi, <span class="hljs-number">1</span>, node); <span class="hljs-comment">// 注意d-&gt;vi是指针，这里要取地址</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这样就保证了输出的<code>dst</code>是resize后的尺寸，否则照上面那样写，（与输入源不一样的尺寸）会报错。</p><p>写法不是唯一的，也可以在<code>FilterCreate()</code>函数里写，只是我还不太会…</p><h3 id="遇事不决用double"><a href="#遇事不决用double" class="headerlink" title="遇事不决用double"></a>遇事不决用double</h3><p>emmm困扰了我一整天的颜色问题，把函数内部处理全变成double，直到输出时再改成所需的类型，颜色终于正常了。</p><p>现在毕竟还在起步阶段，先把能正常运行的程序写出来，再考虑提升性能的事情。</p><h3 id="关于编译与调用"><a href="#关于编译与调用" class="headerlink" title="关于编译与调用"></a>关于编译与调用</h3><p>要保持编译时用的头文件与VapourSynth SDK文件夹中的头文件一致，否则无法调用。</p><p>（所以在配置编译文件时需要动点脑子）</p><h3 id="C-的基础"><a href="#C-的基础" class="headerlink" title="C++的基础"></a>C++的基础</h3><h4 id="进一步理解C-的类型转换"><a href="#进一步理解C-的类型转换" class="headerlink" title="进一步理解C++的类型转换"></a>进一步理解C++的类型转换</h4><h4 id="编译相关"><a href="#编译相关" class="headerlink" title="编译相关"></a>编译相关</h4><p>两次编译的结果，hash不会一样的，但二进制文件大小一样。</p><h4 id="零散的知识点"><a href="#零散的知识点" class="headerlink" title="零散的知识点"></a>零散的知识点</h4><p>递归函数（调用了自身的函数）没法内联。</p><p>静态函数（用<code>static</code>关键字声明）不可在文件外被调用。</p>]]></content>
    
    
    <categories>
      
      <category>Code</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>VapourSynth</tag>
      
      <tag>Avisynth</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>记一次从AviSynth到VapourSynth的迁移（1）：感受不同的API 上</title>
    <link href="/2019/12/28/ported-to-vs/"/>
    <url>/2019/12/28/ported-to-vs/</url>
    
    <content type="html"><![CDATA[<p>（内容待整理…orz）</p><h3 id="1-细碎的问题"><a href="#1-细碎的问题" class="headerlink" title="1.细碎的问题"></a>1.细碎的问题</h3><h4 id="变量命名习惯的变化"><a href="#变量命名习惯的变化" class="headerlink" title="变量命名习惯的变化"></a>变量命名习惯的变化</h4><p>avs的<code>pitch</code> = vs的<code>stride</code></p><p>avs的<code>env</code> = vs的<code>vi</code>？那avs的<code>params</code>呢？</p><p>vs中很少见<code>dst-&gt;width</code>之类的写法，而是<code>d-&gt;width</code></p><a id="more"></a><h4 id="函数的迁移"><a href="#函数的迁移" class="headerlink" title="函数的迁移"></a>函数的迁移</h4><p>1.<code>GetRowSize()</code>到<code>GetWidth()*sizeof()</code>?</p><p>2.<code>BitBlt()</code>到<code>vs_bitblt</code></p><p>3.获取子采样的字节数</p><p><code>GetPlaneWidthSubsampling()</code>、<code>GetPlaneHeightSubsampling()</code>到<code>subSamplingW</code>、<code>subSamplingH</code></p><p>4.在初始化<code>gcd_h</code>、<code>gcd_v</code>的时候写了一串，是因为avs没有提供类似<code>vsapi-&gt;getFrameWidth(src, plane)</code>的api，在vs中，不用这么费力。</p><h4 id="变量类型的重新定义"><a href="#变量类型的重新定义" class="headerlink" title="变量类型的重新定义"></a>变量类型的重新定义</h4><p>1.为了兼容32bit，不能用<code>unsigned</code>修饰变量类型，因为32bit的取值是<code>[-1.0, 1.0]</code>，包含负值。</p><p>2.为了避免我不知道的麻烦，把所有<code>short</code>类型全用<code>int</code>代替，之后有可能再改回来。</p><h3 id="2-函数调用逻辑的变化"><a href="#2-函数调用逻辑的变化" class="headerlink" title="2.函数调用逻辑的变化"></a>2.函数调用逻辑的变化</h3><ul><li>判断RGB or YUV空间 -&gt; 选择相应的函数</li></ul><p>就是这么简单的逻辑，写个if语句就好，为什么感到这么凌乱。</p><p>我需要回答几个问题</p><ul><li>为什么把横向和纵向写成两个函数？在<code>process()</code>调用时，这两个函数的关系是什么，是先处理一个方向吗？</li><li>在if判断条件中的运算结果，其生存期是多少？</li><li>为什么在Hor和Ver两个方向，分别代入了源和输出的尺寸？</li></ul><h3 id="3-从类到模版"><a href="#3-从类到模版" class="headerlink" title="3.从类到模版"></a>3.从类到模版</h3><p>还是类和对象好啊，为什么使用了vs api后，就没有那种教科书一般经典的类和对象的用法了呢？</p><h4 id="调用VapourSynth-API本身的一些问题"><a href="#调用VapourSynth-API本身的一些问题" class="headerlink" title="调用VapourSynth API本身的一些问题"></a>调用VapourSynth API本身的一些问题</h4><p>使用函数（我想说啥来着…）</p><p>我甚至忘了<code>vsapi-&gt;getFrameWidth(src, plane)</code>，把<code>src</code>换成<code>dst</code>就是输出的尺寸了啊..一个劲写<code>d-&gt;target_width</code>总感觉不对劲…</p><h3 id="4-C-基础相关"><a href="#4-C-基础相关" class="headerlink" title="4.C++基础相关"></a>4.C++基础相关</h3><h4 id="this指针"><a href="#this指针" class="headerlink" title="this指针"></a>this指针</h4><h5 id="语法上的概念"><a href="#语法上的概念" class="headerlink" title="语法上的概念"></a>语法上的概念</h5><p>只有成员函数才有this指针，每个对象都能通过this指针访问自己的地址。</p><p>这篇<a href="https://www.runoob.com/cplusplus/cpp-this-pointer.html" target="_blank" rel="noopener">菜鸟教程</a>确实很好，不仅说明了this指针，也更加清楚地理解了<code>-&gt;</code>运算符。</p><p>这是类和对象中的概念，我在迁移后的VapouSynth中根本没有写class，所以不要this指针了吧。</p><p>从语法上讲，this指针不能用于被<code>static</code>标记的（成员）函数。</p><h5 id="具体实现的功能"><a href="#具体实现的功能" class="headerlink" title="具体实现的功能"></a>具体实现的功能</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">if</span> (!(<span class="hljs-keyword">this</span>-&gt;*(<span class="hljs-keyword">this</span>-&gt;ResizeHorizontal))(buff, srcp, src_pitch, &amp;params[i]))<br></code></pre></td></tr></table></figure><p>从这个判断语句中能得到什么？让我终于明白了代码中四个核心处理函数为什么要写成<code>bool</code>型了。像这样</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">bool</span> AreaResize::ResizeHorizontalPlanar(BYTE* dstp, <span class="hljs-keyword">const</span> BYTE* srcp, <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> src_pitch, <span class="hljs-keyword">const</span> <span class="hljs-keyword">params_t</span>* params)<br></code></pre></td></tr></table></figure><p>emmm…但是每个函数最后都写着<code>return true</code>，那<code>false</code>是怎么来的…</p><h4 id="数学函数"><a href="#数学函数" class="headerlink" title="数学函数"></a>数学函数</h4><p><code>gcd()</code>，求最大公约数，实现如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">gcd</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">int</span> m = x % y;<br><span class="hljs-keyword">return</span> m == <span class="hljs-number">0</span> ? y : gcd(y, m);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="C-的多线程"><a href="#C-的多线程" class="headerlink" title="C++的多线程"></a>C++的多线程</h4><p>并发（Concurrency）和并行（Parallelism）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">Concurrency::parallel_for();<br></code></pre></td></tr></table></figure><h4 id="switch语句"><a href="#switch语句" class="headerlink" title="switch语句"></a>switch语句</h4><p>在条件并列且写法整齐时，用switch比if…else更简洁一些。</p><h4 id="基础的基础"><a href="#基础的基础" class="headerlink" title="基础的基础"></a>基础的基础</h4><p>第一次看到类似这样的写法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">short</span> index_value = target_width; index_value--; )<br></code></pre></td></tr></table></figure><p>最后的判断项省略了。</p>]]></content>
    
    
    <categories>
      
      <category>Code</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>VapourSynth</tag>
      
      <tag>Avisynth</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OpenCV学习笔记（1）：入门、傅里叶变换与亮度对比度调整</title>
    <link href="/2019/12/27/OpenCV-learn-1/"/>
    <url>/2019/12/27/OpenCV-learn-1/</url>
    
    <content type="html"><![CDATA[<script type="text/javascript"   src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><p>记录一下学习《OpenCV3编程入门》的过程。由于有图像处理的基础，感觉很多内容都很亲切。</p><h3 id="这几天学习的总结"><a href="#这几天学习的总结" class="headerlink" title="这几天学习的总结"></a>这几天学习的总结</h3><ul><li>OpenCV在VS下的配置，OpenCV头文件的引用关系（第一章）</li><li>OpenCV基础的操作（感受到变量是怎样在函数中传递的）（第一章）</li><li>OpenCV的常用函数（第三章）</li><li>Mat矩阵变量的初始化和输出（第四章）</li><li>一些C++相关的基础知识（第二章）<ul><li><code>printf()</code>格式输出函数</li><li>一些变量的命名规范</li><li>通过宏来定义的常量，通常所有字母集体大写</li></ul></li><li>图像混合、亮度与对比度调整、傅里叶变换（第五章）（顺带复习了第四章的基础函数，<code>Rect()</code>、<code>Scalar()</code>、<code>Szie()</code>等）</li><li>窗口程序相关：滑动条的创建（第三章与第五章）</li></ul><a id="more"></a><p>《OpenCV3编程入门》这本书一个特点就是前后知识会有相关和重合，这样学起来感觉不错。</p><h3 id="傅里叶变换"><a href="#傅里叶变换" class="headerlink" title="傅里叶变换"></a>傅里叶变换</h3><p>有个之前接触过，但没有亲自操作过的概念，对数尺度缩放。</p><p>单纯对二维图像进行傅里叶变换，变换结果通常不容易观察，明亮的高频区域过小。为便于观察，可以进行对数缩放。</p><p>对数缩放在大二的课上没有讲过，但我在一个小工具里用过，比直接变换“美观”很多。</p><p>先回忆一下大二课堂上用matlab做过的傅里叶变换。</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs matlab">[Image, map] = imread(<span class="hljs-string">'C:/code/test.png'</span>, <span class="hljs-string">'png'</span>);<br>imshow(Image);<br><br>Image = rgb2gray(Image);    <span class="hljs-comment">% 转换为灰度图像</span><br>fftI = fft2(Image);         <span class="hljs-comment">% 进行傅里叶变化</span><br>sfftI = fftshift(fftI);     <span class="hljs-comment">% 将频谱中心移至图像中心</span><br>RR = <span class="hljs-built_in">real</span>(sfftI);<br>II = <span class="hljs-built_in">imag</span>(sfftI);<br>A = <span class="hljs-built_in">sqrt</span>(RR.^<span class="hljs-number">2</span> + II.^<span class="hljs-number">2</span>);    <span class="hljs-comment">% 计算频谱幅值</span><br>A = (A - <span class="hljs-built_in">min</span>(<span class="hljs-built_in">min</span>(A))) / (<span class="hljs-built_in">max</span>(<span class="hljs-built_in">max</span>(A)) - <span class="hljs-built_in">min</span>(<span class="hljs-built_in">min</span>(A))) * <span class="hljs-number">225</span>;  <span class="hljs-comment">% 归一化</span><br><br><span class="hljs-built_in">figure</span>;<br>imshow(A);<br>axis square;                <span class="hljs-comment">% 将频谱图调整为正方形</span><br></code></pre></td></tr></table></figure><p>再重温一下用OpenCV在C++中的实现。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;opencv2/core/core.hpp&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;opencv2/imgproc/imgproc.hpp&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;opencv2/highgui/highgui.hpp&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> cv;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    Mat srcImage = imread(<span class="hljs-string">"C:/code/test.png"</span>, <span class="hljs-number">0</span>); <span class="hljs-comment">// 和matlab相似，但路径要用双引号</span><br>    imshow(<span class="hljs-string">"Original Image"</span>, srcImage);<br><br>    <span class="hljs-keyword">int</span> m = getOptimalDFTSize(srcImage.rows);     <span class="hljs-comment">// 扩充边界（不知道matlab是如何处理的）</span><br>    <span class="hljs-keyword">int</span> n = getOptimalDFTSize(srcImage.cols);     <span class="hljs-comment">// OpenCV的函数果然丰富，专门为DFT扩充边界的都有</span><br>    Mat padded;<br>    copyMakeBorder(srcImage, padded, <span class="hljs-number">0</span>, m - srcImage.rows, <span class="hljs-number">0</span>, n - srcImage.cols,<br>        BORDER_CONSTANT, Scalar::all(<span class="hljs-number">0</span>));         <span class="hljs-comment">// BORDER_CONSTANT = 0</span><br><br>    <span class="hljs-comment">// 为傅里叶变换结果分配储存空间——这是C++作为程序语言与matlab的不同之处</span><br>    Mat planes[] = &#123; Mat_&lt;<span class="hljs-keyword">float</span>&gt;(padded),<br>                    Mat::zeros(padded.size(), CV_32F) &#125;; <span class="hljs-comment">// 另创建一个与padded同样大小的空矩阵</span><br>    Mat complexI;<br>    merge(planes, <span class="hljs-number">2</span>, complexI);   <span class="hljs-comment">// 增加一个通道，将两个planes合并，为了存储复数</span><br><br>    dft(complexI, complexI);      <span class="hljs-comment">// 进行傅里叶变换</span><br><br>    split(complexI, planes);<br>    magnitude(planes[<span class="hljs-number">0</span>], planes[<span class="hljs-number">1</span>], planes[<span class="hljs-number">0</span>]);  <span class="hljs-comment">// 计算复数幅值，并将结果储存到planes[0]</span><br>    <span class="hljs-comment">// CV_EXPORTS_W void magnitude(InputArray x, InputArray y, OutputArray magnitude);</span><br>    Mat magnitudeImage = planes[<span class="hljs-number">0</span>];<br><br>    magnitudeImage += Scalar::all(<span class="hljs-number">1</span>);    <span class="hljs-comment">// M = log(1 + M)</span><br>    <span class="hljs-built_in">log</span>(magnitudeImage, magnitudeImage); <span class="hljs-comment">// 结果也储存在magnitudeImage中</span><br><br>    <span class="hljs-comment">// 若有奇数行、列，则进行裁剪（matlab里没做这步）</span><br>    magnitudeImage = magnitudeImage(Rect(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, magnitudeImage.cols &amp; <span class="hljs-number">-2</span>, magnitudeImage.rows &amp; <span class="hljs-number">-2</span>));<br><br>    <span class="hljs-comment">// 将频谱中心移至图像中心，显然比matlab要繁琐很多</span><br>    <span class="hljs-keyword">int</span> cx = magnitudeImage.cols / <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">int</span> cy = magnitudeImage.rows / <span class="hljs-number">2</span>;<br>    <span class="hljs-function">Mat <span class="hljs-title">q0</span><span class="hljs-params">(magnitudeImage, Rect(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, cx, cy))</span></span>;   <span class="hljs-comment">// 左上</span><br>    <span class="hljs-function">Mat <span class="hljs-title">q1</span><span class="hljs-params">(magnitudeImage, Rect(cx, <span class="hljs-number">0</span>, cx, cy))</span></span>;  <span class="hljs-comment">// 右上</span><br>    <span class="hljs-function">Mat <span class="hljs-title">q2</span><span class="hljs-params">(magnitudeImage, Rect(<span class="hljs-number">0</span>, cy, cx, cy))</span></span>;  <span class="hljs-comment">// 左下</span><br>    <span class="hljs-function">Mat <span class="hljs-title">q3</span><span class="hljs-params">(magnitudeImage, Rect(cx, cy, cx, cy))</span></span>; <span class="hljs-comment">// 右下</span><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    origin:</span><br><span class="hljs-comment">       q0 | q1</span><br><span class="hljs-comment">       q2 | q3</span><br><span class="hljs-comment">    new:</span><br><span class="hljs-comment">       q3 | q2</span><br><span class="hljs-comment">       q1 | q0</span><br><span class="hljs-comment">    */</span><br>    Mat temp;<br>    q0.copyTo(temp);  <span class="hljs-comment">// q0 -&gt; temp</span><br>    q3.copyTo(q0);    <span class="hljs-comment">// q3 -&gt; q0</span><br>    temp.copyTo(q3);  <span class="hljs-comment">// temp -&gt; q3  // 这种写法就很“面向对象”了，和之前写脚本语言的路数完全一样</span><br>    q1.copyTo(temp);<br>    q2.copyTo(q1);<br>    temp.copyTo(q2);<br><br>    <span class="hljs-comment">// 归一化</span><br>    normalize(magnitudeImage, magnitudeImage, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, NORM_MINMAX);  <span class="hljs-comment">// NORM_MINMAX = 32</span><br><br>    imshow(<span class="hljs-string">"DFT Image"</span>, magnitudeImage);<br>    waitKey(<span class="hljs-number">0</span>);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在一开始，把交换坐标象限的代码写成了这个样子</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++">Mat temp;<br>q0.copyTo(temp);<br>q3.copyTo(q0);<br>q0.copyTo(q3);<br>q1.copyTo(temp);<br>q2.copyTo(q1);<br>q1.copyTo(q2);<br></code></pre></td></tr></table></figure><p>这样的结果为</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*</span><br><span class="hljs-comment">origin:</span><br><span class="hljs-comment">   q0 | q1</span><br><span class="hljs-comment">   q2 | q3</span><br><span class="hljs-comment">new:</span><br><span class="hljs-comment">   q3 | q2</span><br><span class="hljs-comment">   q2 | q3</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h3 id="亮度对比度调整"><a href="#亮度对比度调整" class="headerlink" title="亮度对比度调整"></a>亮度对比度调整</h3><p>亮度、对比度调整在PS中倒是经常用，但是在之前写代码的时候，也就是调一下亮度，为了让边缘检测适应亮场、暗场。</p><p>作为点操作（仅通过输入图像的像素值便可计算相应输出图像的像素值），亮度和对比度之所以成对出现，因为可以写在同一个变换公式中</p><p>$$g(i,j) = a*(i,j) + b$$</p><p>其中，<code>a</code>用来控制对比度，<code>b</code>用来控制亮度。</p><p>具体代码如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;opencv2/core/core.hpp&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;opencv2/highgui/highgui.hpp&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> cv;<br><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">on_ContrastAndBright</span><span class="hljs-params">(<span class="hljs-keyword">int</span>, <span class="hljs-keyword">void</span>*)</span></span>;<br><br><span class="hljs-keyword">int</span> g_nContrastValue, g_nBrightValue;<br>Mat g_srcImage, g_dstImage;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    g_srcImage = imread(<span class="hljs-string">"C:/code/test.png"</span>);<br>    g_dstImage = Mat::zeros(g_srcImage.size(), g_srcImage.type());<br><br>    g_nContrastValue = <span class="hljs-number">80</span>;<br>    g_nBrightValue = <span class="hljs-number">80</span>;<br><br>    <span class="hljs-comment">// 创建结果窗口</span><br>    namedWindow(<span class="hljs-string">"效果图窗口"</span>, <span class="hljs-number">1</span>);<br><br>    createTrackbar(<span class="hljs-string">"对比度： "</span>, <span class="hljs-string">"效果图窗口"</span>, &amp;g_nContrastValue, <span class="hljs-number">300</span>, on_ContrastAndBright);<br>    createTrackbar(<span class="hljs-string">"亮度： "</span>, <span class="hljs-string">"效果图窗口"</span>, &amp;g_nBrightValue, <span class="hljs-number">200</span>, on_ContrastAndBright);<br><br>    <span class="hljs-comment">// 函数初始化</span><br>    on_ContrastAndBright(g_nContrastValue, <span class="hljs-number">0</span>);<br>    on_ContrastAndBright(g_nBrightValue, <span class="hljs-number">0</span>);<br><br>    <span class="hljs-comment">// 输入q时退出程序</span><br>    <span class="hljs-keyword">while</span> (<span class="hljs-keyword">char</span>(waitKey(<span class="hljs-number">1</span>) != <span class="hljs-string">'q'</span>)) &#123;&#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">on_ContrastAndBright</span><span class="hljs-params">(<span class="hljs-keyword">int</span>, <span class="hljs-keyword">void</span>*)</span></span><br><span class="hljs-function"></span>&#123;<br>    namedWindow(<span class="hljs-string">"原始图窗口"</span>, <span class="hljs-number">1</span>);<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> y = <span class="hljs-number">0</span>; y &lt; g_srcImage.rows; y++)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> x = <span class="hljs-number">0</span>; x &lt; g_srcImage.cols; x++)<br>        &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> planes = <span class="hljs-number">0</span>; planes &lt; <span class="hljs-number">3</span>; planes++)<br>            &#123;<br>                g_dstImage.at&lt;Vec3b&gt;(y, x)[planes] = saturate_cast&lt;uchar&gt;<br>                    ((g_nContrastValue * <span class="hljs-number">0.01</span>) * g_srcImage.at&lt;Vec3b&gt;(y, x)[planes] + g_nBrightValue);<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    imshow(<span class="hljs-string">"原始图窗口"</span>, g_srcImage);<br>    imshow(<span class="hljs-string">"效果图窗口"</span>, g_dstImage);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p>OpenCV与VapourSynth比较，虽然VapourSynth为处理视频提供了（面向视频的）高级API，但毕竟没有像OpenCV那样提供丰富的“半成品”函数，像扩充图像边界这样的操作要自己去写，反而体验到一些偏“底层”的东西。</p><p>顺带一提，刚刚会用了VS的“转到定义”功能，确实好方便。</p>]]></content>
    
    
    <categories>
      
      <category>图像处理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>OpenCV</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>从VC++ 6.0到VS——记一个简单窗口程序的迁移</title>
    <link href="/2019/12/27/Phase-trans-to-vs/"/>
    <url>/2019/12/27/Phase-trans-to-vs/</url>
    
    <content type="html"><![CDATA[<p>重新拾起大二时写过，或者说照着教材修改过的一份计算并绘制相图的代码。</p><p>讲道理，从功能上看，用C/C++来写似乎不是一个好的选择，没什么计算量，用Python应该会更简单一些（我仿佛又看到了一个坑…）。</p><p>印象中教程上的原始代码是用一门上古的C语言（变体？）写的，名字已经记不太清。当时是在机房装了那个语言的IDE，看着蓝屏一般的背景色和又大又复古的字体，幼小的我被吓坏了…</p><p>限于教学条件，那个时候自然是基于VC++ 6.0把代码重新改了一遍，然后就交作业了。分数还不错。</p><p>OK，回忆就到这里。昨天心血来潮，想在Visual Studio下重新跑一遍。于是…我就掉进了坑里…</p><h3 id="代码功能与现状"><a href="#代码功能与现状" class="headerlink" title="代码功能与现状"></a>代码功能与现状</h3><p>代码实现的功能其实简陋，执行一下，跳出来一个NiO-MgO固溶体相图的窗口，就完了。所以虽然是窗口程序，用户完全没法做什么。</p><p>代码方面，除了在现在看来中了毒一般的代码风格和陈旧的头文件，还隐藏着C++标准改变埋下的坑。</p><a id="more"></a><p>改代码风格不用多说，坑的在后面…</p><h3 id="适应VS"><a href="#适应VS" class="headerlink" title="适应VS"></a>适应VS</h3><h4 id="关于头文件"><a href="#关于头文件" class="headerlink" title="关于头文件"></a>关于头文件</h4><h5 id="graphics-h"><a href="#graphics-h" class="headerlink" title="graphics.h"></a><code>graphics.h</code></h5><p>代码使用了一个古老而且非标准的头文件，<code>graphics.h</code>。既然如此，随便搜了一个头文件就include了。然而…我下的这个头文件本身就有bug…</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> left=<span class="hljs-number">0</span>, <span class="hljs-keyword">int</span> right=<span class="hljs-number">0</span>, <span class="hljs-keyword">int</span> right=INT_MAX, <span class="hljs-keyword">int</span> bottom=INT_MAX,<br></code></pre></td></tr></table></figure><p>把前面那个<code>right</code>改成<code>top</code>，倒也不是什么大问题（反正全世界的图像处理都是这么搞的，从左和上开始定义）。</p><p>然后就是我下的这个<code>graphics.h</code>，和现有的代码八字不合…</p><p>比如，原始代码是这样写的</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">outtextxy(<span class="hljs-number">225</span>, <span class="hljs-number">220</span>, <span class="hljs-string">"TWO PHASE DLAGRAM\n"</span>);<br></code></pre></td></tr></table></figure><p>按照我下的头文件，第三个参数应当是<code>char *</code>类型，而这里填的<code>&quot;TWO PHASE DLAGRAM\n&quot;</code>是<code>cosnt char *</code>，用强制类型转换解决</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">outtextxy(<span class="hljs-number">225</span>, <span class="hljs-number">220</span>, (<span class="hljs-keyword">char</span>*)<span class="hljs-string">"TWO PHASE DLAGRAM\n"</span>);<br></code></pre></td></tr></table></figure><p>其余的问题后续再说，总之把类似上面头文件与代码不匹配的问题解决之后，我发现一个严重的事情…我下的这个头文件…仅有函数声明…没有函数定义…（此处应插入一个“你跟这开玩笑呢”的图片）。所以，理论上应该还有个lib库之类的东西…</p><p>（所以报了<code>LINK2019</code>错误）</p><p>算了…不折腾了…搜到了EasyX库，想起来当时在VC++ 6.0上用的也是这个。</p><p>配置好头文件和库文件，但略显蛋疼的是，一些绘图函数的参数类型又不一样了。重新改…</p><p>还是拿上面那个举例，EasyX库下的<code>graphics.h</code>需要<code>char</code>类型</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">outtextxy(<span class="hljs-number">225</span>, <span class="hljs-number">220</span>, (<span class="hljs-keyword">char</span>)<span class="hljs-string">"TWO PHASE DLAGRAM\n"</span>);<br></code></pre></td></tr></table></figure><p>（这样在指针间反复横跳…总感觉哪里不对劲…）</p><p>又比如</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">char</span> my[<span class="hljs-number">5</span>], mx[<span class="hljs-number">5</span>];<br>outtextxy(X1 + <span class="hljs-number">2</span> * i * xstep - <span class="hljs-number">10</span>, Y2 + <span class="hljs-number">10</span>, mx);<br></code></pre></td></tr></table></figure><p>而<code>outtextxy()</code>有两种重载形式</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">outtextxy</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y, LPCTSTR str)</span></span>;<span class="hljs-comment">// 在指定位置输出字符串</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">outtextxy</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y, TCHAR c)</span></span>;<span class="hljs-comment">// 在指定位置输出字符</span><br></code></pre></td></tr></table></figure><p>所以把原代码中的<code>char</code>类型强制转换为<code>LPCTSTR</code>类型。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">outtextxy(X1 + <span class="hljs-number">2</span> * i * xstep - <span class="hljs-number">10</span>, Y2 + <span class="hljs-number">10</span>, (LPCTSTR));<br></code></pre></td></tr></table></figure><p><code>LPCTSTR</code>类型先放一下，先说一下函数重载。</p><h5 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h5><p>度娘百科上说的还是挺清楚的。</p><blockquote><p>C++允许在同一范围中声明几个功能类似的同名函数， 形参需要不同。</p></blockquote><p>调用时会选择合适的函数进行调用。类似的还有运算符的重载，比如<code>&lt;&lt;</code>运算符，左移+输出。</p><p>函数重载这个概念在C++课上肯定是学过的，只是被课本和习题蒙蔽了，不知道是干什么的。在读Waifu2x的代码时，才发掘这是怎么一回事。</p><p>目的的话，为了方便吧，能想到的就是这个了。</p><h5 id="继续graphics-h"><a href="#继续graphics-h" class="headerlink" title="继续graphics.h"></a>继续<code>graphics.h</code></h5><p>有些函数变量的含义、个数都变了，照猫画虎地去改。</p><p>参照</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setlinestyle</span><span class="hljs-params">(<span class="hljs-keyword">int</span> style, <span class="hljs-keyword">int</span> thickness = <span class="hljs-number">1</span>, <span class="hljs-keyword">const</span> DWORD *puserstyle = <span class="hljs-literal">NULL</span>, DWORD userstylecount = <span class="hljs-number">0</span>)</span></span>;<span class="hljs-comment">// 设置当前画线样式</span><br></code></pre></td></tr></table></figure><p>将</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">setlinestyle(<span class="hljs-number">0</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>);  <span class="hljs-comment">//坐标轴几何参数</span><br></code></pre></td></tr></table></figure><p>改成</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">setlinestyle(<span class="hljs-number">0</span>, <span class="hljs-number">3</span>);  <span class="hljs-comment">//坐标轴几何参数</span><br></code></pre></td></tr></table></figure><p>以上这些绘图函数都是用来美化修饰的，其实参数含义什么的囫囵吞枣就可以，我也不是UI，但<code>initgrah()</code>这个函数还是要关注一下的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 绘图模式相关函数</span><br><span class="hljs-function">HWND <span class="hljs-title">initgraph</span><span class="hljs-params">(<span class="hljs-keyword">int</span> width, <span class="hljs-keyword">int</span> height, <span class="hljs-keyword">int</span> flag = <span class="hljs-literal">NULL</span>)</span></span>;<span class="hljs-comment">// 初始化图形环境</span><br></code></pre></td></tr></table></figure><p>上面是头文件中的声明，但我的原始代码画风有点不一样</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> gdriver = DETECT, graphmode;<br>initgraph(&amp;gdriver, &amp;graphmode, <span class="hljs-string">"E:\\TurboC3cn\\BGI"</span>);<br></code></pre></td></tr></table></figure><p>恕我孤陋寡闻，这样声明和初始化两个变量，真的是…</p><p>当初我改代码时，似乎也没有动这个地方…所以那个路径我当时是怎么编译通过的…orz…</p><p>按照度娘百科给的函数原型，应该更符合原始代码（因为度娘的词条似乎就是针对（原始的）<code>graphics.h</code>写的，而相比我用的EasyX库，至少对于针对VS2019版本的头文件，是不一样的）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> far <span class="hljs-title">initgraph</span><span class="hljs-params">(<span class="hljs-keyword">int</span> far *gdriver, <span class="hljs-keyword">int</span> far *gmode, <span class="hljs-keyword">char</span> *path)</span></span>;<br></code></pre></td></tr></table></figure><p>嘛…不管了，反正就依照我现在用的头文件，把参数改一下，现在的参数含义还更好理解。</p><p>关于<code>_T(&quot;黑体&quot;)</code>的问题，似乎是解决了，这个没细看。</p><h5 id="stdafx-h"><a href="#stdafx-h" class="headerlink" title="stdafx.h"></a><code>stdafx.h</code></h5><p>这个<code>stdafx.h</code>不用管…注释掉就行…</p><h4 id="C-标准的升级"><a href="#C-标准的升级" class="headerlink" title="C++标准的升级"></a>C++标准的升级</h4><p>我用的VS2019是支持c++14和c++17（虽然我还没搞明白默认的是哪个），有些陈旧的函数会报<code>C4996</code>错误，照着改就行。</p><p><code>getch()</code> -&gt; <code>_getch()</code><br><code>gcvt()</code> -&gt; <code>_gcvt()</code> -&gt; <code>_gcvt_s()</code></p><h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p>好像也就这么多了。虽然画出来的图还不正常…但至少不报错了…</p><p>上午改代码的时候，真有一种代码被下了毒的感觉…</p><p>收获有三点吧。</p><ul><li>理解了头文件、库文件的依赖关系。目前来看，对于稍大型的代码，是在头文件中写函数声明，然后把函数实现放在库文件中。在VS中的配置也更加熟练了（头文件位于<code>\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\xxxx\include</code>之类的地方）。</li><li>明白了函数重载</li><li>关于<code>char</code>和<code>string</code>等类型的关系和转换</li></ul><p>但代码中仍有一些地方值得我去看，比如<code>extern</code>。</p>]]></content>
    
    
    <categories>
      
      <category>Code</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>周记 2019.12.16-12.22</title>
    <link href="/2019/12/22/week-201912-3/"/>
    <url>/2019/12/22/week-201912-3/</url>
    
    <content type="html"><![CDATA[<h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>不写点东西督促，日子真的会从指尖溜走。但写日记…一方面真的是不一定保证能每天都写，另一方面，毕竟学业上还有其他的事情，有时候一天学到的东西也没多少可写。</p><p>总之，把日记改成周记吧。</p><p><del>还是别用“周报”这个字眼了2333</del></p><h3 id="对JincResize的完善"><a href="#对JincResize的完善" class="headerlink" title="对JincResize的完善"></a>对JincResize的完善</h3><h4 id="发布r4：添加32bit支持"><a href="#发布r4：添加32bit支持" class="headerlink" title="发布r4：添加32bit支持"></a>发布r4：添加32bit支持</h4><p>详情写在<a href="https://kiyamou.github.io/2019/11/24/rebuild-JincResize/" target="_blank" rel="noopener">JincResize代码的重构</a>，这里就不再copy了。</p><p>要是再补充一句的话，就是多个分支的if语句的写法，之前用Python时只写过<code>if else</code>和<code>if elif</code>，没有把三者写在一起过…没错…我的基础知识实在是匮乏得可怜。</p><a id="more"></a><p>在C++中</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">if</span> ()<br>...<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ()<br>...<br><span class="hljs-keyword">else</span><br>...<br></code></pre></td></tr></table></figure><p>在Python中</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">if</span> ...:<br>...<br><span class="hljs-keyword">elif</span> ...:<br>...<br><span class="hljs-keyword">else</span>:<br>...<br></code></pre></td></tr></table></figure><h4 id="提高安全性，修正输入变量的类型转换"><a href="#提高安全性，修正输入变量的类型转换" class="headerlink" title="提高安全性，修正输入变量的类型转换"></a>提高安全性，修正输入变量的类型转换</h4><p>代码中的面向Python接口的int型输入参数，有些是直接用<code>(int)</code>做了一次强制类型转换，有些则干脆什么都没有写。</p><p>统一修改成了<code>VSHelper.h</code>中的<code>int64ToIntS()</code>。</p><h4 id="在提高速度的边缘反复挣扎"><a href="#在提高速度的边缘反复挣扎" class="headerlink" title="在提高速度的边缘反复挣扎"></a>在提高速度的边缘反复挣扎</h4><p>论如何更快地做double到int的转换<br><del>然而我没感到有卵用，特别是定义函数后似乎没有内联，反而由于调用函数的成本让速度更慢了</del></p><p>但话说回来，从这里我感受到了编程的奇妙，正如看到的一篇博文中所说，“螺蛳壳里做道场，一行代码有学问”。</p><p>而这也让我切实地感受到，我的编程功底在提升。</p><h3 id="从Tensorflow到Paddle"><a href="#从Tensorflow到Paddle" class="headerlink" title="从Tensorflow到Paddle"></a>从Tensorflow到Paddle</h3><p>额…这个标题起得太大了，只是把一些Tensorflow的函数用Paddle的代替。</p><p>（话说这和我现在做的AviSynth到VapourSynth的迁移不正是很像吗，都是从一个框架到另一个框架的迁移）</p><h3 id="AreaResize的迁移"><a href="#AreaResize的迁移" class="headerlink" title="AreaResize的迁移"></a>AreaResize的迁移</h3><p>从D9上找到一个尚未被前辈迁移到vs的avs plugin，开始迁移，作为练习。</p><p>周四周五下午，和周六一天，基本上都在做基础的迁移（搭框架、改写不一样的C++后端函数、<del>人工copy代码</del>）。说实话，看着400+行的代码，还是很满意这几天的工作的。</p><p>虽然周日从文本编辑器到IDE后，望着<code>80+</code>+<code>20+</code>的error，让我有种写了两天bug的感觉。</p><h3 id="日常生活"><a href="#日常生活" class="headerlink" title="日常生活"></a>日常生活</h3><p>把超期半年多的书还回了图书馆，借了两本和并行计算相关的书，外加我之前借过的数字图像处理。</p><p>我只是想看看和AVX/SSE指令集优化相关的，但..那两本书讲得也是…比较宏观，甚至让我有种上并行计算课的感觉。而搜索网上的教程，也不知从何下手，似乎最直接地，还是死磕现有的代码…</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>图像处理中一些稍底层的东西：色彩空间与数据结构</title>
    <link href="/2019/12/18/image-process-code-1/"/>
    <url>/2019/12/18/image-process-code-1/</url>
    
    <content type="html"><![CDATA[<h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>接触图像处理也有两年了，如果算上大二时H老师的课，甚至有三年多了。我真的很想“上岸”，而不是流于表面，只学到花拳绣腿。</p><p>色彩空间是最基础的概念，当然谈不上“底层”。但和色彩空间相关联的、图像的像素点是以和何种方式储存的，换句话说，数字图像的数据结构是怎样的，应当称得上是从表面到深入的一个转折点了。学数字图像处理，当然不能满足于<code>output = intput.filter()</code>这样的模式。</p><p><em>引言写于2020.1.3</em></p><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p><em>修改于2020.1.2</em></p><h4 id="二维图像与一维数组"><a href="#二维图像与一维数组" class="headerlink" title="二维图像与一维数组"></a>二维图像与一维数组</h4><p>在AviSynth和VapourSynth中，单帧图像的像素按行储存，从图像的左上开始，一行一行地存储于一维数组中，像下面这样。</p><p>——————————&gt;<br>——————————&gt;<br>……<br>——————————&gt;</p><p>所以读取/写入下一个像素，依据行列的不同，分两种情况，大概是这样</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 对于YUV格式图像</span><br><span class="hljs-keyword">const</span> T* srcp = <span class="hljs-keyword">reinterpret_cast</span>&lt;<span class="hljs-keyword">const</span> T*&gt;(vsapi-&gt;getReadPtr(src, plane)); <span class="hljs-comment">// 创建指针</span><br><span class="hljs-keyword">int</span> src_stride = vsapi-&gt;getStride(src, plane) / <span class="hljs-keyword">sizeof</span>(T);                 <span class="hljs-comment">// 获取stride</span><br>srcp++;              <span class="hljs-comment">// 读取同行下一个像素</span><br>srcp += src_stride;  <span class="hljs-comment">// 读取同列下一个元素</span><br></code></pre></td></tr></table></figure><a id="more"></a><p>至于<code>stride</code>，在avs中习惯写作<code>pitch</code>。详情看下面，大概两个星期前写的（当时还处于囫囵吞枣的模式）。</p><h4 id="关于stride与pitch"><a href="#关于stride与pitch" class="headerlink" title="关于stride与pitch"></a>关于<code>stride</code>与<code>pitch</code></h4><blockquote><p>继续读VapourSynth滤镜的代码，这次看<code>Deblock()</code>，和相应的AviSynth代码一起看的。这种同为C++语言，但调用了不同的API，比之前使用同一个API完成从C到C++的迁移，又是另一种感觉。</p><p>但直观上来看，使用AviSynth API，感觉代码要短一些…</p></blockquote><p>回到正题，不仅是在vs和avs框架下，在更一般的图像处理中，经常能够看到带有<code>pitch</code>的变量。</p><p>之前就查过，说是在处理图像时，会以4为单位存储，以提高硬件效率（若以3等比4更小的方式存储，反而会降低效率），所以会用<code>pitch</code>变量实现上述存储方式。</p><p>云里雾里地，不知道在说什么。这次看<code>Deblock()</code>的代码，因为涉及了判断块是否要被处理，类似下面的语句。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++">T * VS_RESTRICT sq0 = dstp1;<br><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">std</span>::<span class="hljs-built_in">abs</span>(sq0[i] - sq[i]) &lt; alpha) &#123;<br>    ...<br>&#125;<br><br>srcp += src_pitch<br></code></pre></td></tr></table></figure><p>看了上面这样的代码，似乎明白很多了，带有<code>pitch</code>的变量就是和内存/储存相关的（“单位内存”），<code>srcp</code>（或<code>dstp</code>）加上一个“单位内存”（并放到for循环中），就是这里已经处理过了，到下一个单位去。</p><blockquote><p>虽然我上面糊里糊涂说了一堆，可能我自己也不明白，但就代码部分而言，真的让我有种《21天实战Caffe》里提到的“阅读源码自由”的感觉。</p></blockquote><p>上面便是两个星期前写的，虽然云里雾里，但应该是说对了意思。然后翻了翻前两天写的<a href="https://kiyamou.github.io/2020/01/01/ported-to-vs-2/" target="_blank" rel="noopener">记一次从AviSynth到VapourSynth的迁移——感受不同的API（二）</a>，理解上又近了一步，但还是没说完全。那篇博文中只说了以下四者单位已经过转换，可以直接在数值上比较。</p><ul><li>VapourSynth中除过<code>sizeof(T)</code>的<code>stride</code></li><li>AviSynth中默认来自8bit图像的<code>pitch</code></li><li>VapourSynth中一般意义上的<code>width</code></li><li>AviSynth中由<code>GetRowSize()</code>得到的<code>width</code></li></ul><p>但我当时没明白一点，其实<code>width</code>和除过<code>sizeof(T)</code>的<code>stride</code>（包括<code>pitch</code>），在数值上是近似相等的。<code>stride</code>直译过来是跨度，而基于“二维图像按行储存于一维数组”的数据结构，所谓跨度，就是宽度，所谓内存上的跨度，就是乘上变量类型所占字节的宽度。</p><p>一开始在读avs版AreaResize源码时，看到<code>dstp += target_width</code>惊呆了，心想还能直接加上宽度。其实，我更早之前遇见的<code>dstp += dst_stride</code>和<code>dstp[y + x * dst_stride]</code>，和直接加宽度都是差不多的，都是为了将指针移动到同列的下一个元素。</p><p>顺带，补充一下C++的基础知识。指针的加法，如</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">double</span> point[<span class="hljs-number">5</span>];<br><span class="hljs-keyword">double</span>* p = point;<br>p += <span class="hljs-number">2</span>;<br></code></pre></td></tr></table></figure><p>等于指针移动<code>sizeof(double)*2</code>个单位。</p><p>同时，这个例子还说明了，可以将数组名赋值给指针，其指向数组的第一个元素。</p><p><em>2020.1.3补充：其实这只是YUV格式的一种储存方式，是我在VapourSynth与AviSynth中常见的方式。但其实还有其他的方式，顺带整理RGB的储存方式。在这之前，需要先补充一些基础概念，恰好最初写这篇Blog时，就写了这些概念。</em></p><h3 id="一些基础概念"><a href="#一些基础概念" class="headerlink" title="一些基础概念"></a>一些基础概念</h3><p>本以为我摸爬滚打这么长时间，就算不太懂代码，一些基础知识总该没问题吧…但是…关于色彩空间，有些别名还是记不住。</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">YV24</span>  = YUV444<br><span class="hljs-attr">YV16</span>  = YUV422<br><span class="hljs-attr">YV12</span>  = YUV420<br><span class="hljs-attr">YV411</span> = YUV411<br><span class="hljs-attr">RGB24</span> = <span class="hljs-number">8</span>bit<br><span class="hljs-attr">RGB32</span> = <span class="hljs-number">8</span>bit（含透明通道）<br></code></pre></td></tr></table></figure><p>顺带一提，在vs中，由一般的10bit，会得到RGB30，一般的16bit，则得到RGB48。</p><h3 id="继续数据结构"><a href="#继续数据结构" class="headerlink" title="继续数据结构"></a>继续数据结构</h3><h4 id="概述与补充"><a href="#概述与补充" class="headerlink" title="概述与补充"></a>概述与补充</h4><p>无论是YUV还是RGB格式，都有两类存储方式，planar和packed，后者在我目前所接触到的代码中，更习惯写作interleave。</p><p>planar直译是平面，就是我所习惯的平面的概念，Y、U、V、R、G、B各作为一个平面。先把一个平面的数据/像素点全存储下来，再去存储下个平面的。我在前面小节提到的数据结构，便属于这类。</p><p>packed/interleave，我肯定是对interleave更熟悉，这个单词对应着另一个图像处理的概念，隔行。当然这里并不是讨论逐行隔行的问题。packed/interleave表示同一个像素点不同平面的数据连续存储，这就导致不同平面的数据是间隔存储的，interleave便取此意。</p><p>更详细的内容，随手一搜就有丰富的资料，比如<a href="https://www.cnblogs.com/azraelly/archive/2013/01/01/2841269.html" target="_blank" rel="noopener">图文详解YUV420数据格式</a>。我这里写一下这几天写代码时，遇到相关问题。YUV格式已经在上面小节说过了，补充一句的就是，我所熟悉的<code>YUV420P</code>的p，应该不是process，而是planar。</p><h4 id="RGB格式"><a href="#RGB格式" class="headerlink" title="RGB格式"></a>RGB格式</h4><p>下面写一下RGB格式。</p><p>在avs中，似乎是RGB interleave更推崇一点，似乎avs内部用的就是这种方式？因为我在一份plugin源码中没看到额外的处理。而与之对比的是，我在读vs的waifu2x-caffe源码时，发现RGB输入被手动转换成了interleave形式。</p><p>另外我还需知道一个问题：在OpenCV中RGB格式是按BGR顺序存储数据的；avs似乎也是这样，或者说习惯是这样；而vs我还没搞明白，直观上觉得还是用的RGB顺序。</p><h3 id="一个直观的问题"><a href="#一个直观的问题" class="headerlink" title="一个直观的问题"></a>一个直观的问题</h3><p>在缩小时，插值算法做了什么</p><p>可以看一下<a href="https://stackoverflow.com/questions/875856/interpolation-algorithms-when-downscaling" target="_blank" rel="noopener">这个回答</a></p><blockquote><p>无论是放大还是缩小，正在进行的“插值”实际上都是在重新采样。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>图像处理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>VapourSynth</tag>
      
      <tag>Avisynth</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>日记 2019.12.14</title>
    <link href="/2019/12/14/day-191214/"/>
    <url>/2019/12/14/day-191214/</url>
    
    <content type="html"><![CDATA[<h3 id="1"><a href="#1" class="headerlink" title="1"></a>1</h3><p>继续基础知识</p><p>“C++ 不允许返回一个完整的数组作为函数的参数。 但可以定义指针函数。”</p><p>“C++ 不支持在函数外返回局部变量的地址，除非定义局部变量为 <strong>static</strong> 变量。”</p><h3 id="2"><a href="#2" class="headerlink" title="2"></a>2</h3><p>开始刷洛谷…明明是给中学生做的题…</p><p>也开始Leetcode，但感觉有点难…</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>日记 2019.12.13</title>
    <link href="/2019/12/14/day-191213/"/>
    <url>/2019/12/14/day-191213/</url>
    
    <content type="html"><![CDATA[<h3 id="1-飞浆开始"><a href="#1-飞浆开始" class="headerlink" title="1 飞浆开始"></a>1 飞浆开始</h3><p>看了一下paddlepaddle Fluid的教材，买书时没细看，发现是百度大佬自己写的。</p><p>感觉和Caffe好像，无论是block、program等逻辑/数据结构，还是具体的<code>.proto</code>储存格式。</p><p>LoD Tensor的概念倒是很新鲜，之前看Caffe和Pytorch，不知是我没细看还是怎么，感觉都没有类似的概念。</p><p>而Python前端+C++后端这种模式，也让人觉得很亲切。我甚至有点写这种Python“前端”了。</p><h3 id="2-Next"><a href="#2-Next" class="headerlink" title="2 Next"></a>2 Next</h3><p>既然是将算法复现，那我趁热把熟悉的手写数字识别和之前大作业的文章内容理解拿过来用一下。</p><a id="more"></a><h3 id="3"><a href="#3" class="headerlink" title="3"></a>3</h3><p>日记嘛，说一点湿的。</p><p>开始写文档时，感觉真有些累。经历白天的看C++，晚上写文档，之后再看paddle，这种思维的转换感觉很不错。</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>日记 2019.12.12</title>
    <link href="/2019/12/12/day-191212/"/>
    <url>/2019/12/12/day-191212/</url>
    
    <content type="html"><![CDATA[<h4 id="1"><a href="#1" class="headerlink" title="1"></a>1</h4><p>用<code>malloc</code>分配内存</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">double</span>* lut = (<span class="hljs-keyword">double</span>*) <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">double</span>)*d.samples);<br></code></pre></td></tr></table></figure><p><code>sizeof(double)</code>=8</p><h4 id="2"><a href="#2" class="headerlink" title="2"></a>2</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">data = <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(d));<br></code></pre></td></tr></table></figure><p>而我修改后，直接省去了<code>data</code>这个变量，因为看不到有什么用。（或许是，我修改后的代码，因为使用了智能指针，所以不需要<code>data</code>做某种辅助？）</p><p><strong>PS</strong>：在HomeOfVapourSynthEvolution的Curve.cpp，能看到这种“成对”的模式，用<code>malloc</code>和<code>calloc</code>来分配内存的变量都用<code>free</code>做了释放。相比之下，我自己该的代码，在新定义<code>lut</code>这个变量时，用了<code>malloc</code>，却没有用<code>free</code>，而是用<code>delete</code>去删除的。</p><p><code>delete</code>不仅释放内存，而且会调用析构函数，而<code>free</code>不会调用析构函数。</p><a id="more"></a><p>Curve.cpp的代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">double</span> (*matrix)[<span class="hljs-number">3</span>] = <span class="hljs-keyword">reinterpret_cast</span>&lt;<span class="hljs-keyword">double</span>(*)[<span class="hljs-number">3</span>]&gt;(<span class="hljs-built_in">calloc</span>(n, <span class="hljs-keyword">sizeof</span>(*matrix)));<br><span class="hljs-keyword">double</span> * h = <span class="hljs-keyword">reinterpret_cast</span>&lt;<span class="hljs-keyword">double</span> *&gt;(<span class="hljs-built_in">malloc</span>((n - <span class="hljs-number">1</span>) * <span class="hljs-keyword">sizeof</span>(*h)));<br><span class="hljs-keyword">double</span> * r = <span class="hljs-keyword">reinterpret_cast</span>&lt;<span class="hljs-keyword">double</span> *&gt;(<span class="hljs-built_in">calloc</span>(n, <span class="hljs-keyword">sizeof</span>(*r)));<br><span class="hljs-keyword">if</span> (!matrix || !h || !r)<br>    <span class="hljs-keyword">throw</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&#123; <span class="hljs-string">"malloc failure (matrix/h/r)"</span> &#125;;<br><br><span class="hljs-built_in">free</span>(matrix);<br><span class="hljs-built_in">free</span>(h);<br><span class="hljs-built_in">free</span>(r);<br></code></pre></td></tr></table></figure><p>我自己的代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">double</span>* lut = <span class="hljs-keyword">reinterpret_cast</span>&lt;<span class="hljs-keyword">double</span>*&gt;(<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">double</span>) * d-&gt;samples));<br><br><span class="hljs-keyword">delete</span> d-&gt;lut;<br></code></pre></td></tr></table></figure><p>如知乎上所说，可以把<code>delete</code>看成做了两件事，一是<code>free</code>，另一是调用析构。</p><p>根据<a href="https://juejin.im/post/5d4c1f18e51d4562132030cb" target="_blank" rel="noopener">这篇博文</a>测试的代码，得出“new 和 delete，malloc 和 free 只能匹配使用，不能混用”。</p><p>虽然这么说，但我想了一会，还是说不出，把我现有代码中的<code>delete d-&gt;lut;</code>改成<code>free(d-&gt;lut)</code>的理由…emm先不管了，我记得之前测试过这两种代码，似乎也没么（速度上的）区别…先这样吧…</p><h4 id="3"><a href="#3" class="headerlink" title="3"></a>3</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-built_in">free</span>(d-&gt;lut);<br><span class="hljs-built_in">free</span>(d);<br></code></pre></td></tr></table></figure><p>是不是要这么理解：<code>free</code>和<code>malloc</code>是成对出现的，因为用了两次<code>malloc</code>，所以就要有两次<code>free</code>。</p><h4 id="4"><a href="#4" class="headerlink" title="4"></a>4</h4><p>以下笔记照抄自<a href="https://www.runoob.com/w3cnote/cpp-static-usage.html" target="_blank" rel="noopener">菜鸟教程</a>。</p><p>“类声明只声明一个类的”尺寸和规格”，并不进行实际的内存分配”</p><p>“static 被引入以告知编译器，将变量存储在程序的静态存储区而非栈上空间”</p><p>“static 修饰全局变量的时候，这个全局变量只能在本文件中访问，不能在其它文件中访问”</p><h4 id="5"><a href="#5" class="headerlink" title="5"></a>5</h4><p>从<code>malloc</code>可分配的最大内存，看似去与<code>size_t</code>相关，到一些关于<code>size_t</code>的基础知识。</p><p>涉及到<code>uintptr_t</code>类型。</p><p>在<a href="https://blog.csdn.net/cs_zhanyb/article/details/16973379" target="_blank" rel="noopener">这篇博客</a>中讲得清楚，<code>uintptr_t</code>是类型别名。</p><p>具体的定义如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Types for `void *' pointers.  */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> __WORDSIZE == 64</span><br><span class="hljs-meta"># <span class="hljs-meta-keyword">ifndef</span> __intptr_t_defined</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">int</span>            <span class="hljs-keyword">intptr_t</span>;<br><span class="hljs-meta">#  <span class="hljs-meta-keyword">define</span> __intptr_t_defined</span><br><span class="hljs-meta"># <span class="hljs-meta-keyword">endif</span></span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">int</span>   <span class="hljs-keyword">uintptr_t</span>;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span><br><span class="hljs-meta"># <span class="hljs-meta-keyword">ifndef</span> __intptr_t_defined</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">int</span>                 <span class="hljs-keyword">intptr_t</span>;<br><span class="hljs-meta">#  <span class="hljs-meta-keyword">define</span> __intptr_t_defined</span><br><span class="hljs-meta"># <span class="hljs-meta-keyword">endif</span></span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span>        <span class="hljs-keyword">uintptr_t</span>;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br></code></pre></td></tr></table></figure><p>可以看到，<code>unintptr_t</code>是类型<code>unsigned long int</code>（64bit）和<code>unsigned int</code>（32bit）的别名。</p><p><strong>PS</strong>：再回到修改代码的起点，看一下<code>uint8_t</code>和<code>uint16_t</code>等的定义（来自stdint.h）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span>           <span class="hljs-keyword">uint8_t</span>;  <br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">short</span> <span class="hljs-keyword">int</span>      <span class="hljs-keyword">uint16_t</span>;  <br><span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> __uint32_t_defined  </span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span>            <span class="hljs-keyword">uint32_t</span>;  <br><span class="hljs-meta"># <span class="hljs-meta-keyword">define</span> __uint32_t_defined  </span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span>  </span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> __WORDSIZE == 64  </span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">int</span>       <span class="hljs-keyword">uint64_t</span>;  <br><span class="hljs-meta">#<span class="hljs-meta-keyword">else</span>  </span><br>__extension__  <br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">int</span>  <span class="hljs-keyword">uint64_t</span>;<br></code></pre></td></tr></table></figure><p>由上可知，<code>uint8_t</code>对应<code>char</code>类型，长度为1字节，<code>uint16_t</code>对应<code>short int</code>类型，长度为2字节。</p><p>在实际代码中，二者分别对应8bit图像和16bit图像（或者说9~16bit图像）。</p><p>现在我需要回答一个问题，这样用不同类型/长度的变量去储存图像，究竟只是为了节省内存，还是必要之举？（我在测试用<code>uint16_t</code>类型变量储存8bit图像时，输出的图像是错误的，这样来看是必要的，但原理呢？为什么10bit图像就没事？-&gt;是否是对于10bit图像，有某种填0的机制？而8bit就会有内存越界的问题？）</p><h4 id="6-数组与指针的区别"><a href="#6-数组与指针的区别" class="headerlink" title="6 数组与指针的区别"></a>6 数组与指针的区别</h4>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>日记 2019.12.11</title>
    <link href="/2019/12/11/day-191211/"/>
    <url>/2019/12/11/day-191211/</url>
    
    <content type="html"><![CDATA[<p>如果不靠一个类似写日记的方法督促我学习，恐怕这学生阶段最后的时光也要溜走了…</p><h3 id="First"><a href="#First" class="headerlink" title="First"></a>First</h3><p>《深入理解C指针》收到了，粗看了一下，收获确实很多，只是我看书的效率有点低啊…不过幸好有之前改代码的经验，配合着看，这样想似乎效率还可以。</p><h3 id="Second"><a href="#Second" class="headerlink" title="Second"></a>Second</h3><p>emmm好像没有了，实验要明天才能进行下一步，至于刚看到的竞赛…emmm我早就不是十五岁的少年了，但看到这个竞赛，还是本能地激动。嘛~这样也好，整体死气沉沉地也不行。</p><p>不过，必须冷静地看到，竞赛…应当算是一个调剂吧。我知道自己处在什么水平，不要自负也不要自卑，更不要陷入自负与自备的交织中。</p><p>中午装好了框架，算是一个开头吧。</p><a id="more"></a><h3 id="Third"><a href="#Third" class="headerlink" title="Third"></a>Third</h3><p>这个12月，核心还是提升C++，快点做实验，然后能用MD画图就画一下，其余地尚不是重点。</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Windows下使用gcc/g++编译器</title>
    <link href="/2019/11/25/gcc-use-1/"/>
    <url>/2019/11/25/gcc-use-1/</url>
    
    <content type="html"><![CDATA[<h3 id="MSVC：从入门到放弃"><a href="#MSVC：从入门到放弃" class="headerlink" title="MSVC：从入门到放弃"></a>MSVC：从入门到放弃</h3><p>从一开始修改JincResize代码到现在，代码编译后dll运行缓慢的问题一直困扰着我。虽然原作者说运行速度慢，但我自己编译的也太慢了（1.5s vs 9s）。改了一些代码（主要是涉及C语言和C++的区别），但对速度无肉眼可见的影响。这样下去，代码重构也没有动力。</p><p>思考了一下，做了一下对照实验。使用原作者代码，直接在VS2019中编译（除了为在VS2019中编译通过，修改了一处代码外，其余代码均未改动），也很慢，也是约9s/帧。这样让我明确了一点，就是编译方面的问题，导致运行速度缓慢的。</p><p>我又仿照HomeOfVapourSynthEvolution的预处理设置，并在编译中尽量使用加快代码速度的优化参数，但最终的编译结果仍没有什么改善。</p><p>所以我有理由判断，是编译器的锅。（也许是现在的代码，虽然做了从C到C++的迁移，但仍有C的风格，导致和VS的纯C++编译器八字不合？）</p><p>不管怎么说，改用gcc/g++。</p><a id="more"></a><h3 id="使用gcc编译C语言代码"><a href="#使用gcc编译C语言代码" class="headerlink" title="使用gcc编译C语言代码"></a>使用gcc编译C语言代码</h3><p>前两天用了一次gcc编译C语言代码，但不知道怎么自行设置头文件和库文件路径，所以就放弃了。</p><p>今天明白了，库文件不一定需要，而反正我所需要的头文件就两个，直接复制过来就好了。</p><p>直接编译原作者代码。</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey">gcc -o ew<span class="hljs-built_in">a_lanczos</span>.dll -shared ew<span class="hljs-built_in">a_lanczos</span>.c<br></code></pre></td></tr></table></figure><p>能编译通过，但VapourSynth中无法调用。想了一下，这里的gcc是32位，和64位的VapourSynth不搭，于是换用64位的gcc，并打开<code>-O2</code>优化。</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey">x86_64-w64-mingw32-gcc -o ew<span class="hljs-built_in">a_lanczos</span>.dll -shared -O2 ew<span class="hljs-built_in">a_lanczos</span>.c<br></code></pre></td></tr></table></figure><p>VapourSynth成功运行，而且速度也和原作者的差不多了！Dll体积也差不多，<del>我感觉原作者就是这么编译的</del>。</p><h3 id="使用g-编译C-代码"><a href="#使用g-编译C-代码" class="headerlink" title="使用g++编译C++代码"></a>使用g++编译C++代码</h3><h4 id="动态编译"><a href="#动态编译" class="headerlink" title="动态编译"></a>动态编译</h4><p>虽说gcc也不是不能编译C++，但毕竟…还是用专业的g++吧。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">x86_64-w64-mingw32-g++ -shared -o <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">JincResize</span>.</span></span>dll -O2 <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">JincResize</span>.</span></span>cpp<br></code></pre></td></tr></table></figure><p>编译出来的dll，VapourSynth无法调用。我怀疑是没有配置库文件的锅，因为在CSDN上看到<a href="https://blog.csdn.net/jmppok/article/details/17118669" target="_blank" rel="noopener">一篇博文</a>，说需要库文件却没有配置时，这样也能编译通过、不报错。也就是默认编译模式下，看不见缺失库文件的问题</p><p>于是我照这篇博文的方法，加上了<code>-Wl,--no-undefined</code>参数，这样就能暴露缺失库文件问题。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">x86_64-w64-mingw32-g++ -o <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">JincResize</span>.</span></span>dll -shared -O2 -Wl,--no-undefined <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">JincResize</span>.</span></span>cpp<br></code></pre></td></tr></table></figure><p>但我试了一次，仍没有报错，正常地编译通过。</p><p>在<a href="http://turbinee.blog.sohu.com/271861881.html" target="_blank" rel="noopener">这篇博文</a>的帮助下，我明白了g++是动态编译，编译好的dll依赖于其他dll。想起了之前<a href="https://kiyamou.github.io/2019/10/20/mxnet-install-win/" target="_blank" rel="noopener">安装MXNet的踩坑经历</a>，（<del>我也能自引了</del>，积累是有用的）。使用Visual Studio的dumpbin工具查到了依赖的两个dll。</p><p>但与博文中把dll放到程序目录就OK不同的是，这两个dll我无论是放到VapourSynth的文件（VapourSynth下各种文件夹都试过了），还是<code>System32</code>中，都依然无法调用我编译的dll。只得另寻他法。</p><p>（况且就算这种方法能行，我也不能这么干，我不可能在发布时再“顺带”发布两个依赖，这也太蛋疼了）</p><h4 id="静态编译"><a href="#静态编译" class="headerlink" title="静态编译"></a>静态编译</h4><p><a href="https://blog.csdn.net/houjin_cn/article/details/37507781" target="_blank" rel="noopener">这篇博文</a>告诉我，可以通过静态编译的方式避免上述依赖的问题。</p><p>只加上<code>-static-libgcc</code>和<code>-static-libstdc++</code>这两个参数，还是不行。于是干脆使用<code>-static</code>，全局静态编译。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">x86_64-w64-mingw32-g++ -shared -o <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">JincResize</span>.</span></span>dll -O2 -static <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">JincResize</span>.</span></span>cpp<br></code></pre></td></tr></table></figure><p>终于成功了。（dll大小：63kb -&gt; 415kb -&gt; 451kb）</p><p>Dll运行速度也是和原作者的相似（所以我增加模板函数和其他修改并没有拖垮速度嘛）。</p><p>这样后续的代码重构也有动力了！</p><h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>这半天加晚上的折腾过程，从一开始的毫无头绪，到折腾CodeBlocks和MinGW，从第一次使用gcc编译成功C语言代码、获得能用的dll，到动态编译C++虽缺少依赖，但能平静地寻找解决办法。真的是很棒的经历。</p><p>加油吧，相信自己。</p>]]></content>
    
    
    <categories>
      
      <category>工具使用</category>
      
    </categories>
    
    
    <tags>
      
      <tag>构建与编译</tag>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JincResize 代码重构（1）</title>
    <link href="/2019/11/24/rebuild-JincResize/"/>
    <url>/2019/11/24/rebuild-JincResize/</url>
    
    <content type="html"><![CDATA[<p>前一篇Blog记录了将原作者代码（初步）从C语言迁移到C++上的过程，以及添加8bit输入支持的方法。下一步我想模仿HomeOfVapourSynthEvolution的代码风格，对上述代码进行重构。同时，也期待能发现，我先前修改的代码运行缓慢的原因。</p><p>Blog写得详细一些，这也是我学习C++基础知识的过程。</p><h3 id="未完成的C语言到C-迁移"><a href="#未完成的C语言到C-迁移" class="headerlink" title="未完成的C语言到C++迁移"></a>未完成的C语言到C++迁移</h3><p>其实C语言和C++的区别还有很多。</p><h4 id="C-的类型转换"><a href="#C-的类型转换" class="headerlink" title="C++的类型转换"></a>C++的类型转换</h4><p>编写VapourSynth插件，在四个<code>VS__CC</code>函数的开头，都需要进行类型转换，原始代码使用C语言风格的类型转换，类似下面这样。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">FilterData* d = (FilterData*)* instanceData;<br></code></pre></td></tr></table></figure><p>如果让代码“更C++”一些，则使用类型转换运算符（Type Conversion Operator）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">FilterData* d = <span class="hljs-keyword">static_cast</span>&lt;FilterData*&gt;(*instanceData);<br></code></pre></td></tr></table></figure><a id="more"></a><p>对于<code>filterInit ()</code>、<code>filterGetFrame()</code>、<code>filterFree()</code>三个函数，使用<code>static_cast</code>进行转换。<code>static_cast</code>用于相关类型的指针之间的转换。</p><p>对于<code>filterCreate()</code>函数，使用<code>reinterpret_cast</code>进行类型转换。无论类型是否相关，<code>reinterpret_cast</code>均可进行（强制）类型转换，是最接近C语言风格的类型转换运算符。</p><p>However，上述改动对运行速度无可见影响（想一下也知道，使用类型转换运算符或许可以让代码更安全，但并没有涉及速度的问题）。</p><h4 id="从指针到智能指针"><a href="#从指针到智能指针" class="headerlink" title="从指针到智能指针"></a>从指针到智能指针</h4><p>书中的描述，给我的印象就是两句话：一是智能指针不是指针，是类，包含重载运算符的类（好像很多地方都这么说，用A修饰的B不是B，<del>JavaScript不是Java</del>）；二是智能指针要配合解除引用运算符<code>*</code>和成员选择运算符<code>-&gt;</code>使用，实现类似指针的效果（不能用<code>.</code>）。</p><p>顺带一提，使用智能指针需要<code>#include &lt;memory&gt;</code>。</p><p>智能指针的优势，就是能及时、更安全地管理内存。</p><p>在原始代码的<code>fiterCreate()</code>函数部分，首先声明了<code>FilterData</code>类型的变量<code>d</code>和指针<code>data</code>（虽然我从头看到尾，也没明白指针<code>data</code>干了什么），在函数的最后，使用<code>malloc()</code>函数为指针<code>data</code>分配了空间，并赋值指向<code>d</code>。</p><p>仿照HomeOfVapourSynthEvolution的代码风格，使用智能指针代替上述普通指针，就是将开头的声明由</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">FilterData d;<br>FilterData* data;<br></code></pre></td></tr></table></figure><p>改为</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">unique_ptr</span>&lt;FilterData&gt; d = <span class="hljs-built_in">std</span>::make_unique&lt;FilterData&gt;();<br></code></pre></td></tr></table></figure><p>以及将使用<code>.</code>的地方改为<code>-&gt;</code>（为什么原代码要用<code>.</code>呢）。</p><p>此外，还有一个事情，在函数体的最后，<code>vsapi-&gt;ceateFiler()</code>那个部分，使用<code>release()</code>函数将<code>d</code>释放掉…我还不知道这是否是配合智能指针的写法，还是仅仅是一个普通的内存释放。</p><h4 id="从智能指针到多态"><a href="#从智能指针到多态" class="headerlink" title="从智能指针到多态"></a>从智能指针到多态</h4><p>《21天学通C++》中提到，智能指针在处理多态对象时具有优势。于是就翻到了多态的那一章，看到了虚函数相关的内容，便想起了在读avs版JincResize代码时，看到虚函数便一头雾水。</p><h4 id="从宏定义到std"><a href="#从宏定义到std" class="headerlink" title="从宏定义到std"></a>从宏定义到std</h4><p>原始代码使用了两个自定义的宏函数，<code>MAX</code>和<code>MIN</code>。先前已经将一部分<code>MAX</code>和<code>MIN</code>用<code>std::max</code>和<code>std::min</code>替代，但另一些无法替代。今天才发现，<code>std::max</code>和<code>std::min</code>的输入变量类型需要一致，自定义的宏函数则没有做规定（这应该也反映了宏的不安全）。那些不能替代的表达式，均是浮点型和整型混搭，改成一致后就可以用<code>std::max</code>和<code>std::min</code>了。</p><p>比较了一下宏、std、使用了模板的内联函数，三者的效率，发现还是使用std更快一点。（测试方法，测试了一段1200帧左右的短视频，比较时间）</p><h4 id="内存管理相关"><a href="#内存管理相关" class="headerlink" title="内存管理相关"></a>内存管理相关</h4><p>其实上面的智能指针就是关于内存管理的。这里单独拿出来，主要是想说一下<code>new</code>、<code>delete</code>、<code>malloc()</code>、<code>free()</code>。这也是我理解最困难的地方。</p><p>一方面，从一开始迁移代码就不明白的<code>data = malloc(sizeof(d));</code>。另一方面，读HomeOfVapourSynthEvolution的代码，像在<code>filterFree()</code>中，只对<code>d</code>进行了<code>delete</code>，而在原始代码中，使用了<code>free()</code>，不仅释放了<code>d</code>，还释放了<code>d-&gt;lut</code>，我不明白为什么还要单独释放<code>lut</code>这么一个对象，明明整个<code>d</code>都释放了。同时，我还不知道<code>delete</code>和<code>free()</code>两种操作的区别（虽然我知道<code>free()</code>和<code>malloc()</code>配合使用，但我好像找不到相应的<code>malloc()</code>啊）。</p><p>在前辈的指点下，阅读了这篇教程（ <a href="https://www.includehelp.com/cpp-tutorial/difference-between-delete-and-free.aspx" target="_blank" rel="noopener">https://www.includehelp.com/cpp-tutorial/difference-between-delete-and-free.aspx</a> ），至少是知道了 <code>delete</code>比<code>free()</code>更快，因为前者是操作符，后者是函数。</p><h4 id="其他一些细节"><a href="#其他一些细节" class="headerlink" title="其他一些细节"></a>其他一些细节</h4><p>不是很关键的知识，还是记下来，免得忘了。</p><p>对于<code>cmath</code>找不到π的宏定义<code>M_PI</code>，可以在预处理中加入<code>_USE_MATH_DEFINES</code>。</p><h3 id="增加异常处理"><a href="#增加异常处理" class="headerlink" title="增加异常处理"></a>增加异常处理</h3><p>这部分语法比较简单，在<code>filterCreate()</code>函数中增加<code>try {...} catch {...}</code>代码块，并把之前的内容copy到<code>try {...}</code>内就OK了。需要思考的是会遇到什么异常。</p><h3 id="真正意义上的重构部分"><a href="#真正意义上的重构部分" class="headerlink" title="真正意义上的重构部分"></a>真正意义上的重构部分</h3><h4 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h4><p>在前一节的内存管理中也提到，我一直不太明白原始代码很多关于对象的“单独操作”的意义。除了上面的<code>free(d-&gt;lut)</code>外，类似<code>new_vi.width = d-&gt;w</code>等单独操作，也不太明白。话说回来，这两个例子是有区别的：后者删了的话，编译通过，但在vs中测试程序就崩溃；前者删不删都完全正常。</p><h4 id="循环内计算与循环外调用"><a href="#循环内计算与循环外调用" class="headerlink" title="循环内计算与循环外调用"></a>循环内计算与循环外调用</h4><p>除法很慢，而原始代码中又存在可以移除for循环的除法计算，所以移除for循环，希望可以提升速度。</p><p>原代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> y = <span class="hljs-number">0</span>; y &lt; oh; y++) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> x = <span class="hljs-number">0</span>; x &lt; ow; x++) &#123;<br>        <span class="hljs-keyword">double</span> rpm_x = (x + <span class="hljs-number">0.5</span>) * iw / ow;<br>        <span class="hljs-keyword">double</span> rpm_y = (y + <span class="hljs-number">0.5</span>) * ih / oh;<br>        ...<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>新代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">double</span> scale_x = (<span class="hljs-keyword">double</span>)iw / ow;<br><span class="hljs-keyword">double</span> scale_y = (<span class="hljs-keyword">double</span>)ih / oh;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> y = <span class="hljs-number">0</span>; y &lt; oh; y++) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> x = <span class="hljs-number">0</span>; x &lt; ow; x++) &#123;<br>        <span class="hljs-keyword">double</span> rpm_x = (x + <span class="hljs-number">0.5</span>) * scale_x;<br>        <span class="hljs-keyword">double</span> rpm_y = (y + <span class="hljs-number">0.5</span>) * scale_y;<br>        ...<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在实际使用中，<code>oh</code>和<code>ow</code>至少对应1080p or 720p。对于1080p，上述双重for循环就要循环1920*1080 ≈ 2*10^6次，即200+万次，除法进行了400+万次。我以为把除法放到循环外，能提高效率，没想到用上面的视频片段测试，反而更慢了…</p><p>记得在一个地方读到过，调用循环外的变量也存在开销，因外定义、调用变量就要调用析构函数（但我又看到过对于简单变量不需要析构函数…），进而降低效率。所以存在“循环内计算vs循环外调用”的取舍。</p><p>emmm我不知道该怎么解释了，也可能是我的测试方法依赖于当时CPU的表现？</p><p>除了这个除法的改动，我还试着把for循环内的位移运算拿出来。但大家都知道，位移运输很快，所以拿到for循环外后，速度下降得更明显了…我好难…</p><p>知乎上看到两句话，合起来就是，“不必追求5%效率的提升”，“这样可能会降低其他方面的性能，如可扩展性”。</p><p>虽然目前的改动，对效率的影响可能连5%都不到，但我还是要改的吧，毕竟上面的双重for循环内还有一个双重for循环…</p><h4 id="目前代码的运算量"><a href="#目前代码的运算量" class="headerlink" title="目前代码的运算量"></a>目前代码的运算量</h4><p>核心运算量是前前后后加起来的五重for循环，第一重循环3次，这倒是没什么，后面两个双重for循环，对于放大到1080p的情况，大约要执行4.3*10^12次，即4.3万亿次…乘3，就是12.9万亿次…除了for循环本身的判断，循环内还有if判断语句（似乎这个也会拖慢性能）。</p><p>虽然作为放大算法，这恐怕也没办法..但看上去仍觉得可怕…</p><h4 id="从avs版代码得到的启发"><a href="#从avs版代码得到的启发" class="headerlink" title="从avs版代码得到的启发"></a>从avs版代码得到的启发</h4><p>去看了avs版JincResize代码，原始版的核心代码和我现在的代码看上去差不多。但最新的代码，在第二个双重for循环中，省去了除法运算，也就是省去了归一化过程。怎么做到这一点的，我还没看明白，但这应该是一个优化的方向。</p><h3 id="功能增加"><a href="#功能增加" class="headerlink" title="功能增加"></a>功能增加</h3><h4 id="添加32bit支持（2019-12-18）"><a href="#添加32bit支持（2019-12-18）" class="headerlink" title="添加32bit支持（2019.12.18）"></a>添加32bit支持（2019.12.18）</h4><p>在完成从C到C++的迁移后，只支持8-16bit整型输入，若要增加32bit浮点数的支持，首先要修改一下模板函数的调用，再用<code>float</code>型调用一次。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">if</span> (d-&gt;vi-&gt;format-&gt;bytesPerSample == <span class="hljs-number">1</span>)<br>    process&lt;<span class="hljs-keyword">uint8_t</span>&gt;();<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (d-&gt;vi-&gt;format-&gt;bytesPerSample == <span class="hljs-number">2</span>)<br>    process&lt;<span class="hljs-keyword">uint16_t</span>&gt;();<br><span class="hljs-keyword">else</span><br>    process&lt;<span class="hljs-keyword">float</span>&gt;();<br></code></pre></td></tr></table></figure><p>（这样看使用模板的理由就更充分了，如果说<code>uint8_t</code>和<code>uint16_t</code>都是整型，（或许？）可以用直接用<code>int</code>型来操作，那么这次引入<code>float</code>，模板的作用就更明显了。）</p><p>当然，仅仅接口处改了还不行，去看一下实际处理部分，也就是运算过程中有无涉及位深的部分。</p><p>唯一涉及的就是这句话</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">pixel = <span class="hljs-built_in">std</span>::max(<span class="hljs-built_in">std</span>::min(pixel / normalizer, (<span class="hljs-number">1</span> &lt;&lt; d-&gt;vi-&gt;format-&gt;bitsPerSample) - <span class="hljs-number">1.0</span>), <span class="hljs-number">0.0</span>);<br></code></pre></td></tr></table></figure><p>这种比较两次大小的操作在图像处理中很常见，用最大值和最小值限制，得到一个中间值的值，以防结果“溢出”色彩取值范围。对于整型而言，限制无非就是色彩<code>[0,2^depth-1]</code>，比如熟悉的8bit，色彩取值<code>[0,255]</code>，16bit是<code>[0,65335]</code>。而对于32bit浮点型，取值范围则是<code>[-1.0,1.0]</code>，这样更好比较了，先判断一下<code>stInteger</code>（vs中判断是否为整型的操作），若否，则</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">pixel = <span class="hljs-built_in">std</span>::max(<span class="hljs-built_in">std</span>::min(pixel / normalizer, <span class="hljs-number">-1.0</span>), <span class="hljs-number">1.0</span>);<br></code></pre></td></tr></table></figure><p>至此，运算部分对32bit浮点型的支持也完成了。</p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><h4 id="使用gcc编译"><a href="#使用gcc编译" class="headerlink" title="使用gcc编译"></a>使用gcc编译</h4><p>主要参考了这篇文章： <a href="https://www.qiufengblog.com/articles/gcc-dll.html" target="_blank" rel="noopener">https://www.qiufengblog.com/articles/gcc-dll.html</a> 。</p><p>使用gcc编译C语言代码，编译为dll。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">gcc -o func.dll -shared main.c<br></code></pre></td></tr></table></figure><p>配置头文件和库文件路径我还不会..只好先到这，还是用VS吧。</p><p>（2019.11.25）成功使用gcc/g++进行编译，并且编译后的dll运行速度大幅提升，和原作者dll的速度相似。</p><h4 id="关于测试"><a href="#关于测试" class="headerlink" title="关于测试"></a>关于测试</h4><p>借助x265编码器进行的测试，由于增加了视频重编码的过程，所以其他因素影响可能较大。</p><p>测试时有点意外的就是，我上面的所以改动（“从宏定义到std”部分和“循环内计算与循环外调用”部分），最后重编码得到的文件，hash值都一样。所以这些改动对运行结果没有影响，倒也放心了（特别把除法移除for的部分，我以为新声明一个变量储存除法结果，可能导致精度下降，但其并没有）。</p><h4 id="下一步的计划"><a href="#下一步的计划" class="headerlink" title="下一步的计划"></a>下一步的计划</h4><p>总之，现在就是从free和delete入手，开始代码重构；同时看多态的部分，争取迁移avs版的jinc函数实现。</p>]]></content>
    
    
    <categories>
      
      <category>Code</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++笔记：某培训课程与21天学通C++</title>
    <link href="/2019/11/22/learn-cpp-note-1/"/>
    <url>/2019/11/22/learn-cpp-note-1/</url>
    
    <content type="html"><![CDATA[<h3 id="写在开头的话"><a href="#写在开头的话" class="headerlink" title="写在开头的话"></a>写在开头的话</h3><p>有人讲解，学习效率还是会高一些的吧。</p><p>愿我能坚持。更愿我能在写完这个笔记后，继续写学习笔记之二。毕竟，培训班的课程只能算一个开始。</p><p>后来在忙其他事情的时候，学到了更多的东西，于是把21天学通C++及网络上资料（主要是菜鸟教程）的学习笔记也记到这上面来。虽然和周记系列有点冲突，但同时进行吧，做下去就能变得清晰。</p><a id="more"></a><h3 id="Day1"><a href="#Day1" class="headerlink" title="Day1"></a>Day1</h3><p>先说一下直观地感受，比起自学，视频更让我有了系统学习、或者说科班的感受。毕竟我自己是遇到什么问题才去学相应的内容。不过我之前的基础或者说经历，还是有些用的。老师讲到一些地方，我能和我之前的经验联系起来。</p><p><del>原来C++ primer plus比C++ primer更基础</del></p><h4 id="C-的特点"><a href="#C-的特点" class="headerlink" title="C++的特点"></a>C++的特点</h4><p>说到内存分配，前几天修改Jinc放大算法时还遇到过（给Data分配内存，C++中更推荐用<code>new</code>代替C的<code>malloc()</code>），联系之前用Python写作业的经历。确实是，定义一个变量，C++需要考虑内存分配和释放的问题，而Python完全不用管。所以这也是C++更高效的原因，开发者可以控制、优化内存的使用。</p><h4 id="命名空间（namespace）相关"><a href="#命名空间（namespace）相关" class="headerlink" title="命名空间（namespace）相关"></a>命名空间（namespace）相关</h4><p>std标准命名空间，来自<code>&lt;iostream&gt;</code>，自定义命名空间则通过以下方式实现。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">namespace</span> space &#123; ... &#125; <span class="hljs-comment">// 注意没有分号</span><br></code></pre></td></tr></table></figure><h4 id="struct类型"><a href="#struct类型" class="headerlink" title="struct类型"></a>struct类型</h4><p>struct类型是我自己接触较多的，但可能是视频里讲得不多，还是没听太明白。视频给我的感受，和定义了一个类差不都，但平时的经历让我觉得这只是给变量起了个新名字。</p><h4 id="Other"><a href="#Other" class="headerlink" title="Other"></a>Other</h4><p>其余就是比较基础的东西了，命名空间的调用、变量的定义、bool类型，以及在这些过程中学到的基础的代码和VS使用。</p><h3 id="Day-2"><a href="#Day-2" class="headerlink" title="Day 2"></a>Day 2</h3><p>运行了一下基本的类的代码。</p><h3 id="Day-3"><a href="#Day-3" class="headerlink" title="Day 3"></a>Day 3</h3><p>学习了多态、虚函数，从书中看了纯虚函数的概念。</p><p>但回到avs版的JincResize脚本，也只是用纯虚函数把函数封装得更“严实”，我还无法理解这样做的意义。而且看上去也无关速度。（那我的dll为什么那么慢…我要掀桌子了orz…（后来发现是msvc编译器的问题，换成gcc编译器就快了…）</p><h3 id="Day-n"><a href="#Day-n" class="headerlink" title="Day n"></a>Day n</h3><h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><p>所谓构造函数，可以理解为构建一个属于类的对象。</p><ul><li>构造函数与类同名</li><li>构造函数可以重载</li><li>构造函数没有返回值</li><li>（原始的）构造函数没有参数，但重载也可以有参数</li><li>可以在类外定义构造函数，需要<code>className::className()</code>这样写</li></ul>]]></content>
    
    
    <categories>
      
      <category>Code</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>记一次从C语言到C++的迁移——初次接触VapourSynth API</title>
    <link href="/2019/11/19/trans-c-to-cpp/"/>
    <url>/2019/11/19/trans-c-to-cpp/</url>
    
    <content type="html"><![CDATA[<h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>想在VapourSynth中实现Jinc（EWA Lanczos）放大算法，已经有一份实现，<a href="https://github.com/Lypheo/EWA-Resampling-VS" target="_blank" rel="noopener">https://github.com/Lypheo/EWA-Resampling-VS</a> 。但这份代码仅支持整型16bit输入（严格来说是仅支持整型9~16bit输入，作者说仅支持16bit RGB输入，但无论看代码还是实际测试，16bit YUV和10bit YUV都是支持的）。</p><p>所以我想在原作者代码的基础上，先完善上述输入问题。至少要支持整型8bit YUV输入，后续再考虑支持32bit浮点数输入。</p><p>阅读了原作者代码和其他一些较为成熟的基于VapourSynth实现的代码，大致明白了VapourSynth API调用的过程和基础的代码结构。至少对于Jinc算法，在整型8-16bit的范围内，支持的输入类型仅取决于关键变量的类型定义（这话看起来是一句正确的废话，要怪就怪C++是一门强类型语言Orz）。</p><p>再具体一点，支持8bit需要使用<code>uint8_t</code>来定义关键变量，支持9~16bit需要使用<code>unit16_t</code>来定义关键变量。所以要在代码中，根据输入视频的位深进行类型转换。</p><p>在C语言中，我能想到的就是使用宏来完成上述过程。但是复杂一点宏我就不会写…而且宏也不安全…我还是用C++的模板来写吧。看了一下不同前辈们的代码，也都是用模板来写的，<del>方便Copy</del>。</p><a id="more"></a><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><p>不着急写模板，从C到C++，代码还是要改一下的。</p><ol><li><p>在C++中，使用<code>uint8_t</code>等类型需要include<code>&lt;cstdint&gt;</code>头文件。</p></li><li><p>在C++使用圆周率<code>M_PI</code>的宏，要include相应的数学头文件，随后又带来了新的问题，所以直接定义一个宏吧。</p></li><li><p>内存控制方面，在C++中使用<code>malloc()</code>分配内存，需要进行强制类型转换。具体到这份代码，将</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">data = <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(d));<br></code></pre></td></tr></table></figure><p>修改为</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">data = (FilterData *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(d));<br></code></pre></td></tr></table></figure><p>其中，<code>FilterData</code>是自定义类型。</p></li></ol><h3 id="理解VapourSynth-API和VapourSynth插件的基础代码"><a href="#理解VapourSynth-API和VapourSynth插件的基础代码" class="headerlink" title="理解VapourSynth API和VapourSynth插件的基础代码"></a>理解VapourSynth API和VapourSynth插件的基础代码</h3><h4 id="理解VapourSynth-API"><a href="#理解VapourSynth-API" class="headerlink" title="理解VapourSynth API"></a>理解VapourSynth API</h4><p>解决了基础的代码语法问题，还需要理解VapourSynth API，起码要明白怎么读写视频、怎么获取视频格式信息、视频处理前后储存在什么变量中、这些变量是怎么声明的。</p><p>借助VapourSynth API，上述问题的解答如下。</p><ol><li>视频的读取写入通过<code>vsapi-&gt;getReadPtr</code>、<code>vsapi-&gt;getWritePtr</code>、<code>vsapi-&gt;newVideoFrame</code>实现。</li><li>视频格式信息通过<code>d-&gt;vi-&gt;format</code>获取，具体信息对应具体函数，如获取位深使用<code>bytesPerSample</code>；视频尺寸信息通过<code>vsapi-&gt;getFrameHeight</code>、<code>vsapi-&gt;getFramewidth</code>获取。</li><li>储存视频的变量类型是<code>VSFrameRef*</code>（通过指针储存），分平面储存；输入视频要加上<code>const</code>限制。</li><li>好像3已经回答了变量声明的问题。</li><li>顺带一提，读取用户端输入的函数变量通过类似<code>vsapi-&gt;propGetFloat</code>的方式完成。</li></ol><h4 id="VapourSynth的Hello-World"><a href="#VapourSynth的Hello-World" class="headerlink" title="VapourSynth的Hello World"></a>VapourSynth的Hello World</h4><p>写一个VapourSynth插件，或者说写一个基于VapourSynth框架的算法实现，要包含这么几个部分。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 代码主体</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> VS_CC <span class="hljs-title">filterInit</span><span class="hljs-params">(VSMap* in, VSMap* out, <span class="hljs-keyword">void</span>** instanceData, VSNode* node, VSCore* core, <span class="hljs-keyword">const</span> VSAPI* vsapi)</span> </span>&#123;&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">const</span> VSFrameRef* VS_CC <span class="hljs-title">filterGetFrame</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> activationReason, <span class="hljs-keyword">void</span>** instanceData, <span class="hljs-keyword">void</span>** frameData, VSFrameContext* frameCtx, VSCore* core, <span class="hljs-keyword">const</span> VSAPI* vsapi)</span> </span>&#123;&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> VS_CC <span class="hljs-title">filterFree</span><span class="hljs-params">(<span class="hljs-keyword">void</span>* instanceData, VSCore* core, <span class="hljs-keyword">const</span> VSAPI* vsapi)</span> </span>&#123;&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> VS_CC <span class="hljs-title">filterCreate</span><span class="hljs-params">(<span class="hljs-keyword">const</span> VSMap* in, VSMap* out, <span class="hljs-keyword">void</span>* userData, VSCore* core, <span class="hljs-keyword">const</span> VSAPI* vsapi)</span> </span>&#123;&#125;<br><br><span class="hljs-comment">// Python接口</span><br>VS_EXTERNAL_API(<span class="hljs-keyword">void</span>) VapourSynthPluginInit(VSConfigPlugin configFunc, VSRegisterFunction registerFunc, VSPlugin* plugin) &#123;&#125;<br></code></pre></td></tr></table></figure><p>代码主体的四个函数中，<code>filterInit()</code>和<code>filterFree()</code>是辅助性质的函数，主要代码在<code>filterGetFrame()</code>和<code>filterCreate()</code>中。其中<code>filterCreat()</code>多是用来获取用户端的输入参数，所以实现算法的核心代码一般位于<code>filterGetFrame()</code>中。</p><h3 id="写模板"><a href="#写模板" class="headerlink" title="写模板"></a>写模板</h3><h4 id="Coding过程"><a href="#Coding过程" class="headerlink" title="Coding过程"></a>Coding过程</h4><p>语法和API调用都搞明白了，下面开始写模板。具体需求在引言部分已经写清楚了。现在回到原作者的代码上，寻找鲁棒性缺失的地方。</p><p>容易发现，在<code>GetFrame</code>部分，直接使用<code>uint8_t</code>和<code>uint16_t</code>声明了储存视频的变量。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">const</span> <span class="hljs-keyword">uint8_t</span> *scrp = vsapi-&gt;getReadPtr(frame, plane);<br><span class="hljs-keyword">uint8_t</span> *targetp = vsapi-&gt;getWritePtr(dst, plane);<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">uint16_t</span> *framep = (<span class="hljs-keyword">uint16_t</span> *) scrp;<br><span class="hljs-keyword">uint16_t</span> *dstp = (<span class="hljs-keyword">uint16_t</span> *) targetp;<br></code></pre></td></tr></table></figure><p>这就是原代码仅支持9~16bit的原因（之一），要用函数模板替代上述直接声明。</p><p>当年上C++课的时候，老师说模板不考…所以在教材目录上画个叉，模板的学习到此为止…写模板倒容易写，像定义函数那样照猫画虎。但怎么调用模板，花了一段时间才弄明白。</p><p>实现引言中的需求，逻辑很简单，伪代码如下。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 定义模板</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">bitdepth</span><span class="hljs-params">()</span> </span>&#123;&#125;<br><br><span class="hljs-comment">// 根据输入视频位深，使用不同的类型定义变量</span><br><span class="hljs-keyword">if</span> (depth &lt;= <span class="hljs-number">8</span>)<br>    bitdepth&lt;<span class="hljs-keyword">uint8_t</span>&gt;();<br><span class="hljs-keyword">else</span><br>    bitdepth&lt;<span class="hljs-keyword">uint16_t</span>&gt;();<br></code></pre></td></tr></table></figure><p>我之所以不知道怎么调用函数模板，是因为我一开始不想改动太多的原始代码。原始代码用<code>uint16_t</code>直接声明变量，我也想借助函数模板直接做类似的事情。于是，我的代码写成了下面这个样子。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> T* <span class="hljs-title">process1</span><span class="hljs-params">( ... )</span> </span>&#123;<br>    <span class="hljs-keyword">const</span> T* framep = <span class="hljs-keyword">reinterpret_cast</span>&lt;<span class="hljs-keyword">const</span> T*&gt;(vsapi-&gt;getReadPtr(src, plane));<br>    <span class="hljs-keyword">return</span> framep;<br>&#125;<br><br><span class="hljs-keyword">if</span> (d-&gt;vi-&gt;format-&gt;bytesPerSample == <span class="hljs-number">1</span>) &#123;<br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">uint8_t</span> *scrp = process1&lt;<span class="hljs-keyword">uint8_t</span>&gt;( ... );<br>    <span class="hljs-keyword">uint8_t</span> *framep = (<span class="hljs-keyword">uint8_t</span> *) scrp;<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p>我想当然的以为通过if语句，就可以让代码根据视频输入格式选择变量类型，但我忘了一件事情…if语句内的变量是局部变量，作用域仅限if语句内…</p><p>好吧…那我把后面的代码分别往if和else内复制一遍，直接在if语句内处理到底…<del>这也太蠢了</del>。</p><p>坦白地讲，我心里很清楚，这就是半路出家自学和科班的差距。</p><p>看了前辈的代码，将函数模板写成void函数，在<code>GetFrame</code>部分仅进行函数模板的调用，处理的代码均写在函数模板内。把该写的框架都写全，代码如下。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">process</span><span class="hljs-params">(<span class="hljs-keyword">const</span> VSFrameRef* frame, VSFrameRef* dst, <span class="hljs-keyword">const</span> FilterData* <span class="hljs-keyword">const</span> VS_RESTRICT d, <span class="hljs-keyword">const</span> VSAPI* vsapi)</span> <span class="hljs-keyword">noexcept</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> plane = <span class="hljs-number">0</span>; plane &lt; d-&gt;vi-format-&gt;numPlanes; plane++) &#123;<br>        <span class="hljs-comment">// 储存读取写入视频的变量</span><br>        <span class="hljs-keyword">const</span> T* framep = <span class="hljs-keyword">reinterpret_cast</span>&lt;<span class="hljs-keyword">const</span> T*&gt;(vsapi-&gt;getReadPtr(frame, plane));<br>        T* VS_RESTRICT dstp = <span class="hljs-keyword">reinterpret_cast</span>&lt;T*&gt;(vsapi-&gt;getWritePtr(dst, plane));<br>        <br>        <span class="hljs-comment">// 原始代码是除以2，若以8bit输入，应当是除以1，所以用sizeof(T)代替具体数字</span><br>        <span class="hljs-keyword">int</span> frame_stride = vsapi-&gt;getStride(frame, plane) / <span class="hljs-keyword">sizeof</span>(T);<br>        <span class="hljs-keyword">int</span> dst_stride = vsapi-&gt;getStride(dst, plane) / <span class="hljs-keyword">sizeof</span>(T);<br>        <br>        <span class="hljs-comment">// Jinc算法实现部分</span><br>        ...<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> VSFrameRef* VS_CC <span class="hljs-title">filterGetFrame</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> activationReason, <span class="hljs-keyword">void</span>** instanceData, <span class="hljs-keyword">void</span>** frameData, VSFrameContext* frameCtx, VSCore* core, <span class="hljs-keyword">const</span> VSAPI* vsapi)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (activationReason == arInitial) &#123;<br>        vsapi=&gt;requestFrameFilter(n, d-&gt;node, frameCtx);<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (activationReason == arAllFramesReady) &#123;<br>        <span class="hljs-keyword">const</span> VSFormat* fi = d-&gt;vi-&gt;format;<br>        <br>        <span class="hljs-keyword">const</span> VSFrameRef* frame = vsapi-&gt;getFrameFilter(n, d-&gt;node, frame, core);<br>        VSFrameRef* dst = vsapi-&gt;newVideoFrame(fi, d-&gt;w, d-h, frame, core);<br>        <span class="hljs-comment">// w和h是在filterCreat部分获取的用户端参数，指用户设定的放大后的视频尺寸。</span><br>        <br>        <span class="hljs-keyword">if</span> (fi-&gt;bytesPerSample == <span class="hljs-number">1</span>)<br>            process&lt;<span class="hljs-keyword">uint8_t</span>&gt;(frame, dst, d, vsapi);<br>        <span class="hljs-keyword">else</span><br>            prcess&lt;<span class="hljs-keyword">uint16_t</span>&gt;(frame, dst, d, vsapi);<br>        <span class="hljs-comment">// 更鲁棒的写法，可以支持浮点数视频输入</span><br>        <span class="hljs-comment">// 但我前面的函数模板还没有支持浮点数，且一般用户也很少使用到浮点数视频，所以上述代码堪用</span><br>        <span class="hljs-comment">// else if (fi-&gt;bytesPerSample == 2)</span><br>        <span class="hljs-comment">//     process&lt;uint16_t&gt;(frame, dst, d, vsapi);</span><br>        <span class="hljs-comment">// else</span><br>        <span class="hljs-comment">//     process&lt;float&gt;(frame, dst, d, vsapi);</span><br>        <br>        vsapi-&gt;freeFrame(frame); <span class="hljs-comment">// 释放内存</span><br>        <span class="hljs-keyword">return</span> dst;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>至此，完成了模板的撰写（及小小的代码重构）和调用，测试一下，8bit、10bit、16bit YUV格式输入都没有问题。</p><h4 id="值得注意的基础知识（2019-12-18）"><a href="#值得注意的基础知识（2019-12-18）" class="headerlink" title="值得注意的基础知识（2019.12.18）"></a>值得注意的基础知识（2019.12.18）</h4><p>上面这个模板是从前辈的一处代码中照猫画猫得到的（当时，模板函数的声明应该是copy过来的，改了一下，没太动脑子）（照着模板写模板，<del>禁止套娃</del>），有些细节没注意，或者现在忘了，来记一下。</p><h5 id="noexcept关键字与异常处理、编译优化"><a href="#noexcept关键字与异常处理、编译优化" class="headerlink" title="noexcept关键字与异常处理、编译优化"></a><code>noexcept</code>关键字与异常处理、编译优化</h5><p>在模板函数的函数声明和函数体之间（上述代码的第2行），有这么一个关键字，<code>noexcept</code>。</p><p><code>noexcept</code>是C++11引入的新特性（我居然能注意不同的C++标准了，以前觉得这是要学很久才能去学的东西Orz）。根据这篇博文，<a href="https://www.cnblogs.com/sword03/p/10020344.html" target="_blank" rel="noopener">C++11 带来的新特性 （3）—— 关键字noexcept</a>，<code>noexcept</code>会告诉编译器，使用了<code>noexcept</code>的函数不会发生异常。由于异常处理是在运行而非编译时执行，所以异常处理会影响编译器的优化，通过<code>noexcept</code>这么一“声明”，便于编译器做更多的优化。</p><p>顺带一提，在引入<code>noexcept</code>关键字之前，是使用<code>throw()</code>来实现类似功能。</p><p>博文中还有更深入的内容，以后还值得拿出来再看。</p><h5 id="两个const"><a href="#两个const" class="headerlink" title="两个const"></a>两个<code>const</code></h5><p>我第一次注意到<code>const FilterData* const VS_RESTRICT d</code>这样的声明，有点惊呆了，怎么有两个<code>const</code>。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>总结一下，这篇博文的标题是从C语言到C++的迁移。就我目前的感受，C语言和C++的区别体现在C++有模板，而且对类型转换更加严格。</p><p>另外，文章用相当长的篇幅描述了VapourSynth的C++ API，我搞明白这些东西花了挺长一段时间，即使只算“开窍”后有明显进步的时间，也有一个多星期。如果现在让我从头用VapourSynth API写一个插件，照猫画虎应该没什么大问题，而且通过这段时间对C++的语法也有了更多的了解。</p><p>但另一方面，对于算法实现，这个真要花更多时间。我之前只知道Jinc的数学公式，知道怎样“手动推演”实现视频放大，但完全不知道在代码实现时，还有反向映射这一回事。在代码实现中，除了定义Jinc函数的部分，其余都是简单的加减乘除四则运算。关于8bit、16bit位深处理的地方，也没有涉及数学运算，区别只是变量的声明。这些东西，都是从算法到代码要学习的东西。同时，代码的异常处理、鲁棒性，也真实地接触到了。</p><p>之后的工作，具体到这份代码，就是实现taps功能。这份代码之外，我希望能够从头实现一个算法。</p><h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>关于编译后运行速度问题的。</p><p>关于鲁棒性，能否接受灰度视频/单平面视频输入。</p><p>C++与C头文件的区别，使用std库是否能提高速度，内存分配时的类型转换是否是降低速度的主因？</p><h3 id="代码重构的预备"><a href="#代码重构的预备" class="headerlink" title="代码重构的预备"></a>代码重构的预备</h3><p>测试了半个下午，想解决dll运行慢的问题。（我实在不能理解也无法接受作者提供的dll速度是1s/帧，到我这就是9s/帧）。</p><ul><li><strong>不是编译器配置的锅</strong>，我自行编译了Deblock，速度很快，虽然我的编译器配置与原作者的并不完全相同。</li><li>又重复了一次，修改预处理后，除了<code>malloc()</code>函数部分，其他与作者代码保持一致，仍然是9s/帧的速度。<strong>不是我添加了函数模板导致的速度变慢</strong>。</li><li>换用gcc编译器…一时半会还没折腾好，先不用了..</li><li>我现在真的是无法理解，作者的<code>data = malloc(sizeof(d));</code>是怎么编译通过的，我目前查到的所有资料，都说在<code>malloc()</code>函数前需要声明变量类型。</li><li>我现在还担心，等我代码重构了，还是慢怎么办…</li></ul>]]></content>
    
    
    <categories>
      
      <category>Code</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>VapourSynth</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git的使用：创建SSH key、多账号共存、提交代码及进阶使用</title>
    <link href="/2019/11/03/git-use-1/"/>
    <url>/2019/11/03/git-use-1/</url>
    
    <content type="html"><![CDATA[<h2 id="创建SSH-key"><a href="#创建SSH-key" class="headerlink" title="创建SSH key"></a>创建SSH key</h2><h3 id="创建密钥"><a href="#创建密钥" class="headerlink" title="创建密钥"></a>创建密钥</h3><p>在Windows下，使用Git bash，创建秘钥。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ssh-keygen -t rsa<br></code></pre></td></tr></table></figure><p>在这一步可以使用<code>-C &#39;comment&#39;</code>对秘钥进行注释。一些教程中要求在<code>-C</code>后写邮箱，其实写什么都可以，不写也行，注释而已。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ssh-keygen -t rsa -C <span class="hljs-string">'comment'</span><br></code></pre></td></tr></table></figure><p>默认的密钥为2048位，可以使用<code>-b</code>指定密钥位数。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ssh-keygen -t rsa -b 4096 -C <span class="hljs-string">'comment'</span><br></code></pre></td></tr></table></figure><p>之后会确认密钥文件的存放位置和文件名，如下。</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">Enter <span class="hljs-built_in">file</span> <span class="hljs-keyword">in</span> which <span class="hljs-built_in">to</span> save <span class="hljs-keyword">the</span> key (/c/Users/UserName/.ssh/id_rsa):<br></code></pre></td></tr></table></figure><p>回车即使用括号内的默认位置和名称，如果有多个密钥文件，注意修改文件名。如果不更改存放位置，只修改文件名，直接输入想要的文件名即可。密钥的私钥文件无后缀，公钥文件无需命名，与私钥一致，以<code>.pub</code>为后缀。</p><p>之后会要求设置密码，回车则密码留空。</p><p>看到<code>The key&#39;s randomart image is:</code>和创建密钥时的随机图像，即为创建成功。</p><a id="more"></a><h3 id="添加密钥"><a href="#添加密钥" class="headerlink" title="添加密钥"></a>添加密钥</h3><p>添加私钥至ssh-agent，Windows下私钥的路径为<code>C:\Users\UserName\.ssh\id_rsa</code>。当然在Git Bash里要加上引号，或这么写<code>/c/Users/UserName/.ssh/id_rsa</code>，或者直接<code>~/.ssh/id_rsa</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ssh-add ~/.ssh/id_rsa<br></code></pre></td></tr></table></figure><p>如果上述命令无法执行，则</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ssh-agent bash<br></code></pre></td></tr></table></figure><p>然后在Github或Gitlab的网页端添加公钥（公钥文件为<code>C:\Users\UserName\.ssh\id_rsa.pub</code>）。</p><p>顺带一提，如果在创建时添加了注释，则公钥会以“空格+注释内容”结尾。</p><h2 id="多个Git账号共存"><a href="#多个Git账号共存" class="headerlink" title="多个Git账号共存"></a>多个Git账号共存</h2><h3 id="创建多个ssh-key"><a href="#创建多个ssh-key" class="headerlink" title="创建多个ssh-key"></a>创建多个ssh-key</h3><p>如果需要同时使用Github和Gitlab，并同时使用ssh连接，则需创建两个密钥，如</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">ssh-keygen -t rsa -C <span class="hljs-string">'github'</span><br>ssh-keygen -t rsa -C <span class="hljs-string">'gitlab'</span><br></code></pre></td></tr></table></figure><p>重复上一节的内容，添加私钥至ssh-agent，分别添加公钥至Github和Gitlab。</p><h3 id="为不同网站配置ssh-key"><a href="#为不同网站配置ssh-key" class="headerlink" title="为不同网站配置ssh-key"></a>为不同网站配置ssh-key</h3><p>进入密钥所在的<code>.ssh</code>文件夹，创建配置文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> ~/.ssh<br>touch config<br></code></pre></td></tr></table></figure><p>在<code>config</code>文件中写入如下内容，注意将Github部分的<code>User UserName</code>修改为实际用户名。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-comment"># gitlab</span><br>Host gitlab.com<br>HostName gitlab.com<br>PreferredAuthentications publickey<br>IdentityFile ~/.ssh/id_rsa_gitlab<br><br><span class="hljs-comment"># github</span><br>Host github.com<br>User UserName<br>Hostname ssh.github.com<br>PreferredAuthentications publickey<br>IdentityFile ~/.ssh/id_rsa_github<br>Port 443<br></code></pre></td></tr></table></figure><h3 id="测试ssh-key的配置情况"><a href="#测试ssh-key的配置情况" class="headerlink" title="测试ssh-key的配置情况"></a>测试ssh-key的配置情况</h3><p>使用<code>ssh -T</code>命令测试密钥配置情况。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">ssh -T git@github.com<br>ssh -T git@gitlab.com<br></code></pre></td></tr></table></figure><p>如果是使用该密钥，会询问是否与远程服务器建立连接，输入<code>yes</code>确认即可。之后会在<code>~/.ssh</code>文件夹下生成<code>known_hosts</code>文件，用以记录相应信息。</p><p>对于Github，测试成功的信息为</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">Hi UserName! You<span class="hljs-symbol">'ve</span> successfully authenticated, but GitHub does <span class="hljs-keyword">not</span> provide shell <span class="hljs-keyword">access</span>.<br></code></pre></td></tr></table></figure><p>对于Gitlab，测试成功的信息为</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs autoit">Welcome <span class="hljs-keyword">to</span> GitLab, <span class="hljs-symbol">@UserName</span>!<br></code></pre></td></tr></table></figure><p>至此，密钥的创建与配置工作完成。</p><h3 id="设置Git账户信息"><a href="#设置Git账户信息" class="headerlink" title="设置Git账户信息"></a>设置Git账户信息</h3><p>一般将常用的Git账户设置为全局（global）账户，为需要使用其他账户的仓库设置局域（local）账户。</p><p>设置全局账户。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git config --global user.name <span class="hljs-string">'name'</span><br>git config --global user.email <span class="hljs-string">'email'</span><br></code></pre></td></tr></table></figure><p>为特定仓库设置局域账户。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> /Path/To/Repository<br>git config --<span class="hljs-built_in">local</span> user.name <span class="hljs-string">'name'</span><br>git config --<span class="hljs-built_in">local</span> user.email <span class="hljs-string">'email'</span><br></code></pre></td></tr></table></figure><p>检查账户配置情况。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git config -l<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git config --global -l<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git config --<span class="hljs-built_in">local</span> -l<br></code></pre></td></tr></table></figure><h3 id="GPG签名相关"><a href="#GPG签名相关" class="headerlink" title="GPG签名相关"></a>GPG签名相关</h3><p>需要注意的是，这里只涉及ssh密钥和Git账户的配置，未涉及GPG签名的配置。如果创建了GPG签名，也要分账户进行类似Git的配置。</p><p>例如，为全局账户配置GPG签名。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git config --global commit.gpgsign <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p>不常用账户不使用GPG签名。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git config --<span class="hljs-built_in">local</span> commit.gpgsign <span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><p>上述设置结果均可使用<code>git config -l</code>命令进行检查。</p><h2 id="在Git上提交代码"><a href="#在Git上提交代码" class="headerlink" title="在Git上提交代码"></a>在Git上提交代码</h2><h4 id="基本"><a href="#基本" class="headerlink" title="基本"></a>基本</h4><p>拉取代码到本地。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git pull origin master<br></code></pre></td></tr></table></figure><p>写完代码后，在Git bash中进入代码文件夹下，将代码写入缓存。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git add .<br></code></pre></td></tr></table></figure><p>写commit message。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git commit -m <span class="hljs-string">"commit message"</span><br></code></pre></td></tr></table></figure><p>提交至master分支。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git push origin master<br></code></pre></td></tr></table></figure><h4 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h4><h5 id="给commit写注释"><a href="#给commit写注释" class="headerlink" title="给commit写注释"></a>给commit写注释</h5><p>在Github/Gitlab网页版或者Github桌面版，每次提交，除了给commit写标题，还可以写比较详尽的注释；在命令行中，写两次<code>-m</code>，分别写标题和注释即可。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git commit -m <span class="hljs-string">"Title"</span> -m <span class="hljs-string">"Description"</span><br></code></pre></td></tr></table></figure><h5 id="撤回本地提交"><a href="#撤回本地提交" class="headerlink" title="撤回本地提交"></a>撤回本地提交</h5><p>当commit已在本地提交，但尚未push至远程仓库时，若想撤回本地提交，则需使用<code>git reset</code>。</p><h6 id="进一步地"><a href="#进一步地" class="headerlink" title="进一步地"></a>进一步地</h6><p>撤回本地提交但不撤回已修改的代码，使用<code>git reset</code>；</p><p>撤回本地提交且撤回已修改的代码，使用<code>git reset --hard</code>。</p><h6 id="具体操作"><a href="#具体操作" class="headerlink" title="具体操作"></a>具体操作</h6><p>首先获取commit id（即数字+不区分大小写字母组成的40位字符串，或者用前6位也可）。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">log</span><br></code></pre></td></tr></table></figure><p>会打印出包括仅本地提交在内的提交记录，找到想要撤回的commit的<strong>前一个commit id</strong>，例如前一个commit id为<code>666666</code>，则</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git reset 666666<br></code></pre></td></tr></table></figure><p>之后可按正常流程再次提交代码。</p><h6 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h6><ol><li><p>单纯想撤回某次本地提交</p></li><li><p>本地仓库与远程仓库冲突，在未拉取远程仓库更新的情况下，向本地仓库进行了提交。<br>即使在远程更新与本地提交未涉及相同文件时，强行拉取远程仓库，仍会产生不必要的”Merge …”提交。<br>此时可以撤回本地提交，先拉取远程更新，假装无事发生。</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>工具使用</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python Q&amp;A</title>
    <link href="/2019/10/24/python-Q-A/"/>
    <url>/2019/10/24/python-Q-A/</url>
    
    <content type="html"><![CDATA[<p>记录一些基础简单的东西，随时更新。<del>我太笨了记不住东西，啦啦啦</del></p><p><strong>Question</strong>：PyCharm报错，但cmd不报错。具体情况为把想调用的dll或.py文件放到了<code>Python\Python3x\Lib\site-packages</code>中，并且已经设置好了本地的python.exe解释器，但PyCharm就是无法正常运行，出现类似<code>dll failed</code>的错误。</p><p><strong>Answer</strong>：把<code>Python\Python3x\Lib\site-packages</code>写入系统环境变量，否则PyCharm依旧找不到。</p><p><strong>Question</strong>：占位符（tap）与空格的问题</p><p><strong>Answer</strong>：Notepad++和Atom均有显示占位符和空格的选项。</p><p><strong>Question</strong>：为什么VapouSynth API的函数<code>propGetFloat()</code>名字写作float，却是double类型？</p><p><strong>Answer</strong>：猜测是基于VapouSynth以C++为后端、以Python为前端的模式而故意为之，因为Python中浮点数只有float类型，其与C++的double类型相似。</p><a id="more"></a><p><strong>Question</strong>：报错<code>module &#39;pickle&#39; has no attribute &#39;loads&#39;</code>怎么解决</p><p><strong>Answer</strong>：这是我见过的最蛋疼的报错…原因是我在同project文件夹里自己写一个名为<code>pickle.py</code>的文件，Python会优先加载自定义文件…详情看<a href="https://blog.csdn.net/lwgkzl/article/details/84316630" target="_blank" rel="noopener">这里</a>。具体我自己的故事，前一天晚上为了了解序列化和反序列号，写了这个文件。能踩到这个error…有种游戏里进了隐藏结局的感觉…</p>]]></content>
    
    
    <categories>
      
      <category>Code</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Windows下MXNet的安装（针对 OSError: [WinError 126] 错误）</title>
    <link href="/2019/10/20/mxnet-install-win/"/>
    <url>/2019/10/20/mxnet-install-win/</url>
    
    <content type="html"><![CDATA[<p>记录一下在Windows下安装GPU版MXNet时踩到的坑。</p><p>MXNet安装引导：<a href="http://mxnet.incubator.apache.org/get_started" target="_blank" rel="noopener">http://mxnet.incubator.apache.org/get_started</a></p><p>MXNet版本选择master，其余根据实际情况选择。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">pip install mxnet-cu91 --pre<br></code></pre></td></tr></table></figure><p>安装完成后，执行以下命令，查看MXNet版本号，检测是否安装成功。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">python -c <span class="hljs-string">"import mxnet; print(mxnet.__version__)"</span><br></code></pre></td></tr></table></figure><p>我在检测安装是否成功时，出现以下报错。</p><figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs taggerscript">Traceback (most recent call last):<br>  File "&lt;string&gt;", line 1, in &lt;module&gt;<br>  File "C:<span class="hljs-symbol">\U</span>sers<span class="hljs-symbol">\U</span>serName<span class="hljs-symbol">\A</span>ppData<span class="hljs-symbol">\L</span>ocal<span class="hljs-symbol">\P</span>rograms<span class="hljs-symbol">\P</span>ython<span class="hljs-symbol">\P</span>ython36<span class="hljs-symbol">\l</span>ib<span class="hljs-symbol">\s</span>ite-packages<span class="hljs-symbol">\m</span>xnet<span class="hljs-symbol">\_</span>_init__.py", line 24, in &lt;module&gt;<br>    from .context import Context, current_context, cpu, gpu, cpu_pinned<br>  File "C:<span class="hljs-symbol">\U</span>sers<span class="hljs-symbol">\U</span>serName<span class="hljs-symbol">\A</span>ppData<span class="hljs-symbol">\L</span>ocal<span class="hljs-symbol">\P</span>rograms<span class="hljs-symbol">\P</span>ython<span class="hljs-symbol">\P</span>ython36<span class="hljs-symbol">\l</span>ib<span class="hljs-symbol">\s</span>ite-packages<span class="hljs-symbol">\m</span>xnet<span class="hljs-symbol">\c</span>ontext.py", line 24, in &lt;module&gt;<br>    from .base import classproperty, with_metaclass, _MXClassPropertyMetaClass<br>  File "C:<span class="hljs-symbol">\U</span>sers<span class="hljs-symbol">\U</span>serName<span class="hljs-symbol">\A</span>ppData<span class="hljs-symbol">\L</span>ocal<span class="hljs-symbol">\P</span>rograms<span class="hljs-symbol">\P</span>ython<span class="hljs-symbol">\P</span>ython36<span class="hljs-symbol">\l</span>ib<span class="hljs-symbol">\s</span>ite-packages<span class="hljs-symbol">\m</span>xnet<span class="hljs-symbol">\b</span>ase.py", line 214, in &lt;module&gt;<br>    _LIB = _load_lib()<br>  File "C:<span class="hljs-symbol">\U</span>sers<span class="hljs-symbol">\U</span>serName<span class="hljs-symbol">\A</span>ppData<span class="hljs-symbol">\L</span>ocal<span class="hljs-symbol">\P</span>rograms<span class="hljs-symbol">\P</span>ython<span class="hljs-symbol">\P</span>ython36<span class="hljs-symbol">\l</span>ib<span class="hljs-symbol">\s</span>ite-packages<span class="hljs-symbol">\m</span>xnet<span class="hljs-symbol">\b</span>ase.py", line 205, in _load_lib<br>    lib = ctypes.CDLL(lib_path[0], ctypes.RTLD_LOCAL)<br>  File "C:<span class="hljs-symbol">\U</span>sers<span class="hljs-symbol">\U</span>serName<span class="hljs-symbol">\A</span>ppData<span class="hljs-symbol">\L</span>ocal<span class="hljs-symbol">\P</span>rograms<span class="hljs-symbol">\P</span>ython<span class="hljs-symbol">\P</span>ython36<span class="hljs-symbol">\l</span>ib<span class="hljs-symbol">\c</span>types<span class="hljs-symbol">\_</span>_init__.py", line 348, in __init__<br>    self._handle = _dlopen(self._name, mode)<br>OSError: [WinError 126] The specified module could not be found<br></code></pre></td></tr></table></figure><p><code>OSError: [WinError 126]</code>应该是一个很通用的报错，可以理解为没有找到所需的dll。</p><p>正如一位Github网友所说，这个报错只告诉你缺少dll，却不会告诉你缺少了什么dll。没办法，自力更生。</p><a id="more"></a><p>MXNet的“核心dll”是<code>libmxnet.dll</code>，我们需要做的事情就是搞清它所依赖的dll都有什么。</p><p>利用Visual Studio的dumpbin工具，可以查看一个dll所依赖的其他dll。</p><p>打开Developer Command Prompt，进入<code>libmxnet.dll</code>所在文件夹（位于<code>Python\Python36\lib\site-packages\mxnet</code>），执行以下命令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">dumpbin /dependents libmxnet.dll<br></code></pre></td></tr></table></figure><p>得到如下结果。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs bash">Dump of file libmxnet.dll<br><br>File Type: DLL<br><br>  Image has the following dependencies:<br><br>    libopenblas.dll<br>    cudnn64_7.dll<br>    cublas64_91.dll<br>    cufft64_91.dll<br>    cusolver64_91.dll<br>    curand64_91.dll<br>    nvrtc64_91.dll<br>    nvcuda.dll<br>    KERNEL32.dll<br>    USER32.dll<br>    VCOMP140.DLL<br><br>  Summary<br><br>    ......（这部分省略）<br></code></pre></td></tr></table></figure><p>我们需要的是第一部分，在这里列出了<code>libmxnet.dll</code>所依赖的dll。在<code>libmxnet.dll</code>所在文件夹和<code>C:\Windows\System32</code>里逐个对比，我缺少的是以下几个dll。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">cublas64_91.dll<br>cufft64_91.dll<br>cusolver64_91.dll<br>curand64_91.dll<br>nvrtc64_91.dll<br></code></pre></td></tr></table></figure><p>看名字就和CUDA有关，搜索了一下确实如此。按照常规的套路，把CUDA安装目录里相应的dll复制到<code>C:\Windows\System32</code>就OK了。</p><p>（对于正常安装了CUDA的同学，看到了这里，复制了那几个dll后，工作就结束了）</p><p>但我惊讶地发现，我好像没有CUDA安装目录。一瞬间我惊呆了。那我的<code>nvcuda.dll</code>是从哪飞来的…我之前用GPU版的Pytorch和Waifu2x又是怎么用的…难道我只下了一个<code>nvcuda.dll</code>…（好像真的是…）</p><p>重新装CUDA，但安装失败了，也许因为我已经有<code>nvcuda.dll</code>导致冲突。<del>别问，问就是我不会。</del></p><p>不管那么多了，直接用压缩软件打开CUDA的exe安装包，把上面几个dll解压出来、复制，完事大吉。执行前面查看版本号的命令，终于看到可爱的版本号了，安装成功。</p><p>顺带一提，对于我所安装的<code>mxnet-cu91</code>，对numpy的版本有限制，版本上限是<code>1.14.6</code>，我原本的<code>numpy 1.15.x</code>被卸掉了；我专门试了一下<code>mxnet-cu90</code>和<code>mxnet-cu92</code>，都没有此限制。和我一样安装了<code>mxnet-cu91</code>的同学可能要留心一下。</p><p>参考：<a href="https://stackoverflow.com/questions/54870595/oserror-winerror-126-module-could-not-be-found" target="_blank" rel="noopener">https://stackoverflow.com/questions/54870595/oserror-winerror-126-module-could-not-be-found</a></p>]]></content>
    
    
    <categories>
      
      <category>工具使用</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MXNet</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>从Avisynth到VapourSynth：一些方法的迁移</title>
    <link href="/2019/10/20/from-avs-to-vs/"/>
    <url>/2019/10/20/from-avs-to-vs/</url>
    
    <content type="html"><![CDATA[<p>VapourSynth经过四十多个版本的更新，滤镜已经丰富。但Avisynth时代留下了诸多的教程，似乎仍是VapourSynth无法比拟的。</p><p>因此，我试着将前辈们一些用avs写的教程迁移到vs上，希望能够给大家做一点微小的贡献。</p><p>有什么错误的地方还请大家指正~</p><p>默认import如下内容。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> vapoursynth <span class="hljs-keyword">as</span> vs<br>core = vs.get_core()<br><br><span class="hljs-keyword">import</span> mvsfunc <span class="hljs-keyword">as</span> mvf<br><span class="hljs-keyword">import</span> havsfunc <span class="hljs-keyword">as</span> haf<br></code></pre></td></tr></table></figure><a id="more"></a><h3 id="NR-de-banding思路"><a href="#NR-de-banding思路" class="headerlink" title="NR de-banding思路"></a>NR de-banding思路</h3><blockquote><p>avs脚本出处：<a href="https://www.nmm-hd.org/newbbs/viewtopic.php?f=7&amp;t=1495#p12163" target="_blank" rel="noopener">https://www.nmm-hd.org/newbbs/viewtopic.php?f=7&amp;t=1495#p12163</a> 作者：mawen1250</p></blockquote><p>NR de-banding（去色带）思路，可以降低去色带的力度、提升效果。基本的思路是先扫去噪点层，再做去色带，做完后再把噪点层加回来。</p><p>其中NR指noise reduction，降噪的意思，很多处理都可以使用降噪做预处理，以提升效果。</p><h4 id="avs脚本"><a href="#avs脚本" class="headerlink" title="avs脚本"></a>avs脚本</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># stacked-16bit input</span><br>last = last <span class="hljs-comment"># this line can be ignored, just in case someone who doesn't understand it</span><br><br><span class="hljs-comment"># pre-filter</span><br>nr16 = last.Dither_removegrain16(<span class="hljs-number">11</span>, <span class="hljs-number">11</span>).Dither_removegrain16(<span class="hljs-number">20</span>, <span class="hljs-number">0</span>)<br><span class="hljs-comment"># get noise diff clip</span><br>noise = last.Dither_sub16(nr16, y=<span class="hljs-number">3</span>, u=<span class="hljs-number">3</span>, v=<span class="hljs-number">3</span>, dif=<span class="hljs-literal">True</span>)<br><span class="hljs-comment"># refine pre-filtered clip due to limited range of diff clip: [-32768, 32767], avoiding potential issue that the noise can not be fully added back</span><br>nr16 = last.Dither_sub16(noise, y=<span class="hljs-number">3</span>, u=<span class="hljs-number">3</span>, v=<span class="hljs-number">3</span>, dif=<span class="hljs-literal">True</span>)<br><span class="hljs-comment"># de-banding on pre-filtered clip</span><br>last = nr16<br>last = last.f3kdb(<span class="hljs-number">16</span>, <span class="hljs-number">40</span>, <span class="hljs-number">40</span>, <span class="hljs-number">40</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, input_mode=<span class="hljs-number">1</span>, output_mode=<span class="hljs-number">1</span>).Dither_limit_dif16(last, ref=nr16, thr=<span class="hljs-number">0.30</span>, elast=<span class="hljs-number">2.5</span>, y=<span class="hljs-number">3</span>, u=<span class="hljs-number">3</span>, v=<span class="hljs-number">3</span>)<br><span class="hljs-comment"># add back noise</span><br>last = last.Dither_add16(noise, y=<span class="hljs-number">3</span>, u=<span class="hljs-number">3</span>, v=<span class="hljs-number">3</span>, dif=<span class="hljs-literal">True</span>)<br><br><span class="hljs-comment"># stacked-16bit output</span><br>last<br></code></pre></td></tr></table></figure><h4 id="vs脚本"><a href="#vs脚本" class="headerlink" title="vs脚本"></a>vs脚本</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 16bit input: src16</span><br><br><span class="hljs-comment"># pre-filter</span><br>nr16   = core.rgvs.RemoveGrain(src16, [<span class="hljs-number">11</span>,<span class="hljs-number">11</span>]).rgvs.RemoveGrain([<span class="hljs-number">20</span>,<span class="hljs-number">0</span>])<br><span class="hljs-comment"># get noise diff clip</span><br>noise  = core.std.MakeDiff(src16, nr16, planes=[<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>]) <span class="hljs-comment"># By default all planes are processed. So the parameter for planes can be ignored.</span><br>nr16   = core.std.MakeDiff(src16, noise, planes=[<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>])<br><span class="hljs-comment"># de-banding on pre-filtered clip</span><br>deband = core.f3kdb.Deband(nr16, <span class="hljs-number">16</span>,<span class="hljs-number">40</span>,<span class="hljs-number">40</span>,<span class="hljs-number">40</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>, output_depth=<span class="hljs-number">16</span>)<br>deband = mvf.LimitFilter(deband, nr16, thr=<span class="hljs-number">0.30</span>, elast=<span class="hljs-number">2.5</span>, planes=[<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>])<br><span class="hljs-comment"># add back noise</span><br>deband = core.std.MergeDiff(deband, noise, planes=[<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>])<br></code></pre></td></tr></table></figure><p>在此基础上更复杂一点的用法。做完de-banding后，不把噪点全部加回来，而是对噪点层降噪。这就是SBR降噪的思路。</p><p>当然，如果是用KNLMeansCL这类降噪滤镜扫噪点层，在参数不太高的情况下，本身对画面的破坏就已经很小。如果想做降噪，可以不把噪点层加回来。</p><h3 id="Chroma-Shift的处理"><a href="#Chroma-Shift的处理" class="headerlink" title="Chroma Shift的处理"></a>Chroma Shift的处理</h3><blockquote><p>avs脚本出处：<a href="https://www.nmm-hd.org/newbbs/viewtopic.php?f=7&amp;t=1483&amp;p=12144#p12144" target="_blank" rel="noopener">https://www.nmm-hd.org/newbbs/viewtopic.php?f=7&amp;t=1483&amp;p=12144#p12144</a> 作者：mawen1250</p></blockquote><p>Chroma Shift（色度偏移）的处理。关于色度偏移，可以看一下mawen1250前辈的<a href="https://www.nmm-hd.org/newbbs/viewtopic.php?f=5&t=1208" target="_blank" rel="noopener">这个帖子</a>和EleonoreMizo前辈为fmtconv写的<a href="https://github.com/EleonoreMizo/fmtconv/blob/master/doc/fmtconv.html" target="_blank" rel="noopener">Doc</a>中<code>resample</code>函数的部分。</p><h4 id="avs脚本-1"><a href="#avs脚本-1" class="headerlink" title="avs脚本"></a>avs脚本</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Parameters for chroma shift, example for converting MPEG-1 chroma placement to MPEG-2 chroma placement</span><br>U_Horizontal_Shift = <span class="hljs-number">-0.25</span><br>U_Vertical_Shift = <span class="hljs-number">0</span><br>V_Horizontal_Shift = <span class="hljs-number">-0.25</span><br>V_Vertical_Shift = <span class="hljs-number">0</span><br><br><span class="hljs-comment"># 8bit YUV input</span><br><br><span class="hljs-comment"># Separate planes</span><br>Y = last<br>U = UToY8()<br>V = VToY8()<br><br><span class="hljs-comment"># Use resizer to achieve sub-pixel precision shift for each plane</span><br>U = U.Spline16Resize(U.Width(), U.Height(), U_Horizontal_Shift, U_Vertical_Shift)<br>V = V.Spline16Resize(V.Width(), V.Height(), V_Horizontal_Shift, V_Vertical_Shift)<br><br><span class="hljs-comment"># Merge planes back to YUV format</span><br>YToUV(U, V, Y)<br></code></pre></td></tr></table></figure><h4 id="vs脚本-1"><a href="#vs脚本-1" class="headerlink" title="vs脚本"></a>vs脚本</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Parameters for chroma shift, example for converting MPEG-1 chroma placement to MPEG-2 chroma placement</span><br>U_Horizontal_Shift = <span class="hljs-number">-0.25</span><br>U_Vertical_Shift   = <span class="hljs-number">0</span><br>V_Horizontal_Shift = <span class="hljs-number">-0.25</span><br>V_Vertical_Shift   = <span class="hljs-number">0</span><br><br><span class="hljs-comment"># YUV input: src</span><br><br><span class="hljs-comment"># Use resizer to achieve sub-pixel precision shift for each plane</span><br>result = core.fmtc.resample(src, src.width, src.height, sx=[<span class="hljs-number">0</span>, U_Horizontal_Shift, V_Horizontal_Shift], sy=[<span class="hljs-number">0</span>, U_Vertical_Shift, V_Vertical_Shift], planes=[<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">3</span>])<br></code></pre></td></tr></table></figure><h3 id="Chroma-Bleeding的处理"><a href="#Chroma-Bleeding的处理" class="headerlink" title="Chroma Bleeding的处理"></a>Chroma Bleeding的处理</h3><blockquote><p>avs脚本出处：<a href="https://www.nmm-hd.org/newbbs/viewtopic.php?f=7&amp;t=1587&amp;p=12668#p12651" target="_blank" rel="noopener">https://www.nmm-hd.org/newbbs/viewtopic.php?f=7&amp;t=1587&amp;p=12668#p12651</a> 作者：mawen1250</p></blockquote><p>Chroma Bleeding（色度溢出）的处理。详情可以点开上面的链接看一下原帖，mawen1250前辈做了说明。主要是用了AWarpSharp2系列的滤镜，以亮度平面为mask，将色度平面中溢出的部分砍掉。这也很好理解，多出来的就砍掉嘛~</p><p>顺带一提，收线也可用这个滤镜。道理类似，“收”就是砍的嘛~</p><h4 id="avs脚本-2"><a href="#avs脚本-2" class="headerlink" title="avs脚本"></a>avs脚本</h4><p>脚本是8bit YUV420输入，先升至16bit YUV444，再降至8bit YUV444处理色度溢出，继而升至16bit YUV444与未修正色度溢出的16bit YUV444源比较，最后保持16bit YUV444输出。</p><p>（mawen1250前辈的教程写于2015年2月，avs版AWarpSharp2在2018年3月更新的v2.0.0版中添加了16bit支持，上述反复升降位深的做法已不必要）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># YUV420P8 input</span><br>nnedi3_resize16(lsb_in=<span class="hljs-literal">False</span>, lsb=<span class="hljs-literal">True</span>, output=<span class="hljs-string">"YV24"</span>, ratiothr=<span class="hljs-number">2.25</span>, kernel_u=<span class="hljs-string">"Bicubic"</span>, a1=<span class="hljs-number">0.6</span>, a2=<span class="hljs-number">0.4</span>)<br><br>src16 = last<br>DitherPost(mode=<span class="hljs-number">-1</span>)<br><br>warpe = ConvertToYV12().aSobel(<span class="hljs-number">128</span>, <span class="hljs-number">1</span>).aBlur(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>)<br>epp = YToUV(UToY().awarp(warpe, <span class="hljs-number">6</span>, <span class="hljs-number">1</span>), VToY().awarp(warpe, <span class="hljs-number">6</span>, <span class="hljs-number">1</span>), last)<br><br>Dither_limit_dif16(src16, epp.U16(), thr=<span class="hljs-number">1.0</span>, elast=<span class="hljs-number">2</span>, y=<span class="hljs-number">2</span>, u=<span class="hljs-number">3</span>, v=<span class="hljs-number">3</span>)<br><span class="hljs-comment"># YUV444P16 output</span><br></code></pre></td></tr></table></figure><h4 id="vs脚本-2"><a href="#vs脚本-2" class="headerlink" title="vs脚本"></a>vs脚本</h4><p>这里使用了dubhater前辈的<a href="https://github.com/dubhater/vapoursynth-awarpsharp2" target="_blank" rel="noopener">AWarpSharp2</a>移植，由于支持高位深，所以全程在16bit下处理。</p><p>在脚本的最后用<code>mvf.LimitFilter</code>做了限制，这是照抄mawen1250前辈的avs脚本。但avs脚本做限制是为了保留未处理部分的16bit精度（如前面所说，在avs版AWarpSharp2支持16bit前，不得不反复升降位深，这会带来精度的损失），在全程16bit处理的情况下，这个限制是否有必要，值得思考。<del>唔..我太笨了，就是这样</del></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># YUV420P8 input: src</span><br>src16 = mvf.Depth(src, <span class="hljs-number">16</span>)<br>src16 = core.fmtc.resample(src16, src.width, src.height, kernel=<span class="hljs-string">'bicubic'</span>, a1=<span class="hljs-number">0.6</span>, a2=<span class="hljs-number">0.4</span>, css=<span class="hljs-string">'444'</span>) <span class="hljs-comment"># Y plane isn't processed</span><br><br>warpe = mvf.GetPlane(core.warp.ASobel(src16, <span class="hljs-number">128</span>, <span class="hljs-number">1</span>).warp.ABlur(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>), plane=<span class="hljs-number">0</span>)<br>fixU  = core.warp.AWarp(mvf.GetPlane(src16, plane=<span class="hljs-number">1</span>), warpe, depth=<span class="hljs-number">6</span>, chroma=<span class="hljs-number">0</span>)<br>fixV  = core.warp.AWarp(mvf.GetPlane(src16, plane=<span class="hljs-number">2</span>), warpe, depth=<span class="hljs-number">6</span>, chroma=<span class="hljs-number">0</span>)<br>epp   = core.std.ShufflePlanes([src16, fixU, fixV], planes=[<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>], colorfamily=vs.YUV)<br><br>result = mvf.LimitFilter(src16, epp, thr=<span class="hljs-number">1.0</span>, elast=<span class="hljs-number">2.0</span>, planes=[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>])<br><span class="hljs-comment"># YUV444P16 output</span><br></code></pre></td></tr></table></figure><p>如果不想保持16bit YUV444输出，而是输出一般的16bit YUV420，则在进行上述处理后，再用<code>fmtc.resample</code>缩放即可。降低分辨率通常推荐用Spline（样条采样）系列中的<code>spline36</code>，<code>fmtc.resample</code>的默认参数就是它。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">result = core.fmtc.resample(result, src.width, src.height, kernel=<span class="hljs-string">'spline36'</span>, css=<span class="hljs-string">'420'</span>)<br></code></pre></td></tr></table></figure><p>当然，如果是以16bit YUV420输出，将<code>mvf.LimitFilter</code>的限制放到缩放后，将未拉伸色度平面的输入源与降回16bit YUV420的处理结果比较，可能会更好。因为这样多少限制了色度平面拉伸与缩小过程的损失。（我口胡的，不要打我呀~</p><h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>本来想打两个波浪线买一下萌，忘了markdown语法，结果变成了下面那个样子，太真实了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">（未完待续~~我才不会鸽的~）<br></code></pre></td></tr></table></figure><p>（未完待续<del>我才不会鸽的</del>）</p>]]></content>
    
    
    <categories>
      
      <category>图像处理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>VapourSynth</tag>
      
      <tag>Avisynth</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2019/10/17/hello-world/"/>
    <url>/2019/10/17/hello-world/</url>
    
    <content type="html"><![CDATA[<p>第一篇Blog，emmmm不知道要说什么…但总归要写点东西，不然会报错2333</p><p>正经的说一句，希望我能够，表里如一。</p><p>最后</p><p>“Hello World !”</p>]]></content>
    
    
    <categories>
      
      <category>日记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>文献阅读 1811.12231</title>
    <link href="/2019/07/05/literature001/"/>
    <url>/2019/07/05/literature001/</url>
    
    <content type="html"><![CDATA[<p>从文献中提到的几个模型开始——AlexNet，GoogleNet，VGG-16，ResNet-50。</p><p>（从头到尾读文献自然效率低，而按照抓实验重点的常规读文献方法，好像也不太适合现在的我。倒不如先看看文献中提到了哪些我不知道的概念与内容，先学一学，把文献阅读迅速上手。）</p><p>However，上面几个模型好像有点复杂，所以先从LeNet-5开始。</p><a id="more"></a><h3 id="LeNet-5"><a href="#LeNet-5" class="headerlink" title="LeNet-5"></a>LeNet-5</h3><p><a href="https://www.charleychai.com/blogs/2018/ai/NN/lenet.html" target="_blank" rel="noopener">https://www.charleychai.com/blogs/2018/ai/NN/lenet.html</a></p><p>1.卷积-&gt;局部感受野（同时卷积带来权值共享（？））<br>1.2 同一层中，多个卷积核独立操作，获得针对不同特征的输出。<br>2.为什么池化不采用全连接，（即采用子采样）：不对称连接获取更高级的特征<br>2.0 池化-&gt;（子）采样：直接扔掉部分数据，以期待保留主要特征，同时提升鲁棒性（减少次要信息的干扰）。</p>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>文献阅读</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Day14 Caffe实用工具</title>
    <link href="/2019/07/04/caffe-day14/"/>
    <url>/2019/07/04/caffe-day14/</url>
    
    <content type="html"><![CDATA[<p>《21天实战Caffe》学习笔记第14天</p><p>我觉得读源码是一方面，但或许就目前阶段而言，（像操作员工一样）掌握使用方法（和Day14介绍的工具）相对而言是更重要的。</p><a id="more"></a><h3 id="中篇整体的感受"><a href="#中篇整体的感受" class="headerlink" title="中篇整体的感受"></a>中篇整体的感受</h3><p>整体的感受，大概是</p><p>源码部分分成三个部分——caffe特色的.proto参数文件和C++的hpp、cpp文件。</p>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Caffe</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Day19 放之四海而皆准</title>
    <link href="/2019/06/30/caffe-day19/"/>
    <url>/2019/06/30/caffe-day19/</url>
    
    <content type="html"><![CDATA[<p>《21天实战Caffe》学习笔记第19天</p><h3 id="艺术风格迁移"><a href="#艺术风格迁移" class="headerlink" title="艺术风格迁移"></a>艺术风格迁移</h3><p>运行<a href="http://github.com/fzliu/style-transfer" target="_blank" rel="noopener">http://github.com/fzliu/style-transfer</a>的脚本，运行中有几个小问题。</p><p>测试命令如下。</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs maxima">cd <span class="hljs-built_in">style</span>-transfer<br>python <span class="hljs-built_in">style</span>.py -s images/<span class="hljs-built_in">style</span>/starry_night.jpg -c images/<span class="hljs-built_in">content</span>/johannesburg.jpg -g -<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>（以下几个Error依次发生，即解决Error 1后才引发Error 2。）</p><h4 id="Error-1"><a href="#Error-1" class="headerlink" title="Error 1"></a>Error 1</h4><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs delphi">ValueError: can <span class="hljs-keyword">not</span> convert <span class="hljs-keyword">object</span> <span class="hljs-keyword">to</span> float64.<br></code></pre></td></tr></table></figure><p>根据<a href="https://github.com/BVLC/caffe/issues/438" target="_blank" rel="noopener">https://github.com/BVLC/caffe/issues/438</a>中@RawanMG的说法，可以使用matplotlib解决这个问题。</p><p>即在<code>style.py</code>开头添加如下语句。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> skimage <span class="hljs-keyword">import</span> io; io.use_plugin(<span class="hljs-string">'matplotlib'</span>)<br></code></pre></td></tr></table></figure><p>Error 1解决。</p><p>（这个Error可能是我的python site-packages版本较旧的原因？）</p><a id="more"></a><h4 id="Error-2"><a href="#Error-2" class="headerlink" title="Error 2"></a>Error 2</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">ImportError:</span> <span class="hljs-literal">No</span> <span class="hljs-string">module</span> <span class="hljs-string">named</span> <span class="hljs-string">Tkinter</span><br></code></pre></td></tr></table></figure><p>缺少Tkinter包，安装即可。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">yum <span class="hljs-keyword">install</span> tkinter<br></code></pre></td></tr></table></figure><p>测试通过。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> Tkinter<br></code></pre></td></tr></table></figure><p>Error 2解决。</p><h4 id="Error-3"><a href="#Error-3" class="headerlink" title="Error 3"></a>Error 3</h4><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino">IOError: decoder jpeg <span class="hljs-keyword">not</span> <span class="hljs-built_in">available</span><br></code></pre></td></tr></table></figure><p>没有jpeg解码器，安装即可。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">yum <span class="hljs-keyword">install</span> libjpeg-devel<br></code></pre></td></tr></table></figure><p>根据<a href="https://stackoverflow.com/questions/8915296/python-image-library-fails-with-message-decoder-jpeg-not-available-pil" target="_blank" rel="noopener">https://stackoverflow.com/questions/8915296/python-image-library-fails-with-message-decoder-jpeg-not-available-pil</a>的说法，需要重装相应的pyhon site-packages，涉及PIL和Pillow。</p><p>根据<a href="https://blog.csdn.net/qq562029186/article/details/52972152" target="_blank" rel="noopener">https://blog.csdn.net/qq562029186/article/details/52972152</a>，得知Pillow是PIL的替代品，且我目前的Python2安装的就是Pillow，所以重装Pillow。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">pip2 uninstall Pillow<br>pip2 install Pillow==<span class="hljs-number">2.3</span><span class="hljs-number">.0</span><br></code></pre></td></tr></table></figure><p>（限制版本是防止pyhon site-packages间相互依赖、引发冲突，或不支持Python2。）</p><p>Error 3解决。</p><h4 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h4><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-tag">style</span><span class="hljs-selector-class">.py</span><span class="hljs-selector-pseudo">:main</span><span class="hljs-selector-pseudo">:21</span><span class="hljs-selector-pseudo">:22</span><span class="hljs-selector-pseudo">:07.489</span> <span class="hljs-selector-tag">--</span> <span class="hljs-selector-tag">Starting</span> <span class="hljs-selector-tag">style</span> <span class="hljs-selector-tag">transfer</span>.<br><span class="hljs-selector-tag">style</span><span class="hljs-selector-class">.py</span><span class="hljs-selector-pseudo">:main</span><span class="hljs-selector-pseudo">:21</span><span class="hljs-selector-pseudo">:22</span><span class="hljs-selector-pseudo">:07.489</span> <span class="hljs-selector-tag">--</span> <span class="hljs-selector-tag">Running</span> <span class="hljs-selector-tag">net</span> <span class="hljs-selector-tag">on</span> <span class="hljs-selector-tag">CPU</span>.<br><span class="hljs-selector-tag">style</span><span class="hljs-selector-class">.py</span><span class="hljs-selector-pseudo">:main</span><span class="hljs-selector-pseudo">:21</span><span class="hljs-selector-pseudo">:22</span><span class="hljs-selector-pseudo">:07.683</span> <span class="hljs-selector-tag">--</span> <span class="hljs-selector-tag">Successfully</span> <span class="hljs-selector-tag">loaded</span> <span class="hljs-selector-tag">images</span>.<br><span class="hljs-selector-tag">style</span><span class="hljs-selector-class">.py</span><span class="hljs-selector-pseudo">:main</span><span class="hljs-selector-pseudo">:21</span><span class="hljs-selector-pseudo">:22</span><span class="hljs-selector-pseudo">:35.974</span> <span class="hljs-selector-tag">--</span> <span class="hljs-selector-tag">Successfully</span> <span class="hljs-selector-tag">loaded</span> <span class="hljs-selector-tag">model</span> <span class="hljs-selector-tag">vgg16</span>.<br><span class="hljs-selector-tag">Optimizing</span>:   <span class="hljs-selector-tag">1%</span> |<span class="hljs-selector-tag">-</span>                                                                                                                           | <span class="hljs-selector-tag">ETA</span>:  <span class="hljs-selector-tag">20</span><span class="hljs-selector-pseudo">:25</span><span class="hljs-selector-pseudo">:50</span><br></code></pre></td></tr></table></figure><p>由于只用了CPU，运行速度过慢，放弃了，至少代码是能正常运行的。</p><h4 id="一点感想"><a href="#一点感想" class="headerlink" title="一点感想"></a>一点感想</h4><p>艺术风格迁移的核心思路是图像的“内容”和“风格”看似为一个整体，但却是可以分开表达的。基于此，有两个输入——想要的内容和想要的风格，进而获得艺术迁移的结果。</p><p>也就是说，从一张图片上可以剥离出独立于物体概念的风格信息。比如有一张煎蛋的真实照片，那么就可以分离出“煎蛋”这个概念、这个物体，同时分离出“现实拍摄”这一风格。进而以这张图片的“煎蛋”概念作为内容输入，以另一张图片的动画风格作为风格，就能获得动画煎蛋的图片。</p><p>这有些像经典图像处理中的高频信息，人们很难感受到、或者说不是人们关注的重点，但这些高频信息确实能够影响图像清晰度、图像体积乃至记录其他肉眼看不到的信息。</p><p>应当是这才是深度学习发展的一个思路——总归要有思路，才能去用深度学习的工具；而不能说就只盯着输入输出，把深度学习完全当成一个黑箱，只管扔进去和出来的东西。</p><h3 id="自然语言处理（nlp-caffe）"><a href="#自然语言处理（nlp-caffe）" class="headerlink" title="自然语言处理（nlp-caffe）"></a>自然语言处理（nlp-caffe）</h3><h4 id="编译过程"><a href="#编译过程" class="headerlink" title="编译过程"></a>编译过程</h4><p>（编译环境：CentOS 7.6 ）</p><p>用nlpcaffe自带的<code>makefile.config</code>，在改成仅CPU模式（<code>CPU := 1</code>）并检查了python路径后，开始编译。</p><p>但报错。报错内容是缺少cblas。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros">cannot <span class="hljs-builtin-name">find</span> -lcblas<br>cannot <span class="hljs-builtin-name">find</span> -latlas<br></code></pre></td></tr></table></figure><p>查了一下解决方法，有人说CentOS下没有cblas，需用tatlas和satlbas代替，应该将<code>makefile</code>中的cblas和atlas替换掉（CentOS论坛上也有类似的说法）。</p><p>但我按上述方法做了之后，仍是同样的报错。又去看了一下caffe的<code>makefile</code>，相应地方写的也是cblas——所以这么写也没问题吧。</p><p>于是直接将之前编译caffe的<code>makefile.config</code>复制过来，再编译就正常了。</p><p>（粗看没发现这两个<code>makefile.config</code>有什么区别orz…）</p><h4 id="共存的问题"><a href="#共存的问题" class="headerlink" title="共存的问题"></a>共存的问题</h4><p>但其实我好奇一件事情，虽然caffe没有写入环境变量，调用不同版本的caffe对应好路径就OK，但相应的接口怎么办？</p><p>比如在Python下<code>import caffe</code>，这里import进来的caffe是哪个caffe？最后一次编译的吗？</p><h4 id="训练模型"><a href="#训练模型" class="headerlink" title="训练模型"></a>训练模型</h4><p>操作和看日志已经比较熟练了</p><p>但又发生了一件尴尬的事..这个模型训练的是啥…orz…</p><h4 id="模型结构图"><a href="#模型结构图" class="headerlink" title="模型结构图"></a>模型结构图</h4><p>画example的结构模型画了大概20min orz…</p><p>（而且似乎最后什么都没有…）</p>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Caffe</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Day18 关于ILSVRC不得不说的一些事儿</title>
    <link href="/2019/06/28/caffe-day18/"/>
    <url>/2019/06/28/caffe-day18/</url>
    
    <content type="html"><![CDATA[<p>《21天实战Caffe》学习笔记第18天</p><p>因为ILSVRC数据集过于庞大，没有操作。</p><p>因为涉及到去均值，回去读了一下Day14中提到的计算均值代码。</p><p>这一代码相对于前面求解器的实现、传播的实现等代码，看上去简单了。</p><p>又看了一下一个caffe应用实例的代码，代码更是简单了。</p><a id="more"></a><p>另外就是，Day10中习题，问仅有<code>.solverstate</code>文件能否继续训练。在Day18中写道，可以继续训练。</p>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Caffe</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Day17 Caffe迁移和部署</title>
    <link href="/2019/06/28/caffe-day17/"/>
    <url>/2019/06/28/caffe-day17/</url>
    
    <content type="html"><![CDATA[<p>《21天实战Caffe》学习笔记第17天</p><h3 id="docker的使用"><a href="#docker的使用" class="headerlink" title="docker的使用"></a>docker的使用</h3><h4 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h4><p>主要是讲了docker的安装、配置与基本使用，内容相对而言不多。</p><p>把运行docker时的log保存了下来，多少有些帮助。</p><p>根据<a href="https://mirrors.tuna.tsinghua.edu.cn/help/centos/" target="_blank" rel="noopener">https://mirrors.tuna.tsinghua.edu.cn/help/centos/</a>，将yum源换成清华源，但似乎还是（因为网不好）导致超时错误。</p><a id="more"></a><h4 id="一点感想"><a href="#一点感想" class="headerlink" title="一点感想"></a>一点感想</h4><p>Anaconda与Docker的区别。</p><p>（我当然知道这两个不是同一层次上的东西，但作为项目和环境管理工具，多少还是有些像的）</p>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Caffe</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Day16 Caffe可视化方法</title>
    <link href="/2019/06/27/caffe-day16/"/>
    <url>/2019/06/27/caffe-day16/</url>
    
    <content type="html"><![CDATA[<p>《21天实战Caffe》学习笔记第16天</p><h3 id="数据可视化"><a href="#数据可视化" class="headerlink" title="数据可视化"></a>数据可视化</h3><p>把书上的matlab代码敲出来即可，对mnist手写数字数据集和cifar10图片数据集的数据做可视化。</p><h3 id="模型可视化"><a href="#模型可视化" class="headerlink" title="模型可视化"></a>模型可视化</h3><h4 id="网络结构可视化"><a href="#网络结构可视化" class="headerlink" title="网络结构可视化"></a>网络结构可视化</h4><h5 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h5><p>用以下命令安装的python-devel，还是2.7版本的。（那我前面装python 3.7是白忙活了？）</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">yum <span class="hljs-keyword">install</span> python-devel<br></code></pre></td></tr></table></figure><p>numpy和<code>/caffe/python/requirements.txt</code>清单里的包，均用pip3安装的。</p><p>安装时报错</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs subunit"><span class="hljs-keyword">ERROR: </span>matplotlib 3.1.0 has requirement python-dateutil&gt;=2.1, but you'll have python-dateutil 1.5 which is incompatible.<br><span class="hljs-keyword">ERROR: </span>pandas 0.24.2 has requirement python-dateutil&gt;=2.5.0, but you'll have python-dateutil 1.5 which is incompatible.<br></code></pre></td></tr></table></figure><p>因为清单里要求python-dateutil的版本不能大于2，所以出现上述问题。但只是不兼容，而上述三个包都装上了，所以先这样。</p><a id="more"></a><h5 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h5><p>不知道为什么，要重新编译一次caffe。</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">cd</span> <span class="hljs-string">~/caffe</span><br><span class="hljs-attr">make</span> <span class="hljs-string">clean</span><br><span class="hljs-attr">make</span> <span class="hljs-string">-j</span><br></code></pre></td></tr></table></figure><p>编译时报错。（我不记得之前编译有没有报错了）</p><p>改用</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">make</span><br></code></pre></td></tr></table></figure><p>编译通过。</p><p>编译pycaffe。</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">make pycaffe</span><br></code></pre></td></tr></table></figure><p>报错，找不到numpy名下的头文件。</p><p>（通过pip安装numpy还是没法直接用）</p><p>yum里<code>python-numpy</code>叫<code>numpy</code>。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">yum <span class="hljs-keyword">install</span> numpy<br></code></pre></td></tr></table></figure><p>之后pycaffe编译成功。</p><h5 id="运行与画图"><a href="#运行与画图" class="headerlink" title="运行与画图"></a>运行与画图</h5><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">cd ~/caffe/python<br>python3 draw_net<span class="hljs-selector-class">.py</span> ../models/bvlc_reference_caffenet/train_val<span class="hljs-selector-class">.prototxt</span> caffenet.png<br></code></pre></td></tr></table></figure><p>不行，用<code>python</code>执行也不行，但报错信息不一样。</p><p>直接在命令行下调用python，测试</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> caffe<br></code></pre></td></tr></table></figure><p>无论是<code>python3</code>还是<code>python</code>，都不行，同样报错信息不一样。</p><p>（完蛋…）</p><h4 id="检查报错"><a href="#检查报错" class="headerlink" title="检查报错"></a>检查报错</h4><h5 id="报错内容"><a href="#报错内容" class="headerlink" title="报错内容"></a>报错内容</h5><p>用<code>python3</code>调用<code>draw_net.py</code>和控制台<code>import caffe</code>的报错都指向同一个问题，大概是“有冲突”？</p><p>用<code>python</code>调用上述两者似乎也是指向同一个问题，找不到<code>xxx.io</code>。</p><p>虽然caffe已经支持Python3，但从报错信息上看，似乎是用Python2更加靠谱一点。下面解决Pyhon2的报错。</p><h5 id="缺失的包"><a href="#缺失的包" class="headerlink" title="缺失的包"></a>缺失的包</h5><p>报错提示的缺失文件指向一个Python包，那个包我已经安装了。安装的时候我使用<code>pip3</code>安装的，看到报错后又用<code>pip</code>装了一次，但似乎对那个包没什么改动，倒是依赖的限制版本的python-dateutil给强制升级了。</p><p>装完了仍是同样的报错。</p><p>在Github的issue上有人说需要将<code>~/caffe/python</code>添加至环境变量，但我添加后仍是同样的报错。</p><p>而在stackoverflow上甚至有人在python脚本里写了<code>import ...</code>，但仍有同样的报错。</p><p>所以结论应该很明显了，类似numpy，即使用pip给python装了相应的包，也要用yum再装一次？</p><p>但无论是<code>...</code>还是<code>python-...</code>都找不到那个包…</p><p>而且官方教程中也仅有Ubuntu下的安装命令…</p><h4 id="换个思路"><a href="#换个思路" class="headerlink" title="换个思路"></a>换个思路</h4><h5 id="从编译文件入手"><a href="#从编译文件入手" class="headerlink" title="从编译文件入手"></a>从编译文件入手</h5><p>从caffe的编译文件<code>makefile.config</code>入手，看懂了<code>makefile.config</code>文件，发现在编译时忽略了对Python路径的依赖，而我又怕改路径改出乱子。所以根据<code>makefile.config</code>中的注释，将需要的文件复制到对应位置，使<code>makefile.config</code>的默认路径有效。</p><p>主要一点就是，默认路径指向<code>usr/lib</code>，而caffe编译所需的Pyhon相关文件，我这边是在<code>usr/lib64</code>里。</p><p>另外就Python包——site packages和dist packages的问题。</p><h5 id="重新安装依赖"><a href="#重新安装依赖" class="headerlink" title="重新安装依赖"></a>重新安装依赖</h5><p>解决了前述路径问题，自然要重新编译一次，然后也搞明白了目前的<code>pip</code>和<code>pip3</code>命令都指向Python3（这也回答了<a href="https://yimino.github.io/2019/06/27/g-cmake-python/" target="_blank" rel="noopener">https://yimino.github.io/2019/06/27/g-cmake-python/</a>的疑问），所以在安装了Python2的pip后</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">yum <span class="hljs-keyword">install</span> python-pip<br></code></pre></td></tr></table></figure><p>重新安装其他依赖包。</p><p>在前面有不同包之间相互依赖，导致版本冲突的问题，所以这次按照<code>/caffe/python/requirements.txt</code>的内容，重写了<code>requirements.txt</code>，把里面的<code>&gt;=</code>改成<code>==</code>，能安装低版本就尽量安装低版本。</p><p>然后再编译caffe和pycaffe。</p><p>至此，<code>import caffe</code>终于正常了。</p><p>（虽然有个warning，但应该无伤大雅。）</p><h5 id="再次画图"><a href="#再次画图" class="headerlink" title="再次画图"></a>再次画图</h5><p>执行，</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">python draw_net<span class="hljs-selector-class">.py</span> ../models/bvlc_reference_caffenet/train_val<span class="hljs-selector-class">.prototxt</span> caffenet.png<br></code></pre></td></tr></table></figure><p>报错。</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">OSError: [Errno <span class="hljs-number">2</span>] "dot" <span class="hljs-keyword">not</span> <span class="hljs-built_in">found</span> <span class="hljs-keyword">in</span> <span class="hljs-type">path</span>.<br></code></pre></td></tr></table></figure><p>根据<a href="https://github.com/BVLC/caffe/issues/4911" target="_blank" rel="noopener">https://github.com/BVLC/caffe/issues/4911</a>，需要安装graphviz包。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">yum <span class="hljs-keyword">install</span> graphviz<br></code></pre></td></tr></table></figure><p>至此，<code>draw_net.py</code>脚本得以正常运行，网络结构图get！</p><h4 id="网络权值可视化"><a href="#网络权值可视化" class="headerlink" title="网络权值可视化"></a>网络权值可视化</h4><h5 id="安装Matlab"><a href="#安装Matlab" class="headerlink" title="安装Matlab"></a>安装Matlab</h5><p><strong>虚拟机复制文件的缓存</strong></p><p>首先解决一下主机与虚拟机之间复制文件的缓存问题。</p><p>从虚拟机向主机复制文件，缓存于Windows主机的<code>C:\Users\&quot;User Name&quot;\AppData\Local\Temp\vmware-&quot;User Name&quot;\VMwareDnD</code>中，直接删除即可。</p><p>从主机向虚拟机复制文件，缓存于Linux虚拟机的<code>/root/.cache/vmware/drag_and_drop</code>中，查看日期信息，</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli"><span class="hljs-keyword">cd</span> <span class="hljs-string">/root/.cache/vmware/drag_and_drop</span><br><span class="hljs-keyword">ls</span> -lht<br></code></pre></td></tr></table></figure><p>查看文件大小，</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">du -h --max-depth=<span class="hljs-number">0</span> <span class="hljs-regexp">/root/</span>.cache<span class="hljs-regexp">/vmware/</span>drag_and_drop<span class="hljs-regexp">/*</span><br></code></pre></td></tr></table></figure><p>删除缓存。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">rm -rf <span class="hljs-regexp">/root/</span>.cache<span class="hljs-regexp">/vmware/</span>drag_and_drop<span class="hljs-regexp">/*</span><br></code></pre></td></tr></table></figure><p>（但我由主机向虚拟机复制文件后，虚拟机所在磁盘的容量似乎减少了复制文件大小的两倍，在清除虚拟机缓存后也是如此…是我的错觉吗…）</p><p><strong>安装过程</strong></p><p>（看安装包里的教程即可）</p><p>挂载iso。</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gams">mount -t auto -o <span class="hljs-keyword">loop</span> <span class="hljs-symbol">$</span>PATH<span class="hljs-symbol">$</span>/R2018b_glnxa64_dvd1.iso /mnt/iso<br></code></pre></td></tr></table></figure><p>若提示</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim">moun<span class="hljs-variable">t:</span> /dev/loop0 <span class="hljs-keyword">is</span> <span class="hljs-keyword">write</span>-protected, mounting <span class="hljs-keyword">read</span>-<span class="hljs-keyword">only</span><br></code></pre></td></tr></table></figure><p>则</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">cd</span> <span class="hljs-string">/</span><br><span class="hljs-attr">chmod</span> <span class="hljs-string">755 mnt</span><br></code></pre></td></tr></table></figure><p>挂载成功后，不要进入挂载目录，而是在随便的另外一个目录下执行安装命令。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">/mnt/i</span>so<span class="hljs-regexp">/install</span><br></code></pre></td></tr></table></figure><p>我这里提示了</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-string">cp:</span> cannot stat ‘<span class="hljs-regexp">/mnt/</span>iso<span class="hljs-regexp">/sys/</span>java<span class="hljs-regexp">/jre/</span>glnxa64<span class="hljs-regexp">/jre/</span>man<span class="hljs-regexp">/ja_JP.UTF-8’: Input/</span>output error<br></code></pre></td></tr></table></figure><p>但似乎没发现什么问题。</p><p>然后即可进入图像安装界面，按提示操作即可。</p><h3 id="学习曲线"><a href="#学习曲线" class="headerlink" title="学习曲线"></a>学习曲线</h3><p>这个先放一放，之前用matlab神经网络工具箱时看过类似的曲线，而且又没有进一步理解曲线的经验和知识。</p>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Caffe</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>编译AV1编码器libaom的记录</title>
    <link href="/2019/06/15/av1-aom/"/>
    <url>/2019/06/15/av1-aom/</url>
    
    <content type="html"><![CDATA[<h3 id="起始编译过程"><a href="#起始编译过程" class="headerlink" title="起始编译过程"></a>起始编译过程</h3><h4 id="pthread-h文件"><a href="#pthread-h文件" class="headerlink" title="pthread.h文件"></a><code>pthread.h</code>文件</h4><p>提示缺失<code>pthread.h</code>文件</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">Looking <span class="hljs-keyword">for</span> pthread.h - <span class="hljs-keyword">not</span> <span class="hljs-built_in">found</span><br></code></pre></td></tr></table></figure><p>根据教程<a href="https://blog.csdn.net/qianchenglenger/article/details/16907821" target="_blank" rel="noopener">https://blog.csdn.net/qianchenglenger/article/details/16907821</a>，在windows下配置pthread。</p><p>下载<code>pthreads-w32-2-9-1-release.zip</code>，由于年久失修，需要在镜像站下载<br><a href="https://sourceware.org/mirrors.html" target="_blank" rel="noopener">https://sourceware.org/mirrors.html</a>-&gt;<a href="https://mirrors.kernel.org/sourceware/pthreads-win32/" target="_blank" rel="noopener">https://mirrors.kernel.org/sourceware/pthreads-win32/</a>。</p><p>具体操作只涉及<code>/Pre-built.2</code>中的文件。</p><p>1.将<code>/Pre-built.2/include</code>和<code>/Pre-built.2/lib</code>的文件分别放入VS 2019的对应文件夹下。</p><p>2.将<code>/Pre-built.2/dll</code>中<code>/x64</code>和<code>/x86</code>的文件分别放入<code>system32</code>和<code>SysWOW64</code>中。</p><a id="more"></a><h4 id="再次pthread-h文件"><a href="#再次pthread-h文件" class="headerlink" title="再次pthread.h文件"></a>再次<code>pthread.h</code>文件</h4><p>但完成上述操作后，仍找不到<code>pthread.h</code>文件</p><p>虽然命令行终端中显示的报错内容与之前一致，但在<code>Error.log</code>中，增加了一行报错信息。</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lasso"><span class="hljs-params">...</span>\pthread.h error C2011:  <span class="hljs-string">'timespec'</span>: <span class="hljs-string">'struct'</span> <span class="hljs-keyword">type</span> redefinition <span class="hljs-params">...</span><br></code></pre></td></tr></table></figure><p>通过这个报错信息可知，我们上一步向VS 2019中添加头文件等操作是起了作用的，虽然终端上仍说找不到<code>pthread.h</code>文件，但报错信息表明cmake已经找到了<code>pthread.h</code>文件。</p><p>在<code>pthread.h</code>文件内添加</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> HAVE_STRUCT_TIMESPEC </span><br><span class="hljs-comment">// add by https://blog.csdn.net/user11223344abc/article/details/80536809</span><br></code></pre></td></tr></table></figure><p>后，终于能找到<code>pthread.h</code>文件</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">Looking <span class="hljs-keyword">for</span> pthread<span class="hljs-selector-class">.h</span> - found<br></code></pre></td></tr></table></figure><p>但又出现新的问题。</p><p>终端下</p><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs haml">-<span class="ruby">- Performing Test CMAKE_HAVE_LIBC_PTHREAD</span><br><span class="ruby">-- Performing Test CMAKE_HAVE_LIBC_PTHREAD - Failed</span><br><span class="ruby">-- Looking <span class="hljs-keyword">for</span> pthread_create <span class="hljs-keyword">in</span> pthreads</span><br><span class="ruby">-- Looking <span class="hljs-keyword">for</span> pthread_create <span class="hljs-keyword">in</span> pthreads - <span class="hljs-keyword">not</span> found</span><br><span class="ruby">-- Looking <span class="hljs-keyword">for</span> pthread_create <span class="hljs-keyword">in</span> pthread</span><br><span class="ruby">-- Looking <span class="hljs-keyword">for</span> pthread_create <span class="hljs-keyword">in</span> pthread - <span class="hljs-keyword">not</span> found</span><br><span class="ruby">-- Check <span class="hljs-keyword">if</span> compiler accepts -pthread</span><br><span class="ruby">-- Check <span class="hljs-keyword">if</span> compiler accepts -pthread - no</span><br></code></pre></td></tr></table></figure><p><code>Error.log</code>中</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">cannot <span class="hljs-built_in">open</span> <span class="hljs-built_in">file</span> <span class="hljs-string">'pthreads.lib'</span><br></code></pre></td></tr></table></figure><p>把放入系统内存的dll重新向<code>tools</code>下的<code>bin</code>文件夹放了一份，但不起作用，同样的报错。</p><p>在<a href="https://github.com/tensorflow/tensorflow/issues/5576" target="_blank" rel="noopener">https://github.com/tensorflow/tensorflow/issues/5576</a>，有人说把<code>Cmakelist.txt</code>中的</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lisp">find_package (<span class="hljs-name">Threads</span>)<br></code></pre></td></tr></table></figure><p>注释掉，因为在Windows下根本不需要pthreads。</p><p>但我试着单独注释掉上面那句话、注释掉整个if块，都不成功，仍得到同样的报错。</p><h4 id="Linux下的结果"><a href="#Linux下的结果" class="headerlink" title="Linux下的结果"></a>Linux下的结果</h4><p>在CentOS 7.6 虚拟机下编译</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> <span class="hljs-string">"aom的上级目录"</span><br>cmake aom<br></code></pre></td></tr></table></figure><p>同样报错</p><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs haml">-<span class="ruby">- Looking <span class="hljs-keyword">for</span> pthread_create</span><br><span class="ruby">-- Looking <span class="hljs-keyword">for</span> pthread_create - <span class="hljs-keyword">not</span> found</span><br><span class="ruby">-- Looking <span class="hljs-keyword">for</span> pthread_create <span class="hljs-keyword">in</span> pthreads</span><br><span class="ruby">-- Looking <span class="hljs-keyword">for</span> pthread_create <span class="hljs-keyword">in</span> pthreads - <span class="hljs-keyword">not</span> found</span><br><span class="ruby">-- Looking <span class="hljs-keyword">for</span> pthread_create <span class="hljs-keyword">in</span> pthread</span><br><span class="ruby">-- Looking <span class="hljs-keyword">for</span> pthread_create <span class="hljs-keyword">in</span> pthread - found</span><br></code></pre></td></tr></table></figure><p>日志文件中</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">cannot <span class="hljs-builtin-name">find</span> -lpthreads<br></code></pre></td></tr></table></figure><p>（其实在完成上述操作后，编译环境的铺垫已经完成。）</p><h3 id="VS模式编译"><a href="#VS模式编译" class="headerlink" title="VS模式编译"></a>VS模式编译</h3><h4 id="源码编译"><a href="#源码编译" class="headerlink" title="源码编译"></a>源码编译</h4><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros">cd <span class="hljs-string">"aom上级目录"</span><br>cmake aom <span class="hljs-attribute">-DAOM_TARGET_CPU</span>=generic<br></code></pre></td></tr></table></figure><p>使用以下两个命令编译，都不成功，而控制台输出不一致。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> <span class="hljs-string">"aom上级目录"</span><br>cmake aom<br></code></pre></td></tr></table></figure><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gams">cd aom<br><span class="hljs-function"><span class="hljs-title">cmake</span></span> ../aom<br></code></pre></td></tr></table></figure><p>正确而优雅的编译方式，在<code>/aom</code>所在目录下新建<code>/aom_build</code>，执行以下命令。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">cmake <span class="hljs-built_in">..</span>/aom <span class="hljs-attribute">-DAOM_TARGET_CPU</span>=generic<br></code></pre></td></tr></table></figure><p>至此，cmake步骤完成，生成包含<code>aom.sln</code>解决方法在内的VS项目。</p><h4 id="由sln到exe"><a href="#由sln到exe" class="headerlink" title="由sln到exe"></a>由sln到exe</h4><p>在VS中（将语言调整为中文Orz…，）设置好<code>release</code>模式后，开始build，以生成可执行的exe文件。</p><p>报错信息如下</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">aom_build\aom_av1_common<span class="hljs-selector-class">.vcxproj</span> : error MSB4014: 生成已意外停止，因为发生内部故障。<br>aom_build\aom_av1_common<span class="hljs-selector-class">.vcxproj</span> : error MSB4014: System<span class="hljs-selector-class">.Text</span><span class="hljs-selector-class">.EncoderFallbackException</span>: 无法将位于索引 <span class="hljs-number">1646</span> 处的 Unicode 字符 \uDD62 转换为指定的代码页。<br></code></pre></td></tr></table></figure><p>在将系统内部语言（非显示语言）更改为英语并重新编译源码后，仍是同样的报错。</p><p>（检查了其他报错文件，一样的报错）</p><p>好吧，专心去解决这个<code>索引1646</code>是什么鬼。</p><h4 id="安装VS的桌面版工程组件"><a href="#安装VS的桌面版工程组件" class="headerlink" title="安装VS的桌面版工程组件"></a>安装VS的桌面版工程组件</h4><p>虽然这个听上去是必要的，但装上后仍没什么用，一样的报错。</p><h4 id="安装工具"><a href="#安装工具" class="headerlink" title="安装工具"></a>安装工具</h4><p>没有装perl和Doxygen，前者必须，后者可选。</p><p>但装完后，除了在编译完成后能找到Doxygen，VS中多了一个要处理的文件和索引位置延后之外，本质上与之前无区别。</p><h3 id="关于GCC"><a href="#关于GCC" class="headerlink" title="关于GCC"></a>关于GCC</h3><p>期间安装了GCC，并将<code>MinGW-make.exe</code>改名为<code>make.exe</code>（据说是防止cmake找不到）；而之前安装的GnuWin32，其bin也叫<code>make.exe</code>，为了防止冲突，又将GnuWin32从环境变量中删去。</p><p>上述操作的一个结果是，在编译aom的doc时，提示缺少<code>dot</code>（但控制台只是提了一下，无waring和error，而且在后续用命令行成功编译exe后，同时编译出的doc也能正常打开（html的doc，而tex的还没看））。</p><h3 id="命令行编译"><a href="#命令行编译" class="headerlink" title="命令行编译"></a>命令行编译</h3><p>参考<a href="https://blog.csdn.net/u014426939/article/details/80080635" target="_blank" rel="noopener">https://blog.csdn.net/u014426939/article/details/80080635</a></p><h4 id="生成Cache"><a href="#生成Cache" class="headerlink" title="生成Cache"></a>生成Cache</h4><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros">cd build<br>cmake <span class="hljs-built_in">..</span>/aom <span class="hljs-attribute">-DAOM_TARGET_CPU</span>=generic<br></code></pre></td></tr></table></figure><h4 id="生成exe"><a href="#生成exe" class="headerlink" title="生成exe"></a>生成exe</h4><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli"><span class="hljs-keyword">cd</span> build<br>cmake <span class="hljs-params">--build</span> <span class="hljs-string">./</span> <span class="hljs-params">--config</span> Release<br></code></pre></td></tr></table></figure><p>相应exe文件在<code>/build/Release</code>中。</p>]]></content>
    
    
    <categories>
      
      <category>工具使用</category>
      
    </categories>
    
    
    <tags>
      
      <tag>构建与编译</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Day12 Caffe反向传播计算</title>
    <link href="/2019/06/06/caffe-day12/"/>
    <url>/2019/06/06/caffe-day12/</url>
    
    <content type="html"><![CDATA[<p>《21天实战Caffe》学习笔记第12天</p><h3 id="代码阅读"><a href="#代码阅读" class="headerlink" title="代码阅读"></a>代码阅读</h3><p>本以为是继续阅读昨天<code>/src/caffe/net.cpp</code>代码中余下关于反向传播的部分，但先讲了关于损失层与损失函数的代码。</p><p>这也是符合直观想法的，因为反向传播的关键，就是反向传递误差（即损失）。                                                                                                                                                                                                                                                                                                                                                                                                                                                  </p><p>今天主要是讲了损失层、损失函数的实现，在买了《21天学通C++》后，代码也逐渐看得进去了。</p><a id="more"></a><p>代码的主观印象就是各种模版类。</p><p>讲完损失层、损失函数，才继续昨天的<code>net.cpp</code>代码。</p><h3 id="代码所表达的思路"><a href="#代码所表达的思路" class="headerlink" title="代码所表达的思路"></a>代码所表达的思路</h3><p>Blob由data和diff——即数据和损失（误差）组成。反向传播从损失入手（比如我们熟知的BP误差反向传播算法），前向传播则从数据入手。</p>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Caffe</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>GPG密钥的配置与Git的使用</title>
    <link href="/2019/06/06/git-use-0/"/>
    <url>/2019/06/06/git-use-0/</url>
    
    <content type="html"><![CDATA[<p>一些Git命令</p><h3 id="一、添加GPG密钥"><a href="#一、添加GPG密钥" class="headerlink" title="一、添加GPG密钥"></a>一、添加GPG密钥</h3><h4 id="准备工作：安装与配置GPG"><a href="#准备工作：安装与配置GPG" class="headerlink" title="准备工作：安装与配置GPG"></a>准备工作：安装与配置GPG</h4><p>（虽然Git自带GPG，但这里仍单独安装了GPG程序）</p><p>在Windows下，安装Gpg4win，下载地址：<a href="https://gpg4win.org/download.html" target="_blank" rel="noopener">https://gpg4win.org/download.html</a>。</p><p>Gpg4win中包含了GnuPG（GnuPG即GPG的全名）。</p><p>安装完成后，执行如下命令，指定使用我们刚安装的GnuPG。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">git<span class="hljs-built_in"> config </span>--global gpg.program <span class="hljs-string">"C:\Program Files (x86)\GnuPG\bin\gpg.exe"</span><br></code></pre></td></tr></table></figure><h4 id="创建与设置密钥"><a href="#创建与设置密钥" class="headerlink" title="创建与设置密钥"></a>创建与设置密钥</h4><p>使用<code>--full-generate-key</code>选项，即在创建密钥时进行完整的密钥选项设置。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs verilog">gpg --full-<span class="hljs-keyword">generate</span>-key<br></code></pre></td></tr></table></figure><a id="more"></a><p><i class="fas fa-exclamation-triangle"></i>在旧版本GPG及对应的教程中，直接输入<code>gpg --gen-key</code>便会显示完整的密钥选项设置，至少在GPG 2.2及以后版本中，输入<code>gpg --gen-key</code>会直接创建默认设置的密钥（2048位，存在有效期限制）。</p><p>下面开始密钥设置。</p><h5 id="1-选择加密算法"><a href="#1-选择加密算法" class="headerlink" title="1.选择加密算法"></a>1.选择加密算法</h5><p>选择默认的1即可，表示加密和签名均使用 RSA 算法。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql">Please <span class="hljs-keyword">select</span> what kind <span class="hljs-keyword">of</span> <span class="hljs-keyword">key</span> you want:<br>   (<span class="hljs-number">1</span>) RSA <span class="hljs-keyword">and</span> RSA (<span class="hljs-keyword">default</span>)<br>   (<span class="hljs-number">2</span>) DSA <span class="hljs-keyword">and</span> Elgamal<br>   (<span class="hljs-number">3</span>) DSA (<span class="hljs-keyword">sign</span> <span class="hljs-keyword">only</span>)<br>   (<span class="hljs-number">4</span>) RSA (<span class="hljs-keyword">sign</span> <span class="hljs-keyword">only</span>)<br>Your selection?<br></code></pre></td></tr></table></figure><h5 id="2-设置密钥长度"><a href="#2-设置密钥长度" class="headerlink" title="2.设置密钥长度"></a>2.设置密钥长度</h5><p>最长为4096位，设置为4096位即可。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">RSA keys may be between <span class="hljs-number">1024</span> <span class="hljs-keyword">and</span> <span class="hljs-number">4096</span> bits long.<br>What keysize <span class="hljs-keyword">do</span> you want? (<span class="hljs-number">2048</span>)<br></code></pre></td></tr></table></figure><h5 id="3-设置密钥有效期"><a href="#3-设置密钥有效期" class="headerlink" title="3.设置密钥有效期"></a>3.设置密钥有效期</h5><p>选择0为永久有效。</p><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs vbnet">Please specify how <span class="hljs-built_in">long</span> the <span class="hljs-keyword">key</span> should be valid.<br>         <span class="hljs-number">0</span> = <span class="hljs-keyword">key</span> does <span class="hljs-keyword">not</span> expire<br>      &lt;n&gt;  = <span class="hljs-keyword">key</span> expires <span class="hljs-keyword">in</span> n days<br>      &lt;n&gt;w = <span class="hljs-keyword">key</span> expires <span class="hljs-keyword">in</span> n weeks<br>      &lt;n&gt;m = <span class="hljs-keyword">key</span> expires <span class="hljs-keyword">in</span> n months<br>      &lt;n&gt;y = <span class="hljs-keyword">key</span> expires <span class="hljs-keyword">in</span> n years<br><span class="hljs-keyword">Key</span> <span class="hljs-keyword">is</span> valid <span class="hljs-keyword">for</span>? (<span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><p>完成上述设置后，会要求确认。</p><h5 id="4-输入Github账号信息"><a href="#4-输入Github账号信息" class="headerlink" title="4.输入Github账号信息"></a>4.输入Github账号信息</h5><p>输入Github账号、Github邮箱地址、密钥备注（即Comment，此项可留空）。</p><h5 id="5-为密钥设置密码"><a href="#5-为密钥设置密码" class="headerlink" title="5.为密钥设置密码"></a>5.为密钥设置密码</h5><p>第4、5步按照流程进行即可。</p><p>至此，一个新的GPG密钥创建完成。</p><p>（我记不清创建随机数的过程了）</p><h4 id="输出密钥与上传"><a href="#输出密钥与上传" class="headerlink" title="输出密钥与上传"></a>输出密钥与上传</h4><h5 id="1-输出密钥"><a href="#1-输出密钥" class="headerlink" title="1.输出密钥"></a>1.输出密钥</h5><p>获取GPG key ID的两种方法：</p><p>1.在密钥创建完成后，会出现一长串字符，在这里似乎代表GPG key ID，以此ID执行以下命令，也是可以输出密钥文件的应该。</p><p>2.打开Gpg4win程序，在图形界面会看到4*4的字符，这个可以确认是GPG key ID，以此ID执行以下命令（不要输空格），输出密钥文件。</p><figure class="highlight dsconfig"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dsconfig"><span class="hljs-string">gpg </span><span class="hljs-built_in">--armor</span> <span class="hljs-built_in">--output</span> <span class="hljs-string">public-key.</span><span class="hljs-string">txt </span><span class="hljs-built_in">--export</span> <span class="hljs-string">"GPG key ID"</span><br></code></pre></td></tr></table></figure><p><i class="fas fa-exclamation-triangle"></i>在旧版本GPG及对应的教程中，会有一条短GPG key ID，但新版本似乎没有。</p><h5 id="2-上传密钥至Github"><a href="#2-上传密钥至Github" class="headerlink" title="2.上传密钥至Github"></a>2.上传密钥至Github</h5><p>将密钥文件的内容复制到Github设置页面—SSH and GPG keys—New GPG key中即可。</p><p>（新建GPG key后，也可以在SSH and GPG keys页面上看到GPG key ID，与Gpg4win程序图形界面中看到的ID是一致的）</p><h4 id="在Git中配置密钥"><a href="#在Git中配置密钥" class="headerlink" title="在Git中配置密钥"></a>在Git中配置密钥</h4><p>在Git添加密钥。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">git<span class="hljs-built_in"> config </span>--global user.signingkey <span class="hljs-string">"GPG key ID"</span><br></code></pre></td></tr></table></figure><p>在全局上使用该密钥。<br>（也可以专门在一个项目上使用该密钥）</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">git<span class="hljs-built_in"> config </span>--global commit.gpgsign <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p>（取消全局的命令如下）</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">git<span class="hljs-built_in"> config </span>--global commit.gpgsign <span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><p>执行以下命令，检查密钥配置情况。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">git<span class="hljs-built_in"> config </span>-l<br></code></pre></td></tr></table></figure><p>若包含以下信息，则说明密钥配置成功。</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">user.signingkey</span>= <span class="hljs-string">"GPG key ID"</span><br><span class="hljs-attr">commit.gpgsign</span>=<span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><h3 id="二、通过Git命令提交代码"><a href="#二、通过Git命令提交代码" class="headerlink" title="二、通过Git命令提交代码"></a>二、通过Git命令提交代码</h3><p>在本地修改完代码后，进入项目文件夹，执行以下命令，提交代码至master分支。</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>git add .<br><span class="hljs-variable">$ </span>git commit -m <span class="hljs-string">"messsage for code update"</span><br><span class="hljs-variable">$ </span>git push -u origin master<br></code></pre></td></tr></table></figure><p>在执行第3条命令后会要求输入Github账号密码，输入后即成功向Github提交代码。</p>]]></content>
    
    
    <categories>
      
      <category>工具使用</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Day11 Caffe前向传播计算</title>
    <link href="/2019/06/05/caffe-day11/"/>
    <url>/2019/06/05/caffe-day11/</url>
    
    <content type="html"><![CDATA[<p>《21天实战Caffe》学习笔记第11天</p><h3 id="代码阅读"><a href="#代码阅读" class="headerlink" title="代码阅读"></a>代码阅读</h3><p>这一章是带领读者阅读<code>/src/caffe/net.cpp</code>，即描述网络（Net）的代码。</p><p>涉及了Net的构造函数，负责初始化的<code>Init()</code>函数，负责输出Blob、输入Blob、权值Blob的函数，以及关于Forward实现的函数。</p><a id="more"></a><p>这看上去像是<a href="https://yimino.github.io/2019/06/02/caffe-day8/" target="_blank" rel="noopener">第8天 Caffe数据结构</a>的内容，但在第8天中并没有讲到<code>/src/caffe/net.cpp</code>，只讲了<code>/include/caffe/net.hpp</code>。</p><p>另外，<code>/src/caffe/net.cpp</code>的后续内容，即Backward实现函数，应该是明天的内容。</p>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Caffe</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Day10 Caffe模型</title>
    <link href="/2019/06/05/caffe-day10/"/>
    <url>/2019/06/05/caffe-day10/</url>
    
    <content type="html"><![CDATA[<p>《21天实战Caffe》学习笔记第10天</p><p>在这一天重新看了训练日志，因为在Day6运行手写数字识别代码时，由于刚接触，很多log都没有来得及看。这一天结合相应源码看了看log。</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><h4 id="逻辑回归分类器的训练"><a href="#逻辑回归分类器的训练" class="headerlink" title="逻辑回归分类器的训练"></a>逻辑回归分类器的训练</h4><p>在使用Caffe进行训练时，默认文件路径，自然是针对Caffe根目录的，要在Caffe根目录下执行以下命令。</p><p>这里的“默认文件路径”不仅指下面的命令，而且指参数文件中调用其他文件的路径。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">$ .<span class="hljs-regexp">/build/</span>tools<span class="hljs-regexp">/caffe train --solver=examples/m</span>nist<span class="hljs-regexp">/lenet_lr_solver.prototxt</span><br></code></pre></td></tr></table></figure><a id="more"></a><h3 id="练习题1：模型设计与代码实现"><a href="#练习题1：模型设计与代码实现" class="headerlink" title="练习题1：模型设计与代码实现"></a>练习题1：模型设计与代码实现</h3><p>Caffe将模型设计与代码实现分开有什么好处？</p><p>1.便于模型修改，而不必在每次修改模型时都去改动代码；</p><p>2.便于代码的复用。</p><h3 id="练习题2：权值文件与状态文件"><a href="#练习题2：权值文件与状态文件" class="headerlink" title="练习题2：权值文件与状态文件"></a>练习题2：权值文件与状态文件</h3><p>如果只有Caffe训练好的模型权值文件（.caffemodel）而没有求解器状态文件（.solverstate），能否让网络继续训练？能否对网络精调？</p><p>（以下是我胡乱猜的）</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown">应该是可以精调而不能继续训练。<br>因为迭代次数等信息记录在求解器状态文件（.solverstate）中，没有这些信息不能继续训练；<br>而网络的可学习参数记录在模型权值文件（.caffemodel），可以以此进行精调。<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Caffe</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Day9 Caffe I/O模块</title>
    <link href="/2019/06/05/caffe-day9/"/>
    <url>/2019/06/05/caffe-day9/</url>
    
    <content type="html"><![CDATA[<p>《21天实战Caffe》学习笔记第9天</p><h3 id="代码阅读：数据变换器的实现"><a href="#代码阅读：数据变换器的实现" class="headerlink" title="代码阅读：数据变换器的实现"></a>代码阅读：数据变换器的实现</h3><h4 id="实现文件-data-transformer-cpp"><a href="#实现文件-data-transformer-cpp" class="headerlink" title="实现文件 data_transformer.cpp"></a>实现文件 data_transformer.cpp</h4><p>针对Datum和Blob（Blobproto）两种方法，给出了不同输入、输出类型的变换函数，包括由Datum输入、由Blob输入、输入类型为cv::Mat对象，输出为指针、输出到Blob。</p><a id="more"></a><p>图像处理的实现包括使用OpenCV实现。</p><p><del>在图像处理代码中，很多是描述“辅助条件”的语句，而核心语句其实并不多。</del>是我看错地方了。</p><h3 id="练习题3：用Matlab实现数据变换"><a href="#练习题3：用Matlab实现数据变换" class="headerlink" title="练习题3：用Matlab实现数据变换"></a>练习题3：用Matlab实现数据变换</h3><p>这里不太会Matlab，用Python实现。</p><p>也没有太理解“数据变换”都包括什么，只做了图像分块。</p><p>于是问题转化为使用Python做图像分块。</p><p>但我连这个都不会……</p><p>借助<a href="https://zhuanlan.zhihu.com/p/39361808" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/39361808</a>的代码，使用Python实现图像分块。</p>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Caffe</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Day8 Caffe数据结构</title>
    <link href="/2019/06/02/caffe-day8/"/>
    <url>/2019/06/02/caffe-day8/</url>
    
    <content type="html"><![CDATA[<p>《21天实战Caffe》学习笔记第8天</p><h3 id="代码测试"><a href="#代码测试" class="headerlink" title="代码测试"></a>代码测试</h3><p>运行书中的测试代码，按照书中介绍的执行流程进行，遇到一些问题，如下。</p><h4 id="报错1"><a href="#报错1" class="headerlink" title="报错1"></a>报错1</h4><p>执行如下编译语句时，</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs armasm">$ g++ -o app <span class="hljs-keyword">blob_demo.cpp </span>-I ~/caffe/<span class="hljs-meta">include</span> -D CPU_ONLY -I ~/caffe/.<span class="hljs-keyword">build_release/src </span>-L ~/<span class="hljs-keyword">build/lib </span>-lcaffe<br></code></pre></td></tr></table></figure><p>报错。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">cannot <span class="hljs-builtin-name">find</span> -lcaffe<br></code></pre></td></tr></table></figure><p>解决方法是在编译前执行下列语句，将Caffe的<code>libcaffe.so</code>文件复制到系统的<code>/lib</code>文件下，否则g++编译命令中的<code>-lcaffe</code>无法执行。</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal">$ cp ~<span class="hljs-regexp">/caffe/build</span><span class="hljs-regexp">/lib/libcaffe</span>.so /usr/local/<span class="hljs-class"><span class="hljs-keyword">lib</span></span><br></code></pre></td></tr></table></figure><a id="more"></a><h4 id="报错2"><a href="#报错2" class="headerlink" title="报错2"></a>报错2</h4><p>在使用<code>mutable_cpu_data()</code>后，编译时需要调用glog，即在编译命令中加入<code>-lglog</code>。</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs armasm">$ g++ -o app <span class="hljs-keyword">blob_demo.cpp </span>-I ~/caffe/<span class="hljs-meta">include</span> -D CPU_ONLY -I ~/caffe/.<span class="hljs-keyword">build_release/src </span>-L ~/<span class="hljs-keyword">build/lib </span>-lcaffe -lglog<br></code></pre></td></tr></table></figure><p>否则会报错。</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livescript"><span class="hljs-literal">undefined</span> reference <span class="hljs-keyword">to</span> symbol <span class="hljs-string">'_ZN6google4base21CheckOpMessageBuilder7ForVar2Ev'</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Caffe</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Day7 Caffe代码梳理</title>
    <link href="/2019/06/01/caffe-day7/"/>
    <url>/2019/06/01/caffe-day7/</url>
    
    <content type="html"><![CDATA[<script type="text/javascript"   src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><p>《21天实战Caffe》学习笔记第7天</p><h3 id="练习题1：Caffe源码中一些宏的原始定义"><a href="#练习题1：Caffe源码中一些宏的原始定义" class="headerlink" title="练习题1：Caffe源码中一些宏的原始定义"></a>练习题1：Caffe源码中一些宏的原始定义</h3><h4 id="NOT-IMPLEMENTED"><a href="#NOT-IMPLEMENTED" class="headerlink" title="NOT_IMPLEMENTED"></a>NOT_IMPLEMENTED</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> NOT_IMPLEMENTED LOG(FATAL) &lt;&lt; <span class="hljs-meta-string">"Not Implemented Yet"</span></span><br></code></pre></td></tr></table></figure><h4 id="INSTANTIATE-CLASS"><a href="#INSTANTIATE-CLASS" class="headerlink" title="INSTANTIATE_CLASS"></a>INSTANTIATE_CLASS</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> INSTANTIATE_CLASS(classname) \</span><br>  <span class="hljs-keyword">char</span> gInstantiationGuard#<span class="hljs-meta">#classname; \</span><br>  <span class="hljs-keyword">template</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">classname</span>&lt;float&gt;;</span> \<br>  <span class="hljs-keyword">template</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">classname</span>&lt;double&gt;</span><br></code></pre></td></tr></table></figure><a id="more"></a><h3 id="练习题3：推导BNLL-layer的误差反向传播公式"><a href="#练习题3：推导BNLL-layer的误差反向传播公式" class="headerlink" title="练习题3：推导BNLL layer的误差反向传播公式"></a>练习题3：推导BNLL layer的误差反向传播公式</h3><p>BNLL layer的激活函数为</p><p>$$\varphi\left(x\right)=x+\ln\left(1+e^{-x}\right),x&gt;0$$</p><p>$$\varphi\left(x\right)=\ln\left(1+e^x\right),x\leqslant0$$</p><h4 id="对激活函数求导"><a href="#对激活函数求导" class="headerlink" title="对激活函数求导"></a>对激活函数求导</h4><p>事实上，激活函数可以写成统一的形式</p><p>$$\varphi\left(x\right)=\ln\left(1+e^x\right)$$</p><p>求导</p><p>$$\varphi’\left(x\right)=\displaystyle\frac{e^x}{1+e^x}$$</p><h4 id="计算反向误差公式"><a href="#计算反向误差公式" class="headerlink" title="计算反向误差公式"></a>计算反向误差公式</h4><p>反向误差=后一层的反向误差*激活函数导数，即</p><p>$$\delta^{\left(l\right)}=\displaystyle\delta^{\left(l+1\right)}\frac{e^x}{1+e^x}$$</p>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Caffe</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Day6 手写数字识别</title>
    <link href="/2019/06/01/caffe-day6/"/>
    <url>/2019/06/01/caffe-day6/</url>
    
    <content type="html"><![CDATA[<p>《21天实战Caffe》学习笔记第6天</p><h3 id="练习题3：完成Caffe-Cifar10示例"><a href="#练习题3：完成Caffe-Cifar10示例" class="headerlink" title="练习题3：完成Caffe Cifar10示例"></a>练习题3：完成Caffe Cifar10示例</h3><h4 id="下载数据集"><a href="#下载数据集" class="headerlink" title="下载数据集"></a>下载数据集</h4><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">$ <span class="hljs-keyword">cd</span> ~<span class="hljs-string">/caffe/data/cifar10</span><br>$ <span class="hljs-string">./get_cifar10.sh</span><br></code></pre></td></tr></table></figure><h4 id="数据的格式转换"><a href="#数据的格式转换" class="headerlink" title="数据的格式转换"></a>数据的格式转换</h4><p>将下载的数据集转换为caffe支持的lmdb格式。</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">$ <span class="hljs-keyword">cd</span> ~<span class="hljs-string">/caffe/examples/cifar10</span><br>$ <span class="hljs-string">./create_cifar10.sh</span><br></code></pre></td></tr></table></figure><h4 id="修改训练参数"><a href="#修改训练参数" class="headerlink" title="修改训练参数"></a>修改训练参数</h4><p>由于在虚拟机下运行，无法使用GPU进行训练，故需将训练参数中的训练模式设置为CPU模式。</p><p>在<code>~/caffe/examples/cifar10</code>文件件下，打开<code>cifar10_full_solver.prototxt</code>，将最后的<code>solve mode</code>改为CPU模式。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># solver mode: CPU or GPU</span><br>solver_mode: CPU<br></code></pre></td></tr></table></figure><a id="more"></a><h4 id="进行训练"><a href="#进行训练" class="headerlink" title="进行训练"></a>进行训练</h4><p>Cifar10示例提供了多种训练脚本，这里使用<code>train_full.sh</code>进行训练，上一步中修改的参数文件同样是该训练脚本所对应的参数文件。</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>./train_full.sh<br></code></pre></td></tr></table></figure><h4 id="训练过程"><a href="#训练过程" class="headerlink" title="训练过程"></a>训练过程</h4><p>在虚拟机中用CPU训练了6h 10min，仍未完成，放弃。</p><p>虚拟机的CPU分配为2*8，但在训练中只有两个核心在工作：主力核心，一个线程占用20-40%，另一个线程占用约80%；另一个核心，两个线程占用均在20%上下波动。</p><p>所以，是我在CPU分配上的理解不对，还是“在原有虚拟机文件上新建虚拟机”导致只能沿用原有虚拟机的CPU分配方式（原有虚拟机的CPU分配是2*2）？根据上述CPU占用情况，似乎是后者。</p><h4 id="结果分析"><a href="#结果分析" class="headerlink" title="结果分析"></a>结果分析</h4><p>（TODO）</p><h4 id="收尾工作"><a href="#收尾工作" class="headerlink" title="收尾工作"></a>收尾工作</h4><p>完成训练和分析，删除数据文件，以节省硬盘空间。</p>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Caffe</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
