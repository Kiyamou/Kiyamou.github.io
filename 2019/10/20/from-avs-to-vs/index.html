<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 从Avisynth到VapourSynth：一些方法的迁移 · 308实验室</title><meta name="description" content="从Avisynth到VapourSynth：一些方法的迁移 - Kiyamou"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://yoursite.com/atom.xml" title="308实验室"><meta name="generator" content="Hexo 4.2.1"><link rel="alternate" href="/atom.xml" title="308实验室" type="application/atom+xml">
</head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/circle.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/Kiyamou" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/about" target="_self" class="nav-list-link">ABOUT</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">从Avisynth到VapourSynth：一些方法的迁移</h1><div class="post-info">Oct 20, 2019</div><div class="post-content"><p>VapourSynth经过四十多个版本的更新，滤镜已经丰富。但Avisynth时代留下了诸多的教程，似乎仍是VapourSynth无法比拟的。</p>
<p>因此，我试着将前辈们一些用avs写的教程迁移到vs上，希望能够给大家做一点微小的贡献。</p>
<p>有什么错误的地方还请大家指正~</p>
<p>默认import如下内容。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> vapoursynth <span class="keyword">as</span> vs</span><br><span class="line">core = vs.get_core()</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> mvsfunc <span class="keyword">as</span> mvf</span><br><span class="line"><span class="keyword">import</span> havsfunc <span class="keyword">as</span> haf</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h3 id="NR-de-banding思路"><a href="#NR-de-banding思路" class="headerlink" title="NR de-banding思路"></a>NR de-banding思路</h3><blockquote>
<p>avs脚本出处：<a href="https://www.nmm-hd.org/newbbs/viewtopic.php?f=7&amp;t=1495#p12163" target="_blank" rel="noopener">https://www.nmm-hd.org/newbbs/viewtopic.php?f=7&amp;t=1495#p12163</a> 作者：mawen1250</p>
</blockquote>
<p>NR de-banding（去色带）思路，可以降低去色带的力度、提升效果。基本的思路是先扫去噪点层，再做去色带，做完后再把噪点层加回来。</p>
<p>其中NR指noise reduction，降噪的意思，很多处理都可以使用降噪做预处理，以提升效果。</p>
<h4 id="avs脚本"><a href="#avs脚本" class="headerlink" title="avs脚本"></a>avs脚本</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># stacked-16bit input</span></span><br><span class="line">last = last <span class="comment"># this line can be ignored, just in case someone who doesn't understand it</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># pre-filter</span></span><br><span class="line">nr16 = last.Dither_removegrain16(<span class="number">11</span>, <span class="number">11</span>).Dither_removegrain16(<span class="number">20</span>, <span class="number">0</span>)</span><br><span class="line"><span class="comment"># get noise diff clip</span></span><br><span class="line">noise = last.Dither_sub16(nr16, y=<span class="number">3</span>, u=<span class="number">3</span>, v=<span class="number">3</span>, dif=<span class="literal">True</span>)</span><br><span class="line"><span class="comment"># refine pre-filtered clip due to limited range of diff clip: [-32768, 32767], avoiding potential issue that the noise can not be fully added back</span></span><br><span class="line">nr16 = last.Dither_sub16(noise, y=<span class="number">3</span>, u=<span class="number">3</span>, v=<span class="number">3</span>, dif=<span class="literal">True</span>)</span><br><span class="line"><span class="comment"># de-banding on pre-filtered clip</span></span><br><span class="line">last = nr16</span><br><span class="line">last = last.f3kdb(<span class="number">16</span>, <span class="number">40</span>, <span class="number">40</span>, <span class="number">40</span>, <span class="number">0</span>, <span class="number">0</span>, input_mode=<span class="number">1</span>, output_mode=<span class="number">1</span>).Dither_limit_dif16(last, ref=nr16, thr=<span class="number">0.30</span>, elast=<span class="number">2.5</span>, y=<span class="number">3</span>, u=<span class="number">3</span>, v=<span class="number">3</span>)</span><br><span class="line"><span class="comment"># add back noise</span></span><br><span class="line">last = last.Dither_add16(noise, y=<span class="number">3</span>, u=<span class="number">3</span>, v=<span class="number">3</span>, dif=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># stacked-16bit output</span></span><br><span class="line">last</span><br></pre></td></tr></table></figure>

<h4 id="vs脚本"><a href="#vs脚本" class="headerlink" title="vs脚本"></a>vs脚本</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 16bit input: src16</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># pre-filter</span></span><br><span class="line">nr16   = core.rgvs.RemoveGrain(src16, [<span class="number">11</span>,<span class="number">11</span>]).rgvs.RemoveGrain([<span class="number">20</span>,<span class="number">0</span>])</span><br><span class="line"><span class="comment"># get noise diff clip</span></span><br><span class="line">noise  = core.std.MakeDiff(src16, nr16, planes=[<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>]) <span class="comment"># By default all planes are processed. So the parameter for planes can be ignored.</span></span><br><span class="line">nr16   = core.std.MakeDiff(src16, noise, planes=[<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>])</span><br><span class="line"><span class="comment"># de-banding on pre-filtered clip</span></span><br><span class="line">deband = core.f3kdb.Deband(nr16, <span class="number">16</span>,<span class="number">40</span>,<span class="number">40</span>,<span class="number">40</span>,<span class="number">0</span>,<span class="number">0</span>, output_depth=<span class="number">16</span>)</span><br><span class="line">deband = mvf.LimitFilter(deband, nr16, thr=<span class="number">0.30</span>, elast=<span class="number">2.5</span>, planes=[<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>])</span><br><span class="line"><span class="comment"># add back noise</span></span><br><span class="line">deband = core.std.MergeDiff(deband, noise, planes=[<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>])</span><br></pre></td></tr></table></figure>

<p>在此基础上更复杂一点的用法。做完de-banding后，不把噪点全部加回来，而是对噪点层降噪。这就是SBR降噪的思路。</p>
<p>当然，如果是用KNLMeansCL这类降噪滤镜扫噪点层，在参数不太高的情况下，本身对画面的破坏就已经很小。如果想做降噪，可以不把噪点层加回来。</p>
<h3 id="Chroma-Shift的处理"><a href="#Chroma-Shift的处理" class="headerlink" title="Chroma Shift的处理"></a>Chroma Shift的处理</h3><blockquote>
<p>avs脚本出处：<a href="https://www.nmm-hd.org/newbbs/viewtopic.php?f=7&amp;t=1483&amp;p=12144#p12144" target="_blank" rel="noopener">https://www.nmm-hd.org/newbbs/viewtopic.php?f=7&amp;t=1483&amp;p=12144#p12144</a> 作者：mawen1250</p>
</blockquote>
<p>Chroma Shift（色度偏移）的处理。关于色度偏移，可以看一下mawen1250前辈的<a href="https://www.nmm-hd.org/newbbs/viewtopic.php?f=5&t=1208" target="_blank" rel="noopener">这个帖子</a>和EleonoreMizo前辈为fmtconv写的<a href="https://github.com/EleonoreMizo/fmtconv/blob/master/doc/fmtconv.html" target="_blank" rel="noopener">Doc</a>中<code>resample</code>函数的部分。</p>
<h4 id="avs脚本-1"><a href="#avs脚本-1" class="headerlink" title="avs脚本"></a>avs脚本</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Parameters for chroma shift, example for converting MPEG-1 chroma placement to MPEG-2 chroma placement</span></span><br><span class="line">U_Horizontal_Shift = <span class="number">-0.25</span></span><br><span class="line">U_Vertical_Shift = <span class="number">0</span></span><br><span class="line">V_Horizontal_Shift = <span class="number">-0.25</span></span><br><span class="line">V_Vertical_Shift = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 8bit YUV input</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Separate planes</span></span><br><span class="line">Y = last</span><br><span class="line">U = UToY8()</span><br><span class="line">V = VToY8()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Use resizer to achieve sub-pixel precision shift for each plane</span></span><br><span class="line">U = U.Spline16Resize(U.Width(), U.Height(), U_Horizontal_Shift, U_Vertical_Shift)</span><br><span class="line">V = V.Spline16Resize(V.Width(), V.Height(), V_Horizontal_Shift, V_Vertical_Shift)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Merge planes back to YUV format</span></span><br><span class="line">YToUV(U, V, Y)</span><br></pre></td></tr></table></figure>

<h4 id="vs脚本-1"><a href="#vs脚本-1" class="headerlink" title="vs脚本"></a>vs脚本</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Parameters for chroma shift, example for converting MPEG-1 chroma placement to MPEG-2 chroma placement</span></span><br><span class="line">U_Horizontal_Shift = <span class="number">-0.25</span></span><br><span class="line">U_Vertical_Shift   = <span class="number">0</span></span><br><span class="line">V_Horizontal_Shift = <span class="number">-0.25</span></span><br><span class="line">V_Vertical_Shift   = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># YUV input: src</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Use resizer to achieve sub-pixel precision shift for each plane</span></span><br><span class="line">result = core.fmtc.resample(src, src.width, src.height, sx=[<span class="number">0</span>, U_Horizontal_Shift, V_Horizontal_Shift], sy=[<span class="number">0</span>, U_Vertical_Shift, V_Vertical_Shift], planes=[<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>])</span><br></pre></td></tr></table></figure>

<h3 id="Chroma-Bleeding的处理"><a href="#Chroma-Bleeding的处理" class="headerlink" title="Chroma Bleeding的处理"></a>Chroma Bleeding的处理</h3><blockquote>
<p>avs脚本出处：<a href="https://www.nmm-hd.org/newbbs/viewtopic.php?f=7&amp;t=1587&amp;p=12668#p12651" target="_blank" rel="noopener">https://www.nmm-hd.org/newbbs/viewtopic.php?f=7&amp;t=1587&amp;p=12668#p12651</a> 作者：mawen1250</p>
</blockquote>
<p>Chroma Bleeding（色度溢出）的处理。详情可以点开上面的链接看一下原帖，mawen1250前辈做了说明。主要是用了AWarpSharp2系列的滤镜，以亮度平面为mask，将色度平面中溢出的部分砍掉。这也很好理解，多出来的就砍掉嘛~</p>
<p>顺带一提，收线也可用这个滤镜。道理类似，“收”就是砍的嘛~</p>
<h4 id="avs脚本-2"><a href="#avs脚本-2" class="headerlink" title="avs脚本"></a>avs脚本</h4><p>脚本是8bit YUV420输入，先升至16bit YUV444，再降至8bit YUV444处理色度溢出，继而升至16bit YUV444与未修正色度溢出的16bit YUV444源比较，最后保持16bit YUV444输出。</p>
<p>（mawen1250前辈的教程写于2015年2月，avs版AWarpSharp2在2018年3月更新的v2.0.0版中添加了16bit支持，上述反复升降位深的做法已不必要）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># YUV420P8 input</span></span><br><span class="line">nnedi3_resize16(lsb_in=<span class="literal">False</span>, lsb=<span class="literal">True</span>, output=<span class="string">"YV24"</span>, ratiothr=<span class="number">2.25</span>, kernel_u=<span class="string">"Bicubic"</span>, a1=<span class="number">0.6</span>, a2=<span class="number">0.4</span>)</span><br><span class="line"></span><br><span class="line">src16 = last</span><br><span class="line">DitherPost(mode=<span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line">warpe = ConvertToYV12().aSobel(<span class="number">128</span>, <span class="number">1</span>).aBlur(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">epp = YToUV(UToY().awarp(warpe, <span class="number">6</span>, <span class="number">1</span>), VToY().awarp(warpe, <span class="number">6</span>, <span class="number">1</span>), last)</span><br><span class="line"></span><br><span class="line">Dither_limit_dif16(src16, epp.U16(), thr=<span class="number">1.0</span>, elast=<span class="number">2</span>, y=<span class="number">2</span>, u=<span class="number">3</span>, v=<span class="number">3</span>)</span><br><span class="line"><span class="comment"># YUV444P16 output</span></span><br></pre></td></tr></table></figure>

<h4 id="vs脚本-2"><a href="#vs脚本-2" class="headerlink" title="vs脚本"></a>vs脚本</h4><p>这里使用了dubhater前辈的<a href="https://github.com/dubhater/vapoursynth-awarpsharp2" target="_blank" rel="noopener">AWarpSharp2</a>移植，由于支持高位深，所以全程在16bit下处理。</p>
<p>在脚本的最后用<code>mvf.LimitFilter</code>做了限制，这是照抄mawen1250前辈的avs脚本。但avs脚本做限制是为了保留未处理部分的16bit精度（如前面所说，在avs版AWarpSharp2支持16bit前，不得不反复升降位深，这会带来精度的损失），在全程16bit处理的情况下，这个限制是否有必要，值得思考。<del>唔..我太笨了，就是这样</del></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># YUV420P8 input: src</span></span><br><span class="line">src16 = mvf.Depth(src, <span class="number">16</span>)</span><br><span class="line">src16 = core.fmtc.resample(src16, src.width, src.height, kernel=<span class="string">'bicubic'</span>, a1=<span class="number">0.6</span>, a2=<span class="number">0.4</span>, css=<span class="string">'444'</span>) <span class="comment"># Y plane isn't processed</span></span><br><span class="line"></span><br><span class="line">warpe = mvf.GetPlane(core.warp.ASobel(src16, <span class="number">128</span>, <span class="number">1</span>).warp.ABlur(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>), plane=<span class="number">0</span>)</span><br><span class="line">fixU  = core.warp.AWarp(mvf.GetPlane(src16, plane=<span class="number">1</span>), warpe, depth=<span class="number">6</span>, chroma=<span class="number">0</span>)</span><br><span class="line">fixV  = core.warp.AWarp(mvf.GetPlane(src16, plane=<span class="number">2</span>), warpe, depth=<span class="number">6</span>, chroma=<span class="number">0</span>)</span><br><span class="line">epp   = core.std.ShufflePlanes([src16, fixU, fixV], planes=[<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>], colorfamily=vs.YUV)</span><br><span class="line"></span><br><span class="line">result = mvf.LimitFilter(src16, epp, thr=<span class="number">1.0</span>, elast=<span class="number">2.0</span>, planes=[<span class="number">1</span>,<span class="number">2</span>])</span><br><span class="line"><span class="comment"># YUV444P16 output</span></span><br></pre></td></tr></table></figure>

<p>如果不想保持16bit YUV444输出，而是输出一般的16bit YUV420，则在进行上述处理后，再用<code>fmtc.resample</code>缩放即可。降低分辨率通常推荐用Spline（样条采样）系列中的<code>spline36</code>，<code>fmtc.resample</code>的默认参数就是它。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">result = core.fmtc.resample(result, src.width, src.height, kernel=<span class="string">'spline36'</span>, css=<span class="string">'420'</span>)</span><br></pre></td></tr></table></figure>

<p>当然，如果是以16bit YUV420输出，将<code>mvf.LimitFilter</code>的限制放到缩放后，将未拉伸色度平面的输入源与降回16bit YUV420的处理结果比较，可能会更好。因为这样多少限制了色度平面拉伸与缩小过程的损失。（我口胡的，不要打我呀~</p>
<h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>本来想打两个波浪线买一下萌，忘了markdown语法，结果变成了下面那个样子，太真实了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">（未完待续~~我才不会鸽的~）</span><br></pre></td></tr></table></figure>

<p>（未完待续<del>我才不会鸽的</del>）</p>
</div></article></div></main><footer><div class="paginator"><a href="/2019/10/20/mxnet-install-win/" class="prev">PREV</a><a href="/2019/10/17/hello-world/" class="next">NEXT</a></div><div class="copyright"><p>© 2019 - 2020 <a href="http://yoursite.com">Kiyamou</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>