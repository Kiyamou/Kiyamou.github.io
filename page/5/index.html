<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 308实验室</title><meta name="description" content="A Blog Powered By Hexo"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://yoursite.com/atom.xml" title="308实验室"><meta name="generator" content="Hexo 4.2.1"><link rel="alternate" href="/atom.xml" title="308实验室" type="application/atom+xml">
</head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/circle.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/Kiyamou" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/about" target="_self" class="nav-list-link">ABOUT</a></li></ul></header><main class="container"><ul class="home post-list"><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2019/12/27/Phase-trans-to-vs/" class="post-title-link">从VC++ 6.0到VS——记一个简单窗口程序的迁移</a></h2><div class="post-info">Dec 27, 2019</div><div class="post-content"><p>重新拾起大二时写过，或者说照着教材修改过的一份计算并绘制相图的代码。</p>
<p>讲道理，从功能上看，用C/C++来写似乎不是一个好的选择，没什么计算量，用Python应该会更简单一些（我仿佛又看到了一个坑…）。</p>
<p>印象中教程上的原始代码是用一门上古的C语言（变体？）写的，名字已经记不太清。当时是在机房装了那个语言的IDE，看着蓝屏一般的背景色和又大又复古的字体，幼小的我被吓坏了…</p>
<p>限于教学条件，那个时候自然是基于VC++ 6.0把代码重新改了一遍，然后就交作业了。分数还不错。</p>
<p>OK，回忆就到这里。昨天心血来潮，想在Visual Studio下重新跑一遍。于是…我就掉进了坑里…</p>
<h3 id="代码功能与现状"><a href="#代码功能与现状" class="headerlink" title="代码功能与现状"></a>代码功能与现状</h3><p>代码实现的功能其实简陋，执行一下，跳出来一个NiO-MgO固溶体相图的窗口，就完了。所以虽然是窗口程序，用户完全没法做什么。</p>
<p>代码方面，除了在现在看来中了毒一般的代码风格和陈旧的头文件，还隐藏着C++标准改变埋下的坑。</p></div><a href="/2019/12/27/Phase-trans-to-vs/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2019/12/22/week-201912-3/" class="post-title-link">周记 2019.12.16-12.22</a></h2><div class="post-info">Dec 22, 2019</div><div class="post-content"><h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>不写点东西督促，日子真的会从指尖溜走。但写日记…一方面真的是不一定保证能每天都写，另一方面，毕竟学业上还有其他的事情，有时候一天学到的东西也没多少可写。</p>
<p>总之，把日记改成周记吧。</p>
<p><del>还是别用“周报”这个字眼了2333</del></p>
<h3 id="对JincResize的完善"><a href="#对JincResize的完善" class="headerlink" title="对JincResize的完善"></a>对JincResize的完善</h3><h4 id="发布r4：添加32bit支持"><a href="#发布r4：添加32bit支持" class="headerlink" title="发布r4：添加32bit支持"></a>发布r4：添加32bit支持</h4><p>详情写在<a href="https://kiyamou.github.io/2019/11/24/rebuild-JincResize/" target="_blank" rel="noopener">JincResize代码的重构</a>，这里就不再copy了。</p>
<p>要是再补充一句的话，就是多个分支的if语句的写法，之前用Python时只写过<code>if else</code>和<code>if elif</code>，没有把三者写在一起过…没错…我的基础知识实在是匮乏得可怜。</p></div><a href="/2019/12/22/week-201912-3/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2019/12/18/image-process-code-1/" class="post-title-link">图像处理中一些稍底层的东西：色彩空间与数据结构</a></h2><div class="post-info">Dec 18, 2019</div><div class="post-content"><h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>接触图像处理也有两年了，如果算上大二时H老师的课，甚至有三年多了。我真的很想“上岸”，而不是流于表面，只学到花拳绣腿。</p>
<p>色彩空间是最基础的概念，当然谈不上“底层”。但和色彩空间相关联的、图像的像素点是以和何种方式储存的，换句话说，数字图像的数据结构是怎样的，应当称得上是从表面到深入的一个转折点了。学数字图像处理，当然不能满足于<code>output = intput.filter()</code>这样的模式。</p>
<p><em>引言写于2020.1.3</em></p>
<h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p><em>修改于2020.1.2</em></p>
<h4 id="二维图像与一维数组"><a href="#二维图像与一维数组" class="headerlink" title="二维图像与一维数组"></a>二维图像与一维数组</h4><p>在AviSynth和VapourSynth中，单帧图像的像素按行储存，从图像的左上开始，一行一行地存储于一维数组中，像下面这样。</p>
<p>——————————&gt;<br>——————————&gt;<br>……<br>——————————&gt;</p>
<p>所以读取/写入下一个像素，依据行列的不同，分两种情况，大概是这样</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对于YUV格式图像</span></span><br><span class="line"><span class="keyword">const</span> T* srcp = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> T*&gt;(vsapi-&gt;getReadPtr(src, plane)); <span class="comment">// 创建指针</span></span><br><span class="line"><span class="keyword">int</span> src_stride = vsapi-&gt;getStride(src, plane) / <span class="keyword">sizeof</span>(T);                 <span class="comment">// 获取stride</span></span><br><span class="line">srcp++;              <span class="comment">// 读取同行下一个像素</span></span><br><span class="line">srcp += src_stride;  <span class="comment">// 读取同列下一个元素</span></span><br></pre></td></tr></table></figure></div><a href="/2019/12/18/image-process-code-1/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2019/12/14/day-191214/" class="post-title-link">日记 2019.12.14</a></h2><div class="post-info">Dec 14, 2019</div><div class="post-content"></div><a href="/2019/12/14/day-191214/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2019/12/14/day-191213/" class="post-title-link">日记 2019.12.13</a></h2><div class="post-info">Dec 14, 2019</div><div class="post-content"><h3 id="1-飞浆开始"><a href="#1-飞浆开始" class="headerlink" title="1 飞浆开始"></a>1 飞浆开始</h3><p>看了一下paddlepaddle Fluid的教材，买书时没细看，发现是百度大佬自己写的。</p>
<p>感觉和Caffe好像，无论是block、program等逻辑/数据结构，还是具体的<code>.proto</code>储存格式。</p>
<p>LoD Tensor的概念倒是很新鲜，之前看Caffe和Pytorch，不知是我没细看还是怎么，感觉都没有类似的概念。</p>
<p>而Python前端+C++后端这种模式，也让人觉得很亲切。我甚至有点写这种Python“前端”了。</p>
<h3 id="2-Next"><a href="#2-Next" class="headerlink" title="2 Next"></a>2 Next</h3><p>既然是将算法复现，那我趁热把熟悉的手写数字识别和之前大作业的文章内容理解拿过来用一下。</p></div><a href="/2019/12/14/day-191213/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2019/12/12/day-191212/" class="post-title-link">日记 2019.12.12</a></h2><div class="post-info">Dec 12, 2019</div><div class="post-content"><h4 id="1"><a href="#1" class="headerlink" title="1"></a>1</h4><p>用<code>malloc</code>分配内存</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span>* lut = (<span class="keyword">double</span>*) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">double</span>)*d.samples);</span><br></pre></td></tr></table></figure>

<p><code>sizeof(double)</code>=8</p>
<h4 id="2"><a href="#2" class="headerlink" title="2"></a>2</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(d));</span><br></pre></td></tr></table></figure>

<p>而我修改后，直接省去了<code>data</code>这个变量，因为看不到有什么用。（或许是，我修改后的代码，因为使用了智能指针，所以不需要<code>data</code>做某种辅助？）</p>
<p><strong>PS</strong>：在HomeOfVapourSynthEvolution的Curve.cpp，能看到这种“成对”的模式，用<code>malloc</code>和<code>calloc</code>来分配内存的变量都用<code>free</code>做了释放。相比之下，我自己该的代码，在新定义<code>lut</code>这个变量时，用了<code>malloc</code>，却没有用<code>free</code>，而是用<code>delete</code>去删除的。</p>
<p><code>delete</code>不仅释放内存，而且会调用析构函数，而<code>free</code>不会调用析构函数。</p></div><a href="/2019/12/12/day-191212/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2019/12/11/day-191211/" class="post-title-link">日记 2019.12.11</a></h2><div class="post-info">Dec 11, 2019</div><div class="post-content"><p>如果不靠一个类似写日记的方法督促我学习，恐怕这学生阶段最后的时光也要溜走了…</p>
<h3 id="First"><a href="#First" class="headerlink" title="First"></a>First</h3><p>《深入理解C指针》收到了，粗看了一下，收获确实很多，只是我看书的效率有点低啊…不过幸好有之前改代码的经验，配合着看，这样想似乎效率还可以。</p>
<h3 id="Second"><a href="#Second" class="headerlink" title="Second"></a>Second</h3><p>emmm好像没有了，实验要明天才能进行下一步，至于刚看到的竞赛…emmm我早就不是十五岁的少年了，但看到这个竞赛，还是本能地激动。嘛~这样也好，整体死气沉沉地也不行。</p>
<p>不过，必须冷静地看到，竞赛…应当算是一个调剂吧。我知道自己处在什么水平，不要自负也不要自卑，更不要陷入自负与自备的交织中。</p>
<p>中午装好了框架，算是一个开头吧。</p></div><a href="/2019/12/11/day-191211/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2019/11/25/gcc-use-1/" class="post-title-link">Windows下使用gcc/g++编译器</a></h2><div class="post-info">Nov 25, 2019</div><div class="post-content"><h3 id="MSVC：从入门到放弃"><a href="#MSVC：从入门到放弃" class="headerlink" title="MSVC：从入门到放弃"></a>MSVC：从入门到放弃</h3><p>从一开始修改JincResize代码到现在，代码编译后dll运行缓慢的问题一直困扰着我。虽然原作者说运行速度慢，但我自己编译的也太慢了（1.5s vs 9s）。改了一些代码（主要是涉及C语言和C++的区别），但对速度无肉眼可见的影响。这样下去，代码重构也没有动力。</p>
<p>思考了一下，做了一下对照实验。使用原作者代码，直接在VS2019中编译（除了为在VS2019中编译通过，修改了一处代码外，其余代码均未改动），也很慢，也是约9s/帧。这样让我明确了一点，就是编译方面的问题，导致运行速度缓慢的。</p>
<p>我又仿照HomeOfVapourSynthEvolution的预处理设置，并在编译中尽量使用加快代码速度的优化参数，但最终的编译结果仍没有什么改善。</p>
<p>所以我有理由判断，是编译器的锅。（也许是现在的代码，虽然做了从C到C++的迁移，但仍有C的风格，导致和VS的纯C++编译器八字不合？）</p>
<p>不管怎么说，改用gcc/g++。</p></div><a href="/2019/11/25/gcc-use-1/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2019/11/24/rebuild-JincResize/" class="post-title-link">JincResize 代码重构（1）</a></h2><div class="post-info">Nov 24, 2019</div><div class="post-content"><p>前一篇Blog记录了将原作者代码（初步）从C语言迁移到C++上的过程，以及添加8bit输入支持的方法。下一步我想模仿HomeOfVapourSynthEvolution的代码风格，对上述代码进行重构。同时，也期待能发现，我先前修改的代码运行缓慢的原因。</p>
<p>Blog写得详细一些，这也是我学习C++基础知识的过程。</p>
<h3 id="未完成的C语言到C-迁移"><a href="#未完成的C语言到C-迁移" class="headerlink" title="未完成的C语言到C++迁移"></a>未完成的C语言到C++迁移</h3><p>其实C语言和C++的区别还有很多。</p>
<h4 id="C-的类型转换"><a href="#C-的类型转换" class="headerlink" title="C++的类型转换"></a>C++的类型转换</h4><p>编写VapourSynth插件，在四个<code>VS__CC</code>函数的开头，都需要进行类型转换，原始代码使用C语言风格的类型转换，类似下面这样。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FilterData* d = (FilterData*)* instanceData;</span><br></pre></td></tr></table></figure>

<p>如果让代码“更C++”一些，则使用类型转换运算符（Type Conversion Operator）。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FilterData* d = <span class="keyword">static_cast</span>&lt;FilterData*&gt;(*instanceData);</span><br></pre></td></tr></table></figure></div><a href="/2019/11/24/rebuild-JincResize/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2019/11/22/learn-cpp-note-1/" class="post-title-link">C++笔记：某培训课程与21天学通C++</a></h2><div class="post-info">Nov 22, 2019</div><div class="post-content"><h3 id="写在开头的话"><a href="#写在开头的话" class="headerlink" title="写在开头的话"></a>写在开头的话</h3><p>有人讲解，学习效率还是会高一些的吧。</p>
<p>愿我能坚持。更愿我能在写完这个笔记后，继续写学习笔记之二。毕竟，培训班的课程只能算一个开始。</p>
<p>后来在忙其他事情的时候，学到了更多的东西，于是把21天学通C++及网络上资料（主要是菜鸟教程）的学习笔记也记到这上面来。虽然和周记系列有点冲突，但同时进行吧，做下去就能变得清晰。</p></div><a href="/2019/11/22/learn-cpp-note-1/" class="read-more">...more</a></article></li></ul></main><footer><div class="paginator"><a href="/page/4/" class="prev">PREV</a><a href="/page/6/" class="next">NEXT</a></div><div class="copyright"><p>© 2019 - 2021 <a href="http://yoursite.com">Kiyamou</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>