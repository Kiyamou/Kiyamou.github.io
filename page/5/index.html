<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 308实验室</title><meta name="description" content="A Blog Powered By Hexo"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://yoursite.com/atom.xml" title="308实验室"><meta name="generator" content="Hexo 4.2.1"><link rel="alternate" href="/atom.xml" title="308实验室" type="application/atom+xml">
</head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/circle.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/Kiyamou" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/about" target="_self" class="nav-list-link">ABOUT</a></li></ul></header><main class="container"><ul class="home post-list"><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2019/12/18/image-process-code-1/" class="post-title-link">图像处理中一些稍底层的东西：色彩空间与数据结构</a></h2><div class="post-info">Dec 18, 2019</div><div class="post-content"><h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>接触图像处理也有两年了，如果算上大二时H老师的课，甚至有三年多了。我真的很想“上岸”，而不是流于表面，只学到花拳绣腿。</p>
<p>色彩空间是最基础的概念，当然谈不上“底层”。但和色彩空间相关联的、图像的像素点是以和何种方式储存的，换句话说，数字图像的数据结构是怎样的，应当称得上是从表面到深入的一个转折点了。学数字图像处理，当然不能满足于<code>output = intput.filter()</code>这样的模式。</p>
<p><em>引言写于2020.1.3</em></p>
<h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p><em>修改于2020.1.2</em></p>
<h4 id="二维图像与一维数组"><a href="#二维图像与一维数组" class="headerlink" title="二维图像与一维数组"></a>二维图像与一维数组</h4><p>在AviSynth和VapourSynth中，单帧图像的像素按行储存，从图像的左上开始，一行一行地存储于一维数组中，像下面这样。</p>
<p>——————————&gt;<br>——————————&gt;<br>……<br>——————————&gt;</p>
<p>所以读取/写入下一个像素，依据行列的不同，分两种情况，大概是这样</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对于YUV格式图像</span></span><br><span class="line"><span class="keyword">const</span> T* srcp = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> T*&gt;(vsapi-&gt;getReadPtr(src, plane)); <span class="comment">// 创建指针</span></span><br><span class="line"><span class="keyword">int</span> src_stride = vsapi-&gt;getStride(src, plane) / <span class="keyword">sizeof</span>(T);                 <span class="comment">// 获取stride</span></span><br><span class="line">srcp++;              <span class="comment">// 读取同行下一个像素</span></span><br><span class="line">srcp += src_stride;  <span class="comment">// 读取同列下一个元素</span></span><br></pre></td></tr></table></figure></div><a href="/2019/12/18/image-process-code-1/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2019/12/14/day-191214/" class="post-title-link">日记 2019.12.14</a></h2><div class="post-info">Dec 14, 2019</div><div class="post-content"></div><a href="/2019/12/14/day-191214/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2019/12/14/day-191213/" class="post-title-link">日记 2019.12.13</a></h2><div class="post-info">Dec 14, 2019</div><div class="post-content"><h3 id="1-飞浆开始"><a href="#1-飞浆开始" class="headerlink" title="1 飞浆开始"></a>1 飞浆开始</h3><p>看了一下paddlepaddle Fluid的教材，买书时没细看，发现是百度大佬自己写的。</p>
<p>感觉和Caffe好像，无论是block、program等逻辑/数据结构，还是具体的<code>.proto</code>储存格式。</p>
<p>LoD Tensor的概念倒是很新鲜，之前看Caffe和Pytorch，不知是我没细看还是怎么，感觉都没有类似的概念。</p>
<p>而Python前端+C++后端这种模式，也让人觉得很亲切。我甚至有点写这种Python“前端”了。</p>
<h3 id="2-Next"><a href="#2-Next" class="headerlink" title="2 Next"></a>2 Next</h3><p>既然是将算法复现，那我趁热把熟悉的手写数字识别和之前大作业的文章内容理解拿过来用一下。</p></div><a href="/2019/12/14/day-191213/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2019/12/12/day-191212/" class="post-title-link">日记 2019.12.12</a></h2><div class="post-info">Dec 12, 2019</div><div class="post-content"><h4 id="1"><a href="#1" class="headerlink" title="1"></a>1</h4><p>用<code>malloc</code>分配内存</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span>* lut = (<span class="keyword">double</span>*) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">double</span>)*d.samples);</span><br></pre></td></tr></table></figure>

<p><code>sizeof(double)</code>=8</p>
<h4 id="2"><a href="#2" class="headerlink" title="2"></a>2</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(d));</span><br></pre></td></tr></table></figure>

<p>而我修改后，直接省去了<code>data</code>这个变量，因为看不到有什么用。（或许是，我修改后的代码，因为使用了智能指针，所以不需要<code>data</code>做某种辅助？）</p>
<p><strong>PS</strong>：在HomeOfVapourSynthEvolution的Curve.cpp，能看到这种“成对”的模式，用<code>malloc</code>和<code>calloc</code>来分配内存的变量都用<code>free</code>做了释放。相比之下，我自己该的代码，在新定义<code>lut</code>这个变量时，用了<code>malloc</code>，却没有用<code>free</code>，而是用<code>delete</code>去删除的。</p>
<p><code>delete</code>不仅释放内存，而且会调用析构函数，而<code>free</code>不会调用析构函数。</p></div><a href="/2019/12/12/day-191212/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2019/12/11/day-191211/" class="post-title-link">日记 2019.12.11</a></h2><div class="post-info">Dec 11, 2019</div><div class="post-content"><p>如果不靠一个类似写日记的方法督促我学习，恐怕这学生阶段最后的时光也要溜走了…</p>
<h3 id="First"><a href="#First" class="headerlink" title="First"></a>First</h3><p>《深入理解C指针》收到了，粗看了一下，收获确实很多，只是我看书的效率有点低啊…不过幸好有之前改代码的经验，配合着看，这样想似乎效率还可以。</p>
<h3 id="Second"><a href="#Second" class="headerlink" title="Second"></a>Second</h3><p>emmm好像没有了，实验要明天才能进行下一步，至于刚看到的竞赛…emmm我早就不是十五岁的少年了，但看到这个竞赛，还是本能地激动。嘛~这样也好，整体死气沉沉地也不行。</p>
<p>不过，必须冷静地看到，竞赛…应当算是一个调剂吧。我知道自己处在什么水平，不要自负也不要自卑，更不要陷入自负与自备的交织中。</p>
<p>中午装好了框架，算是一个开头吧。</p></div><a href="/2019/12/11/day-191211/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2019/11/25/gcc-use-1/" class="post-title-link">Windows下使用gcc/g++编译器</a></h2><div class="post-info">Nov 25, 2019</div><div class="post-content"><h3 id="MSVC：从入门到放弃"><a href="#MSVC：从入门到放弃" class="headerlink" title="MSVC：从入门到放弃"></a>MSVC：从入门到放弃</h3><p>从一开始修改JincResize代码到现在，代码编译后dll运行缓慢的问题一直困扰着我。虽然原作者说运行速度慢，但我自己编译的也太慢了（1.5s vs 9s）。改了一些代码（主要是涉及C语言和C++的区别），但对速度无肉眼可见的影响。这样下去，代码重构也没有动力。</p>
<p>思考了一下，做了一下对照实验。使用原作者代码，直接在VS2019中编译（除了为在VS2019中编译通过，修改了一处代码外，其余代码均未改动），也很慢，也是约9s/帧。这样让我明确了一点，就是编译方面的问题，导致运行速度缓慢的。</p>
<p>我又仿照HomeOfVapourSynthEvolution的预处理设置，并在编译中尽量使用加快代码速度的优化参数，但最终的编译结果仍没有什么改善。</p>
<p>所以我有理由判断，是编译器的锅。（也许是现在的代码，虽然做了从C到C++的迁移，但仍有C的风格，导致和VS的纯C++编译器八字不合？）</p>
<p>不管怎么说，改用gcc/g++。</p></div><a href="/2019/11/25/gcc-use-1/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2019/11/24/rebuild-JincResize/" class="post-title-link">JincResize 代码重构（1）</a></h2><div class="post-info">Nov 24, 2019</div><div class="post-content"><p>前一篇Blog记录了将原作者代码（初步）从C语言迁移到C++上的过程，以及添加8bit输入支持的方法。下一步我想模仿HomeOfVapourSynthEvolution的代码风格，对上述代码进行重构。同时，也期待能发现，我先前修改的代码运行缓慢的原因。</p>
<p>Blog写得详细一些，这也是我学习C++基础知识的过程。</p>
<h3 id="未完成的C语言到C-迁移"><a href="#未完成的C语言到C-迁移" class="headerlink" title="未完成的C语言到C++迁移"></a>未完成的C语言到C++迁移</h3><p>其实C语言和C++的区别还有很多。</p>
<h4 id="C-的类型转换"><a href="#C-的类型转换" class="headerlink" title="C++的类型转换"></a>C++的类型转换</h4><p>编写VapourSynth插件，在四个<code>VS__CC</code>函数的开头，都需要进行类型转换，原始代码使用C语言风格的类型转换，类似下面这样。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FilterData* d = (FilterData*)* instanceData;</span><br></pre></td></tr></table></figure>

<p>如果让代码“更C++”一些，则使用类型转换运算符（Type Conversion Operator）。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FilterData* d = <span class="keyword">static_cast</span>&lt;FilterData*&gt;(*instanceData);</span><br></pre></td></tr></table></figure></div><a href="/2019/11/24/rebuild-JincResize/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2019/11/22/learn-cpp-note-1/" class="post-title-link">C++笔记：某培训课程与21天学通C++</a></h2><div class="post-info">Nov 22, 2019</div><div class="post-content"><h3 id="写在开头的话"><a href="#写在开头的话" class="headerlink" title="写在开头的话"></a>写在开头的话</h3><p>有人讲解，学习效率还是会高一些的吧。</p>
<p>愿我能坚持。更愿我能在写完这个笔记后，继续写学习笔记之二。毕竟，培训班的课程只能算一个开始。</p>
<p>后来在忙其他事情的时候，学到了更多的东西，于是把21天学通C++及网络上资料（主要是菜鸟教程）的学习笔记也记到这上面来。虽然和周记系列有点冲突，但同时进行吧，做下去就能变得清晰。</p></div><a href="/2019/11/22/learn-cpp-note-1/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2019/11/19/trans-c-to-cpp/" class="post-title-link">记一次从C语言到C++的迁移——初次接触VapourSynth API</a></h2><div class="post-info">Nov 19, 2019</div><div class="post-content"><h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>想在VapourSynth中实现Jinc（EWA Lanczos）放大算法，已经有一份实现，<a href="https://github.com/Lypheo/EWA-Resampling-VS" target="_blank" rel="noopener">https://github.com/Lypheo/EWA-Resampling-VS</a> 。但这份代码仅支持整型16bit输入（严格来说是仅支持整型9~16bit输入，作者说仅支持16bit RGB输入，但无论看代码还是实际测试，16bit YUV和10bit YUV都是支持的）。</p>
<p>所以我想在原作者代码的基础上，先完善上述输入问题。至少要支持整型8bit YUV输入，后续再考虑支持32bit浮点数输入。</p>
<p>阅读了原作者代码和其他一些较为成熟的基于VapourSynth实现的代码，大致明白了VapourSynth API调用的过程和基础的代码结构。至少对于Jinc算法，在整型8-16bit的范围内，支持的输入类型仅取决于关键变量的类型定义（这话看起来是一句正确的废话，要怪就怪C++是一门强类型语言Orz）。</p>
<p>再具体一点，支持8bit需要使用<code>uint8_t</code>来定义关键变量，支持9~16bit需要使用<code>unit16_t</code>来定义关键变量。所以要在代码中，根据输入视频的位深进行类型转换。</p>
<p>在C语言中，我能想到的就是使用宏来完成上述过程。但是复杂一点宏我就不会写…而且宏也不安全…我还是用C++的模板来写吧。看了一下不同前辈们的代码，也都是用模板来写的，<del>方便Copy</del>。</p></div><a href="/2019/11/19/trans-c-to-cpp/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2019/11/03/git-use-1/" class="post-title-link">Git的使用：创建SSH key、多账号共存、提交代码及进阶使用</a></h2><div class="post-info">Nov 3, 2019</div><div class="post-content"><h2 id="创建SSH-key"><a href="#创建SSH-key" class="headerlink" title="创建SSH key"></a>创建SSH key</h2><h3 id="创建密钥"><a href="#创建密钥" class="headerlink" title="创建密钥"></a>创建密钥</h3><p>在Windows下，使用Git bash，创建秘钥。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa</span><br></pre></td></tr></table></figure>

<p>在这一步可以使用<code>-C &#39;comment&#39;</code>对秘钥进行注释。一些教程中要求在<code>-C</code>后写邮箱，其实写什么都可以，不写也行，注释而已。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C <span class="string">'comment'</span></span><br></pre></td></tr></table></figure>

<p>默认的密钥为2048位，可以使用<code>-b</code>指定密钥位数。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -b 4096 -C <span class="string">'comment'</span></span><br></pre></td></tr></table></figure>

<p>之后会确认密钥文件的存放位置和文件名，如下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Enter file in which to save the key (&#x2F;c&#x2F;Users&#x2F;UserName&#x2F;.ssh&#x2F;id_rsa):</span><br></pre></td></tr></table></figure>

<p>回车即使用括号内的默认位置和名称，如果有多个密钥文件，注意修改文件名。如果不更改存放位置，只修改文件名，直接输入想要的文件名即可。密钥的私钥文件无后缀，公钥文件无需命名，与私钥一致，以<code>.pub</code>为后缀。</p>
<p>之后会要求设置密码，回车则密码留空。</p>
<p>看到<code>The key&#39;s randomart image is:</code>和创建密钥时的随机图像，即为创建成功。</p></div><a href="/2019/11/03/git-use-1/" class="read-more">...more</a></article></li></ul></main><footer><div class="paginator"><a href="/page/4/" class="prev">PREV</a><a href="/page/6/" class="next">NEXT</a></div><div class="copyright"><p>© 2019 - 2020 <a href="http://yoursite.com">Kiyamou</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>